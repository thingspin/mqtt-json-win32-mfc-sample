; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\lonycell\Downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT

PUBLIC	?all@Features@Json@@SA?AV12@XZ			; Json::Features::all
PUBLIC	?strictMode@Features@Json@@SA?AV12@XZ		; Json::Features::strictMode
PUBLIC	??0Features@Json@@QAE@XZ			; Json::Features::Features
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	_sscanf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0Reader@Json@@QAE@XZ				; Json::Reader::Reader
PUBLIC	??0Reader@Json@@QAE@ABVFeatures@1@@Z		; Json::Reader::Reader
PUBLIC	?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
PUBLIC	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z	; Json::Reader::parse
PUBLIC	?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
PUBLIC	?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormatedErrorMessages
PUBLIC	??1ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::~ErrorInfo
PUBLIC	?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ; Json::Reader::expectToken
PUBLIC	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readToken
PUBLIC	?skipSpaces@Reader@Json@@AAEXXZ			; Json::Reader::skipSpaces
PUBLIC	?match@Reader@Json@@AAE_NPBDH@Z			; Json::Reader::match
PUBLIC	?readComment@Reader@Json@@AAE_NXZ		; Json::Reader::readComment
PUBLIC	?readCStyleComment@Reader@Json@@AAE_NXZ		; Json::Reader::readCStyleComment
PUBLIC	?readCppStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCppStyleComment
PUBLIC	?readString@Reader@Json@@AAE_NXZ		; Json::Reader::readString
PUBLIC	?readNumber@Reader@Json@@AAEXXZ			; Json::Reader::readNumber
PUBLIC	?readValue@Reader@Json@@AAE_NXZ			; Json::Reader::readValue
PUBLIC	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readObject
PUBLIC	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readArray
PUBLIC	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeNumber
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeString
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
PUBLIC	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeDouble
PUBLIC	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
PUBLIC	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
PUBLIC	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
PUBLIC	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
PUBLIC	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
PUBLIC	?currentValue@Reader@Json@@AAEAAVValue@2@XZ	; Json::Reader::currentValue
PUBLIC	?getNextChar@Reader@Json@@AAEDXZ		; Json::Reader::getNextChar
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
PUBLIC	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
PUBLIC	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens
PUBLIC	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
PUBLIC	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
PUBLIC	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
PUBLIC	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
PUBLIC	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
PUBLIC	??1Reader@Json@@QAE@XZ				; Json::Reader::~Reader
PUBLIC	??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z ; Json::operator>>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ ; `string'
PUBLIC	??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ ; `string'
PUBLIC	??_C@_03FFDNHNKN@rue?$AA@			; `string'
PUBLIC	??_C@_04KCECFHEP@alse?$AA@			; `string'
PUBLIC	??_C@_03KNPGGKC@ull?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ ; `string'
PUBLIC	??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ ; `string'
PUBLIC	??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ ; `string'
PUBLIC	??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ ; `string'
PUBLIC	??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ ; `string'
PUBLIC	??_C@_01GEODFPGF@?8?$AA@			; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ ; `string'
PUBLIC	??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ ; `string'
PUBLIC	??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@	; `string'
PUBLIC	??_C@_04JBAOJHKB@See?5?$AA@			; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	??0Value@Json@@QAE@W4ValueType@1@@Z:PROC	; Json::Value::Value
EXTRN	??0Value@Json@@QAE@H@Z:PROC			; Json::Value::Value
EXTRN	??0Value@Json@@QAE@I@Z:PROC			; Json::Value::Value
EXTRN	??0Value@Json@@QAE@N@Z:PROC			; Json::Value::Value
EXTRN	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Json::Value::Value
EXTRN	??0Value@Json@@QAE@_N@Z:PROC			; Json::Value::Value
EXTRN	??1Value@Json@@QAE@XZ:PROC			; Json::Value::~Value
EXTRN	??4Value@Json@@QAEAAV01@ABV01@@Z:PROC		; Json::Value::operator=
EXTRN	?isArray@Value@Json@@QBE_NXZ:PROC		; Json::Value::isArray
EXTRN	?isObject@Value@Json@@QBE_NXZ:PROC		; Json::Value::isObject
EXTRN	??AValue@Json@@QAEAAV01@I@Z:PROC		; Json::Value::operator[]
EXTRN	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Json::Value::operator[]
EXTRN	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z:PROC ; Json::Value::setComment
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?minInt@Value@Json@@2HB:DWORD			; Json::Value::minInt
EXTRN	?maxInt@Value@Json@@2HB:DWORD			; Json::Value::maxInt
EXTRN	?maxUInt@Value@Json@@2IB:DWORD			; Json::Value::maxUInt
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT
??_C@_04JBAOJHKB@See?5?$AA@ DB 'See ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
CONST	SEGMENT
??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@ DB ' for detail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5?$AA@ DB '* ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ DB 'Line %d, Column '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: hexadecimal digit expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: four digits expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
CONST	SEGMENT
??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ DB 'expecting '
	DB	'another \u token to begin the second half of a unicode surrog'
	DB	'ate pair', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
CONST	SEGMENT
??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ DB 'additional si'
	DB	'x characters expected to parse unicode surrogate pair.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ DB 'Bad escape '
	DB	'sequence in string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ DB 'Empty esc'
	DB	'ape sequence in string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT
??_C@_01GEODFPGF@?8?$AA@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
CONST	SEGMENT
??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ DB ''' is not a number.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
CONST	SEGMENT
??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ DB 'Mi'
	DB	'ssing '','' or '']'' in array declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT
??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ DB 'Missin'
	DB	'g ''}'' or object member name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT
??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ DB 'Mi'
	DB	'ssing '','' or ''}'' in object declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
CONST	SEGMENT
??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ DB 'Missing '
	DB	''':'' after object member name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT
??_C@_03KNPGGKC@ull?$AA@ DB 'ull', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
CONST	SEGMENT
??_C@_04KCECFHEP@alse?$AA@ DB 'alse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT
??_C@_03FFDNHNKN@rue?$AA@ DB 'rue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
CONST	SEGMENT
??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ DB 'Syntax err'
	DB	'or: value, object or array expected.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
CONST	SEGMENT
??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ DB 'A valid JS'
	DB	'ON document must be either an array or an object value.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z$0
__ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z$1
__ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z$2
__ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$27 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$27
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$26
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0
__ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$1
__ehfuncinfo$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z$41
__ehfuncinfo$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1
__ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0
__ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
__ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
__ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4
__ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1
__ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readValue@Reader@Json@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3
__ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?readValue@Reader@Json@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0
__ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0
__ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0
__ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0
__ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$0
__ehfuncinfo$??0Reader@Json@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00@Z PROC ; std::_Copy_memmove<Json::Value * * *,Json::Value * * *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00@Z ENDP ; std::_Copy_memmove<Json::Value * * *,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00@Z PROC ; std::_Copy_memmove<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00@Z ENDP ; std::_Copy_memmove<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+12], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	pop	ebp
	ret	4
??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PAPAVValue@Json@@PAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked1@PAPAVValue@Json@@PAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<Json::Value * *,Json::Value * *,std::allocator<Json::Value * *> >, COMDAT

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 241  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked1@PAPAVValue@Json@@PAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<Json::Value * *,Json::Value * *,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAPAVValue@Json@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAPAVValue@Json@@0@Z PROC ; std::_Ptr_copy_cat<Json::Value * *,Json::Value * *>, COMDAT

; 792  : 	{	// return pointer copy optimization category for pointers

	push	ebp
	mov	ebp, esp

; 793  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 794  : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAPAVValue@Json@@0@Z ENDP ; std::_Ptr_copy_cat<Json::Value * *,Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+12]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN108@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
$LN108@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+12], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PAVErrorInfo@Reader@Json@@PAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked1@PAVErrorInfo@Reader@Json@@PAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 241  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked1@PAVErrorInfo@Reader@Json@@PAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@0@Z PROC ; std::_Ptr_copy_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>, COMDAT

; 792  : 	{	// return pointer copy optimization category for pointers

	push	ebp
	mov	ebp, esp

; 793  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 794  : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Ptr_copy_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z PROC ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ENDP ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value *>::destroy<Json::Value *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value *>::destroy<Json::Value * *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN5@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+12], 0
$LN5@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	pop	ebp
	ret	0
??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	SHORT $LN3@construct
	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN4@sentry

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN4@sentry:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 123  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 124  : 			}

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 117  : 			{	// construct locking and calling _Ipfx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 93   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN5@sentry:

; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	DWORD PTR __Noskip$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	BYTE PTR [esi+4], al

; 119  : 			}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 103  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 94   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 93   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	push	esi

; 94   : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 95   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 97   : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Json::Value * *>,Json::Value * * *>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Json::Value * *>,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >, COMDAT

; 470  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

	push	ebp
	mov	ebp, esp

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	push	0
	push	DWORD PTR __First$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 472  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n1@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z PROC ; std::_Rechecked<Json::Value * * *,Json::Value * * *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 458  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z ENDP ; std::_Rechecked<Json::Value * * *,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_al_unchecked@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 252  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z PROC ; std::_Unchecked<Json::Value * * *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 428  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 429  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ENDP ; std::_Unchecked<Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value *>, COMDAT
; _this$ = ecx

; 710  : 		}

	mov	eax, ecx
	ret	4
??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN8@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 710  : 		}

	mov	eax, ecx
	ret	4
??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1039 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>, COMDAT

; 863  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN18@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+12]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN18@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN110@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	pop	ebp
	ret	0
$LN110@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+12], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	pop	ebp
	ret	0
??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 470  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

	push	ebp
	mov	ebp, esp

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	push	0
	push	DWORD PTR __First$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 472  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n1@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z PROC ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 458  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z ENDP ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_al_unchecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 252  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z PROC ; std::_Unchecked<Json::Reader::ErrorInfo * *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 428  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 429  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ENDP ; std::_Unchecked<Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 710  : 		}

	mov	eax, ecx
	ret	4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>, COMDAT
; _this$ = ecx

; 710  : 		}

	mov	eax, ecx
	ret	4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<Json::Value *> > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<Json::Value *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 796  : 	return (true);

	mov	al, 1

; 797  : 	}

	ret	0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

	mov	al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

	ret	0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@$$V@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VErrorInfo@Reader@Json@@$$V@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN7@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+12], 0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	pop	ebp
	ret	4
??$construct@VErrorInfo@Reader@Json@@$$V@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	SHORT $LN8@construct
	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z$1:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z PROC ; std::forward<Json::Reader::ErrorInfo const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ENDP ; std::forward<Json::Reader::ErrorInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PBD@std@@YAPBDPBD@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PBD@std@@YAPBDPBD@Z PROC			; std::_Unchecked<char const *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 428  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 429  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PBD@std@@YAPBDPBD@Z ENDP			; std::_Unchecked<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 598  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 598  : 		}

	ret	4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z PROC ; std::pointer_traits<std::_Container_proxy *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp

; 280  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 281  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ENDP ; std::pointer_traits<std::_Container_proxy *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Value * *>,Json::Value * * *>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Value * *>,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >, COMDAT

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ebp
	mov	ebp, esp

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	DWORD PTR __Al$[ebp], eax
	mov	DWORD PTR __Count$[ebp], 0

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,
; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	pop	ebp

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	jmp	_memset
??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 265  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1><>, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [ecx+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [ecx+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [ecx+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN13@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

	push	ebp
	mov	ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 927  : 		}

	pop	ebp
	ret	4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 536870911				; 1fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 3

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN20@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+12]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN20@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN112@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
$LN112@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+12], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ebp
	mov	ebp, esp

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	DWORD PTR __Al$[ebp], eax
	mov	DWORD PTR __Count$[ebp], 0

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,
; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	pop	ebp

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	jmp	_memset
??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 265  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAV123@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAV123@@Z PROC ; std::addressof<Json::Reader::ErrorInfo *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	0
??$addressof@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAV123@@Z ENDP ; std::addressof<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::forward<Json::Value *>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::forward<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN15@Deque_iter

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN15@Deque_iter

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN15@Deque_iter:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 642  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [ecx]
	push	esi

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	xor	esi, esi

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN17@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN17@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	esi, DWORD PTR [eax]
$LN17@operator:

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 626  : 		this->_Myoff += _Off;

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], edx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	esi, esi
	je	SHORT $LN37@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	ecx, DWORD PTR [esi]

; 150  : 		if (_Parent == 0)

	test	ecx, ecx
	je	SHORT $LN37@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN37@operator:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 645  : 		}

	pop	ebp
	ret	8
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=, COMDAT
; _this$ = ecx

; 637  : 		{	// decrement by integer

	push	ebp
	mov	ebp, esp

; 626  : 		this->_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	sub	DWORD PTR [ecx+8], eax

; 638  : 		return (*this += -_Off);

	mov	eax, ecx

; 639  : 		}

	pop	ebp
	ret	4
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 625  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 626  : 		this->_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+8], eax

; 627  : 		return (*this);

	mov	eax, ecx

; 628  : 		}

	pop	ebp
	ret	4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	push	esi
	test	eax, eax
	jne	SHORT $LN7@operator
	xor	esi, esi
	jmp	SHORT $LN8@operator
$LN7@operator:
	mov	esi, DWORD PTR [eax]
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	shr	ecx, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]

; 590  : 		return ((reference)**(_Mybase *)this);
; 591  : 		}

	ret	0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 572  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp

; 303  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN13@Deque_iter

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@Deque_iter:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 573  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@Deque_cons:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont, COMDAT
; _this$ = ecx

; 518  : 		{	// set container pointer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]
	test	eax, eax
	je	SHORT $LN5@Setcont

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN5@Setcont:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 520  : 		}

	pop	ebp
	ret	4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	push	esi
	test	eax, eax
	jne	SHORT $LN5@operator
	xor	esi, esi
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	esi, DWORD PTR [eax]
$LN6@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	shr	ecx, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]

; 344  : 		}

	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp

; 303  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN11@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN11@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 306  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@PAVValue@Json@@@std@@YAPAPAVValue@Json@@PAPAV12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAVValue@Json@@@std@@YAPAPAVValue@Json@@PAPAV12@@Z PROC ; std::_Unfancy<Json::Value *>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	0
??$_Unfancy@PAVValue@Json@@@std@@YAPAPAVValue@Json@@PAPAV12@@Z ENDP ; std::_Unfancy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAV12@@Z PROC ; std::addressof<Json::Value * *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	0
??$addressof@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAV12@@Z ENDP ; std::addressof<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1><>, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [ecx+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [ecx+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [ecx+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 598  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 598  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

	xor	al, al

; 1027 : 	}

	ret	0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>, COMDAT
; _this$ = ecx

; 1185 : 		{	// insert element at end

	push	esi
	mov	esi, ecx

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN2@emplace_ba
	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@emplace_ba:
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	and	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [esi+16]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]

; 1187 : 		_PUSH_BACK_BEGIN;

	add	ecx, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	and	ecx, eax

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	push	edi
	lea	edi, DWORD PTR [ecx*4]
	cmp	DWORD PTR [edi+eax], 0
	jne	SHORT $LN3@emplace_ba
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	ecx, ecx
	jne	SHORT $LN113@emplace_ba
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN279@emplace_ba:
$LN113@emplace_ba:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+eax], ecx
$LN3@emplace_ba:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+eax]
	pop	edi
	test	eax, eax
	je	SHORT $LN150@emplace_ba
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+12], 0
$LN150@emplace_ba:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1191 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]
	pop	esi

; 1192 : 		}

	ret	0
$LN278@emplace_ba:
??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	SHORT $LN13@construct
	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z$2:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z PROC ; std::_Unfancy<Json::Reader::ErrorInfo>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	0
??$_Unfancy@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z ENDP ; std::_Unfancy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::move<Json::Value * &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	0
??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::move<Json::Value * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont, COMDAT
; _this$ = ecx

; 518  : 		{	// set container pointer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]
	test	eax, eax
	je	SHORT $LN5@Setcont

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN5@Setcont:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 520  : 		}

	pop	ebp
	ret	4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat, COMDAT
; _this$ = ecx

; 514  : 		}

	ret	4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 472  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	setne	al

; 473  : 		return (!(*this == _Right));
; 474  : 		}

	pop	ebp
	ret	4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==, COMDAT
; _this$ = ecx

; 466  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	sete	al

; 467  : 		_Compat(_Right);
; 468  : 		return (this->_Myoff == _Right._Myoff);
; 469  : 		}

	pop	ebp
	ret	4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++, COMDAT
; _this$ = ecx

; 353  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 354  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 355  : 		if (_Mycont == 0
; 356  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 357  : 		{	// report error
; 358  : 		_DEBUG_ERROR("deque iterator not incrementable");
; 359  : 		_SCL_SECURE_OUT_OF_RANGE;
; 360  : 		}
; 361  : 
; 362  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 363  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 364  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 365  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 366  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 367  : 
; 368  : 		++_Myoff;

	inc	DWORD PTR [ecx+8]

; 369  : 		return (*this);

	mov	eax, ecx

; 370  : 		}

	ret	0
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		{	// return designated object

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jne	SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, DWORD PTR [edx+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+ecx*4]

; 344  : 		}

	ret	0
$LN5@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, DWORD PTR [edx+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+ecx*4]

; 344  : 		}

	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp

; 303  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN11@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN11@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 306  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2439 : 	{	// return string + NTCS

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR __Right$[ebp]
	push	esi
	mov	DWORD PTR $T1[ebp], 0
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN9@operator
	xor	eax, eax
	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	eax, edx
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL143@operator:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL143@operator
	sub	eax, esi
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR __Left$[ebp]
	push	eax
	push	edx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	push	eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 2440 : 	return (_STD move(_Left.append(_Right)));

	mov	eax, esi
	pop	esi

; 2441 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2417 : 	{	// return NTCS + string

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR __Left$[ebp]
	push	esi
	mov	DWORD PTR $T1[ebp], 0
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN9@operator
	xor	eax, eax
	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	eax, edx
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL143@operator:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL143@operator
	sub	eax, esi
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR __Right$[ebp]
	push	eax
	push	edx
	push	0
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	push	eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 2418 : 	return (_STD move(_Right.insert(0, _Left)));

	mov	eax, esi
	pop	esi

; 2419 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2327 : 	{	// return NTCS + string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 496  : 		_Mysize(0),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN109@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN110@operator
$LN109@operator:
	mov	eax, esi
$LN110@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0

; 523  : 		return (*_First == 0 ? 0

	mov	edi, DWORD PTR __Left$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2332 : 	return (_Ans);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN118@operator
	xor	ecx, ecx
	jmp	SHORT $LN119@operator
$LN118@operator:
	mov	ecx, edi
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL192@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL192@operator
	sub	ecx, edx
$LN119@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2329 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());

	mov	eax, DWORD PTR __Right$[ebp]

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	ebx, DWORD PTR [esi+16]

; 2329 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());

	mov	eax, DWORD PTR [eax+16]
	add	eax, ecx

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	ebx, eax
	ja	SHORT $LN178@operator
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN178@operator

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, esi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN178@operator

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN173@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN174@operator
$LN173@operator:
	mov	eax, esi
$LN174@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
$LN178@operator:

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN186@operator
	xor	ecx, ecx
	jmp	SHORT $LN187@operator
$LN186@operator:
	mov	ecx, edi
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL193@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL193@operator
	sub	ecx, edx
$LN187@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edi
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2332 : 	return (_Ans);

	mov	eax, esi

; 2333 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN4@operator
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
	ret	0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0PBDX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$?0PBDX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0ABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char const *,void>, COMDAT
; _this$ = ecx

; 867  : 		{	// construct from [_First, _Last) with optional allocator

	push	ebp
	mov	ebp, esp

; 905  : 		if (_First != _Last)

	mov	eax, DWORD PTR __Last$[ebp]
	push	esi

; 867  : 		{	// construct from [_First, _Last) with optional allocator

	mov	esi, ecx

; 905  : 		if (_First != _Last)

	mov	ecx, DWORD PTR __First$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	ecx, eax
	je	SHORT $LN124@allocator

; 906  : 			assign(_First, _Last - _First);

	sub	eax, ecx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN124@allocator:

; 868  : 		_DEBUG_RANGE(_First, _Last);
; 869  : 		_Tidy();
; 870  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>());
; 871  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	12					; 0000000cH
??$?0PBDX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0ABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char const *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Ok$ = -36						; size = 8
__State$ = -28						; size = 4
__Metadelim$1$ = -24					; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 77   : 	{	// get characters into string, discard delimiter

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 93   : 			: _Myistr(_Istr)

	mov	esi, DWORD PTR __Istr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 80   : 	ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 81   : 	bool _Changed = false;

	xor	bl, bl
	mov	DWORD PTR __State$[ebp], edi
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 93   : 			: _Myistr(_Istr)

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN24@getline

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN24@getline:

; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	1
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	BYTE PTR __Ok$[ebp+4], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 82   : 	const typename _Myis::sentry _Ok(_Istr, true);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 83   : 
; 84   : 	if (_Ok)

	test	al, al
	je	$LN137@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 86   : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN60@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN60@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0

; 589  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR __Delim$[ebp]
	mov	DWORD PTR __Metadelim$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 90   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
$LN140@getline:
	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	ecx, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 93   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	test	al, al
	je	SHORT $LN7@getline

; 94   : 				{	// end of file, quit
; 95   : 				_State |= ios_base::eofbit;

	mov	edi, 1

; 96   : 				break;

	jmp	SHORT $LN3@getline
$LN7@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	ecx, DWORD PTR __Metadelim$1$[ebp]
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 98   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

	test	al, al
	je	SHORT $LN9@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 100  : 				_Changed = true;

	mov	bl, 1
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 101  : 				_Istr.rdbuf()->sbumpc();

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 102  : 				break;

	jmp	SHORT $LN3@getline
$LN9@getline:

; 103  : 				}
; 104  : 			else if (_Str.max_size() <= _Str.size())

	mov	eax, DWORD PTR __Str$[ebp]
	cmp	DWORD PTR [eax+16], -2			; fffffffeH
	jb	SHORT $LN11@getline

; 105  : 				{	// string too large, quit
; 106  : 				_State |= ios_base::failbit;

	mov	edi, 2
	jmp	SHORT $LN3@getline
$LN11@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	ecx
	push	1
	mov	ecx, eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 112  : 				_Changed = true;

	mov	bl, 1
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 92   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
	jmp	SHORT $LN140@getline
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:

; 113  : 				}
; 114  : 		_CATCH_IO_(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN19@getline
	ret	0
$LN19@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	esi, DWORD PTR __Istr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	mov	bl, BYTE PTR __Changed$[ebp]
$LN3@getline:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 115  : 		}
; 116  : 
; 117  : 	if (!_Changed)

	test	bl, bl
	jne	SHORT $LN13@getline
$LN137@getline:

; 118  : 		_State |= ios_base::failbit;

	or	edi, 2
$LN13@getline:

; 119  : 	_Istr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	push	0
	push	edi
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+eax+56]
	test	ecx, ecx
	je	SHORT $LN138@getline

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN138@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 120  : 	return (_Istr);

	mov	eax, esi

; 121  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$26:
	call	___std_terminate
	ret	0
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 150  : 	{	// get characters into string, discard delimiter

	push	ebp
	mov	ebp, esp

; 152  : 	}

	pop	ebp

; 151  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	jmp	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_cp$ = 12						; size = 4
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::codePointToUTF8, COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN116@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN117@codePointT
$LN116@codePointT:
	mov	eax, esi
$LN117@codePointT:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 102  :    return result;

	mov	ebx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 1
	cmp	ebx, 127				; 0000007fH
	ja	SHORT $LN2@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, 1
	jb	SHORT $LN126@codePointT

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 1

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN148@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+1], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN127@codePointT
$LN148@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+1], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN127@codePointT
$LN126@codePointT:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	mov	eax, 1
	sub	eax, ecx
	mov	ecx, esi
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN127@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN176@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	$LN177@codePointT
$LN176@codePointT:
	mov	eax, esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 78   :       result[0] = static_cast<char>(cp);

	jmp	$LN177@codePointT
$LN2@codePointT:

; 79   :    } 
; 80   :    else if (cp <= 0x7FF) 

	cmp	ebx, 2047				; 000007ffH
	ja	SHORT $LN4@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, 2
	jb	SHORT $LN183@codePointT

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 2

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN205@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+2], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN184@codePointT
$LN205@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+2], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN184@codePointT
$LN183@codePointT:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	mov	eax, 2
	sub	eax, ecx
	mov	ecx, esi
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN184@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN233@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN234@codePointT
$LN233@codePointT:
	mov	ecx, esi
$LN234@codePointT:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 83   :       result[1] = static_cast<char>(0x80 | (0x3f & cp));

	mov	al, bl
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+1], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN249@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 84   :       result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));

	shr	ebx, 6
	and	bl, 31					; 0000001fH
	or	bl, -64					; ffffffc0H
	jmp	$LN177@codePointT
$LN249@codePointT:
	shr	ebx, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 84   :       result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));

	and	bl, 31					; 0000001fH
	or	bl, -64					; ffffffc0H
	jmp	$LN177@codePointT
$LN4@codePointT:

; 85   :    } 
; 86   :    else if (cp <= 0xFFFF) 

	cmp	ebx, 65535				; 0000ffffH
	ja	$LN6@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, 3
	jb	SHORT $LN256@codePointT

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 3

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN278@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+3], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN257@codePointT
$LN278@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+3], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN257@codePointT
$LN256@codePointT:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	mov	eax, 3
	sub	eax, ecx
	mov	ecx, esi
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN257@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN306@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN307@codePointT
$LN306@codePointT:
	mov	ecx, esi
$LN307@codePointT:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 89   :       result[2] = static_cast<char>(0x80 | (0x3f & cp));

	mov	al, bl
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+2], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN322@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN323@codePointT
$LN322@codePointT:
	mov	ecx, esi
$LN323@codePointT:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 90   :       result[1] = 0x80 | static_cast<char>((0x3f & (cp >> 6)));

	mov	eax, ebx
	shr	eax, 6
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+1], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN338@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 91   :       result[0] = 0xE0 | static_cast<char>((0xf & (cp >> 12)));

	shr	ebx, 12					; 0000000cH
	and	bl, 15					; 0000000fH
	or	bl, -32					; ffffffe0H
	jmp	SHORT $LN177@codePointT
$LN338@codePointT:
	shr	ebx, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 91   :       result[0] = 0xE0 | static_cast<char>((0xf & (cp >> 12)));

	and	bl, 15					; 0000000fH
	or	bl, -32					; ffffffe0H
	jmp	SHORT $LN177@codePointT
$LN6@codePointT:

; 92   :    }
; 93   :    else if (cp <= 0x10FFFF) 

	cmp	ebx, 1114111				; 0010ffffH
	ja	SHORT $LN406@codePointT

; 94   :    {
; 95   :       result.resize(4);

	push	4
	mov	ecx, esi
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN354@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN355@codePointT
$LN354@codePointT:
	mov	ecx, esi
$LN355@codePointT:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 96   :       result[3] = static_cast<char>(0x80 | (0x3f & cp));

	mov	al, bl
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+3], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN370@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN371@codePointT
$LN370@codePointT:
	mov	ecx, esi
$LN371@codePointT:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 97   :       result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));

	mov	eax, ebx
	shr	eax, 6
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+2], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN386@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN387@codePointT
$LN386@codePointT:
	mov	ecx, esi
$LN387@codePointT:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 98   :       result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));

	mov	eax, ebx
	shr	eax, 12					; 0000000cH
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+1], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN402@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN403@codePointT
$LN402@codePointT:
	mov	eax, esi
$LN403@codePointT:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 99   :       result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));

	shr	ebx, 18					; 00000012H
	and	bl, 7
	or	bl, -16					; fffffff0H
$LN177@codePointT:
	mov	BYTE PTR [eax], bl
$LN406@codePointT:

; 102  :    return result;

	mov	eax, esi

; 103  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN11@codePointT
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN11@codePointT:
	ret	0
__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::codePointToUTF8
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?containsNewLine@Json@@YA_NPBD0@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?containsNewLine@Json@@YA_NPBD0@Z PROC			; Json::containsNewLine, COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp

; 63   :    for ( ;begin < end; ++begin )

	mov	eax, DWORD PTR _begin$[ebp]
	mov	edx, DWORD PTR _end$[ebp]
	cmp	eax, edx
	jae	SHORT $LN3@containsNe
	npad	3
$LL4@containsNe:

; 64   :       if ( *begin == '\n'  ||  *begin == '\r' )

	mov	cl, BYTE PTR [eax]
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN9@containsNe
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN9@containsNe

; 63   :    for ( ;begin < end; ++begin )

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL4@containsNe
$LN3@containsNe:

; 66   :    return false;

	xor	al, al

; 67   : }

	pop	ebp
	ret	0
$LN9@containsNe:

; 65   :          return true;

	mov	al, 1

; 67   : }

	pop	ebp
	ret	0
?containsNewLine@Json@@YA_NPBD0@Z ENDP			; Json::containsNewLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?in@Json@@YA_NDDDDDD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
_c1$ = 12						; size = 1
_c2$ = 16						; size = 1
_c3$ = 20						; size = 1
_c4$ = 24						; size = 1
_c5$ = 28						; size = 1
?in@Json@@YA_NDDDDDD@Z PROC				; Json::in, COMDAT

; 54   : {

	push	ebp
	mov	ebp, esp

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	mov	al, BYTE PTR _c$[ebp]
	cmp	al, BYTE PTR _c1$[ebp]
	je	SHORT $LN3@in
	cmp	al, BYTE PTR _c2$[ebp]
	je	SHORT $LN3@in
	cmp	al, BYTE PTR _c3$[ebp]
	je	SHORT $LN3@in
	cmp	al, BYTE PTR _c4$[ebp]
	je	SHORT $LN3@in
	cmp	al, BYTE PTR _c5$[ebp]
	je	SHORT $LN3@in
	xor	al, al

; 56   : }

	pop	ebp
	ret	0
$LN3@in:

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	mov	al, 1

; 56   : }

	pop	ebp
	ret	0
?in@Json@@YA_NDDDDDD@Z ENDP				; Json::in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?in@Json@@YA_NDDDDD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
_c1$ = 12						; size = 1
_c2$ = 16						; size = 1
_c3$ = 20						; size = 1
_c4$ = 24						; size = 1
?in@Json@@YA_NDDDDD@Z PROC				; Json::in, COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	mov	al, BYTE PTR _c$[ebp]
	cmp	al, BYTE PTR _c1$[ebp]
	je	SHORT $LN3@in
	cmp	al, BYTE PTR _c2$[ebp]
	je	SHORT $LN3@in
	cmp	al, BYTE PTR _c3$[ebp]
	je	SHORT $LN3@in
	cmp	al, BYTE PTR _c4$[ebp]
	je	SHORT $LN3@in
	xor	al, al

; 50   : }

	pop	ebp
	ret	0
$LN3@in:

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	mov	al, 1

; 50   : }

	pop	ebp
	ret	0
?in@Json@@YA_NDDDDD@Z ENDP				; Json::in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
_TEXT	SEGMENT
__InitData$2 = -172					; size = 8
$T3 = -164						; size = 12
_reader$ = -152						; size = 112
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z PROC ; Json::operator>>, COMDAT

; 876  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR _sin$[ebp]

; 877  :     Json::Reader reader;

	lea	ecx, DWORD PTR _reader$[ebp]
	mov	esi, DWORD PTR _root$[ebp]
	call	??0Reader@Json@@QAE@XZ			; Json::Reader::Reader

; 878  :     bool ok = reader.parse(sin, root, true);

	push	1
	push	esi
	push	edi
	lea	ecx, DWORD PTR _reader$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse

; 880  :     if (!ok) throw std::runtime_error(reader.getFormatedErrorMessages());

	lea	ecx, DWORD PTR _reader$[ebp]
	test	al, al
	jne	SHORT $LN2@operator
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormatedErrorMessages
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 880  :     if (!ok) throw std::runtime_error(reader.getFormatedErrorMessages());

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN22@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$2[ebp], eax
	xorps	xmm0, xmm0

; 55   :         __std_exception_copy(&_InitData, &_Data);

	lea	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR $T3[ebp], OFFSET ??_7exception@std@@6B@
	push	eax
	lea	eax, DWORD PTR __InitData$2[ebp]
	movq	QWORD PTR $T3[ebp+4], xmm0
	push	eax
	mov	BYTE PTR __InitData$2[ebp+4], 1
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept

; 163  : 		{	// construct from message string

	mov	DWORD PTR $T3[ebp], OFFSET ??_7runtime_error@std@@6B@
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 880  :     if (!ok) throw std::runtime_error(reader.getFormatedErrorMessages());

	lea	eax, DWORD PTR $T3[ebp]
	push	OFFSET __TI2?AVruntime_error@std@@
	push	eax
	call	__CxxThrowException@8
$LN29@operator:
$LN2@operator:

; 881  :     return sin;

	call	??1Reader@Json@@QAE@XZ
	mov	eax, edi

; 882  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$0:
	lea	ecx, DWORD PTR _reader$[ebp]
	jmp	??1Reader@Json@@QAE@XZ
__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$1:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z ENDP ; Json::operator>>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??1Reader@Json@@QAE@XZ PROC				; Json::Reader::~Reader, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+104]
	lea	esi, DWORD PTR [edi+84]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@Reader
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN9@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@Reader
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN101@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	lea	esi, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN114@Reader
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN114@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN206@Reader
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN206@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1244 : 		_Tidy();

	lea	ecx, DWORD PTR [edi+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [edi+20]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [edi+20], 0

; 1244 : 		_Tidy();

	mov	ecx, edi
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [edi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi
	ret	0
??1Reader@Json@@QAE@XZ ENDP				; Json::Reader::~Reader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1841 : 		{	// free all storage

	push	esi
	mov	esi, ecx
	push	edi

; 1393 : 		return (this->_Mysize() == 0);

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx

; 1842 : 		_Alpty _Almap(this->_Getal());
; 1843 : 		while (!empty())

	je	SHORT $LN371@Tidy
	npad	5
$LL2@Tidy:

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+12]
	dec	eax
	add	ecx, eax

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]
	dec	eax
	and	ecx, eax

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR [edi+32]
	add	edi, 12					; 0000000cH
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN175@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN170@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	jne	SHORT $LN361@Tidy

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN361@Tidy

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN361@Tidy

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	ja	SHORT $LN361@Tidy

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN170@Tidy:

; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN175@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN198@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN198@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN29@Tidy

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN29@Tidy:

; 1393 : 		return (this->_Mysize() == 0);

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx

; 1842 : 		_Alpty _Almap(this->_Getal());
; 1843 : 		while (!empty())

	jne	SHORT $LL2@Tidy
$LN371@Tidy:

; 1845 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN5@Tidy
	npad	2
$LL4@Tidy:

; 1846 : 			{	// free storage for a block and destroy pointer
; 1847 : 			if (this->_Map()[--_Block] != pointer())

	mov	eax, DWORD PTR [esi+4]
	dec	edi
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN7@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1845 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	test	edi, edi
	jne	SHORT $LL4@Tidy
$LN5@Tidy:

; 1848 : 				{	// free block and destroy its pointer
; 1849 : 				this->_Getal().deallocate(this->_Map()[_Block], _DEQUESIZ);
; 1850 : 				this->_Getal().destroy(_STD addressof(this->_Map()[_Block]));
; 1851 : 				}
; 1852 : 			}
; 1853 : 
; 1854 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN334@Tidy

; 1855 : 			_Almap.deallocate(this->_Map(),

	mov	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN328@Tidy
$LN361@Tidy:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN374@Tidy:
$LN328@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN329@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN330@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN375@Tidy:
$LN330@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN331@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN376@Tidy:
$LN331@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN332@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN377@Tidy:
$LN332@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN333@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN378@Tidy:
$LN333@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN329@Tidy:

; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN334@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1857 : 		this->_Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0
	pop	edi

; 1858 : 		this->_Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1859 : 		}

	ret	0
$LN373@Tidy:
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Myptr$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
__Myboff$1$ = -4					; size = 4
__Newmap$1$ = 8						; size = 4
__Count$ = 8						; size = 4
__Almap$ = 11						; size = 1
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap, COMDAT
; _this$ = ecx

; 1785 : 		{	// grow map by at least _Count pointers, _Mapsize() a power of 2

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1786 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1787 : 			"The _Xlen() test should always be performed.");
; 1788 : 
; 1789 : 		typedef typename _Alpty::pointer _Blockptr;
; 1790 : 		_Alpty _Almap(this->_Getal());
; 1791 : 		size_type _Newsize = 0 < this->_Mapsize() ? this->_Mapsize() : 1;

	mov	edx, DWORD PTR __Count$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, 1
	mov	DWORD PTR _this$1$[ebp], edi
	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	cmovne	esi, ecx
	npad	2
$LL2@Growmap:

; 1792 : 		while (_Newsize - this->_Mapsize() < _Count
; 1793 : 			|| _Newsize < _DEQUEMAPSIZ)

	mov	eax, esi
	sub	eax, ecx
	cmp	eax, edx
	jb	SHORT $LN4@Growmap
	cmp	esi, 8
	jae	SHORT $LN3@Growmap
$LN4@Growmap:

; 1794 : 			{	// scale _Newsize to 2^N >= _Mapsize() + _Count
; 1795 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	eax, 107374182				; 06666666H
	sub	eax, esi
	cmp	eax, esi
	jb	$LN338@Growmap

; 1796 : 				_Xlen();	// result too long
; 1797 : 			_Newsize *= 2;

	add	esi, esi

; 1798 : 			}

	jmp	SHORT $LL2@Growmap
$LN3@Growmap:

; 1799 : 		_Count = _Newsize - this->_Mapsize();
; 1800 : 
; 1801 : 		size_type _Myboff = this->_Myoff() / _DEQUESIZ;

	mov	ebx, DWORD PTR [edi+12]
	sub	esi, ecx
	mov	DWORD PTR __Myboff$1$[ebp], ebx

; 1802 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize() + _Count);

	lea	eax, DWORD PTR [ecx+esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1805 : 		_Myptr = _Uninitialized_copy(this->_Map() + _Myboff,

	mov	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi+8]
	shl	ebx, 2
	shl	edi, 2
	mov	DWORD PTR __Newmap$1$[ebp], eax
	lea	edx, DWORD PTR [ecx+ebx]
	add	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, edx
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	edx, DWORD PTR [edi+ebx]
	mov	DWORD PTR __Myptr$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1808 : 		if (_Myboff <= _Count)

	cmp	DWORD PTR __Myboff$1$[ebp], esi
	ja	SHORT $LN6@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ebx+4]

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, eax
	mov	ebx, DWORD PTR __Myboff$1$[ebp]
	sub	edi, eax
	lea	ecx, DWORD PTR [ebx*4]
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	mov	eax, DWORD PTR __imp__memmove
	push	edx
	call	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, esi
	sub	eax, ebx
	shl	eax, 2
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Myptr$1$[ebp]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR __Newmap$1$[ebp]
	mov	ecx, ebx
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	0
	push	edi
	call	_memset
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1818 : 		else

	jmp	SHORT $LN343@Growmap
$LN6@Growmap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	edi, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1820 : 			_Uninitialized_copy(this->_Map(),

	lea	ebx, DWORD PTR [esi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	eax, DWORD PTR __imp__memmove
	push	ebx
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	push	edx
	call	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1823 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	mov	edi, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1823 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	lea	eax, DWORD PTR [ebx+edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, eax
	lea	ecx, DWORD PTR [edx*4]
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	DWORD PTR __Newmap$1$[ebp]
	call	DWORD PTR __imp__memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Newmap$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR __Newmap$1$[ebp]
$LN343@Growmap:
	mov	ebx, DWORD PTR _this$1$[ebp]
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1832 : 		if (this->_Map() != _Mapptr())

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN8@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR [ebx+8]
	push	eax
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN8@Growmap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1836 : 		this->_Map() = _Newmap;	// point at new

	mov	DWORD PTR [ebx+4], edi

; 1837 : 		this->_Mapsize() += _Count;

	add	DWORD PTR [ebx+8], esi
	pop	edi
	pop	esi
	pop	ebx

; 1838 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN338@Growmap:

; 1776 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN345@Growmap:
$LN344@Growmap:
	int	3
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1776 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear, COMDAT
; _this$ = ecx

; 1675 : 		_Tidy();

	jmp	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back, COMDAT
; _this$ = ecx

; 1503 : 		{	// erase element at end

	push	esi
	push	edi
	mov	edi, ecx

; 1504 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1505 : 		if (empty())
; 1506 : 			_DEBUG_ERROR("deque empty before pop");
; 1507 : 		else
; 1508 : 			{	// something to erase, do it
; 1509 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1510 : 			_Orphan_off(_Newoff);
; 1511 : 			size_type _Block = this->_Getblock(_Newoff);
; 1512 : 			this->_Getal().destroy(
; 1513 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1514 : 			if (--this->_Mysize() == 0)
; 1515 : 				this->_Myoff() = 0;
; 1516 : 			}
; 1517 : 
; 1518 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1519 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1520 : 		size_type _Block = this->_Getblock(_Newoff);
; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+12]
	dec	eax
	add	edx, eax

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [edi+8]
	dec	eax
	and	edx, eax

; 1504 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1505 : 		if (empty())
; 1506 : 			_DEBUG_ERROR("deque empty before pop");
; 1507 : 		else
; 1508 : 			{	// something to erase, do it
; 1509 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1510 : 			_Orphan_off(_Newoff);
; 1511 : 			size_type _Block = this->_Getblock(_Newoff);
; 1512 : 			this->_Getal().destroy(
; 1513 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1514 : 			if (--this->_Mysize() == 0)
; 1515 : 				this->_Myoff() = 0;
; 1516 : 			}
; 1517 : 
; 1518 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1519 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1520 : 		size_type _Block = this->_Getblock(_Newoff);
; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	add	esi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN68@pop_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN68@pop_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN160@pop_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN160@pop_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [edi+16], -1
	jne	SHORT $LN2@pop_back

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [edi+12], 0
$LN2@pop_back:
	pop	edi
	pop	esi

; 1525 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1526 : 		}

	ret	0
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
__Ptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back, COMDAT
; _this$ = ecx

; 1494 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [edi+16]
	inc	eax
	cmp	DWORD PTR [edi+8], eax
	ja	SHORT $LN2@push_back
	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@push_back:
	mov	eax, DWORD PTR [edi+8]
	dec	eax
	and	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+16]
	add	eax, DWORD PTR [edi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [edi+8]
	dec	ecx
	and	ecx, eax

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ecx*4]
	cmp	DWORD PTR [ebx+eax], 0
	jne	SHORT $LN3@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	ecx, ecx
	jne	SHORT $LN113@push_back
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN307@push_back:
$LN113@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+eax], ecx
$LN3@push_back:

; 1497 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [ebx+eax]
	mov	DWORD PTR __Ptr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR $T2[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ebx, ebx
	je	SHORT $LN156@push_back
	mov	esi, DWORD PTR __Val$[ebp]
	lea	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [ebx], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [ebx+36], eax
$LN156@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1499 : 		_PUSH_BACK_END;

	inc	DWORD PTR [edi+16]

; 1500 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN306@push_back:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z$41:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty, COMDAT
; _this$ = ecx

; 1392 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 1393 : 		return (this->_Mysize() == 0);
; 1394 : 		}

	ret	0
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; _this$ = ecx

; 1388 : 		return (this->_Getal().max_size());

	mov	eax, 107374182				; 06666666H

; 1389 : 		}

	ret	0
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size, COMDAT
; _this$ = ecx

; 1383 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1384 : 		}

	ret	0
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT
; _this$ = ecx

; 1365 : 		{	// determine new length, padding as needed

	push	ebp
	mov	ebp, esp
	push	ebx

; 1366 : 		while (this->_Mysize() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[ebp]
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+16], ebx
	jae	SHORT $LN229@resize
	npad	1
$LL2@resize:

; 1367 : 			emplace_back();

	mov	ecx, esi
	call	??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
	cmp	DWORD PTR [esi+16], ebx
	jb	SHORT $LL2@resize
$LN229@resize:

; 1368 : 
; 1369 : 		while (_Newsize < this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ebx, ecx
	jae	SHORT $LN240@resize
	push	edi
$LL4@resize:

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+12]
	dec	eax
	add	ecx, eax

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]
	dec	eax
	and	ecx, eax

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR [edi+32]
	add	edi, 12					; 0000000cH
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN172@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN167@resize

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	jne	SHORT $LN234@resize

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN234@resize

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN234@resize

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	ja	SHORT $LN234@resize

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN167@resize:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN172@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN195@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN195@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN26@resize

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN26@resize:

; 1368 : 
; 1369 : 		while (_Newsize < this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ebx, ecx
	jb	SHORT $LL4@resize
	pop	edi
$LN240@resize:
	pop	esi
	pop	ebx

; 1371 : 		}

	pop	ebp
	ret	4
$LN234@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN244@resize:
$LN243@resize:
	int	3
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 1295 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1296 : 		return (const_iterator(this->_Myoff() + this->_Mysize(),

	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1298 : 		}

	pop	ebp
	ret	4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 1284 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1286 : 		}

	pop	ebp
	ret	4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 1243 : 		{	// destroy the deque

	push	esi
	mov	esi, ecx

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 1245 : 		}

	ret	0
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 979  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 979  : 		{	// construct empty deque

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN31@deque
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN96@deque:
$LN31@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 980  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@deque:
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock, COMDAT
; _this$ = ecx

; 767  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp

; 768  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	dec	eax
	and	eax, DWORD PTR __Off$[ebp]

; 770  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 764  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize, COMDAT
; _this$ = ecx

; 941  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 942  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize, COMDAT
; _this$ = ecx

; 936  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 937  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff, COMDAT
; _this$ = ecx

; 931  : 		return (_Get_data()._Myoff);

	lea	eax, DWORD PTR [ecx+12]

; 932  : 		}

	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff, COMDAT
; _this$ = ecx

; 926  : 		return (_Get_data()._Myoff);

	lea	eax, DWORD PTR [ecx+12]

; 927  : 		}

	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mapsize, COMDAT
; _this$ = ecx

; 916  : 		return (_Get_data()._Mapsize);

	lea	eax, DWORD PTR [ecx+8]

; 917  : 		}

	ret	0
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Map@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAPAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
?_Map@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAPAVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Map, COMDAT
; _this$ = ecx

; 906  : 		return (_Get_data()._Map);

	lea	eax, DWORD PTR [ecx+4]

; 907  : 		}

	ret	0
?_Map@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAPAVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Map
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 901  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 902  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 896  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 897  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 891  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 892  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 886  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 887  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 876  : 		_Get_data()._Orphan_all();
; 877  : 		}

	ret	0
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myproxy, COMDAT
; _this$ = ecx

; 866  : 		return (_Get_data()._Myproxy);

	mov	eax, ecx

; 867  : 		}

	ret	0
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 850  : 		{	// destroy proxy

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 857  : 		}

	ret	0
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 841  : 		{	// construct proxy

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 841  : 		{	// construct proxy

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN20@Alloc_prox
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN83@Alloc_prox:
$LN20@Alloc_prox:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
	pop	esi

; 847  : 		}

	ret	0
$LN82@Alloc_prox:
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 822  : 		{	// destroy proxy

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 823  : 		_Free_proxy();
; 824  : 		}

	ret	0
??1?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 808  : 		{	// default construct allocator

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN28@Deque_allo
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN92@Deque_allo:
$LN28@Deque_allo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 809  : 		_Alloc_proxy();
; 810  : 		}

	mov	eax, esi
	pop	esi
	ret	0
$LN91@Deque_allo:
??0?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getblock, COMDAT
; _this$ = ecx

; 802  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	dec	eax
	and	eax, DWORD PTR __Off$[ebp]

; 803  : 		return (_Get_data()._Getblock(_Off));
; 804  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 107374182				; 06666666H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	40					; 00000028H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	eax, 107374182				; 06666666H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::Reader::ErrorInfo>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 107374182				; 06666666H

; 750  : 		}

	ret	0
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 107374182				; 06666666H
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 3

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	40					; 00000028H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [ecx+16], -1
	jne	SHORT $LN4@pop

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [ecx+12], 0
$LN4@pop:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 146  : 		}

	ret	0
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 12
$T2 = -12						; size = 12
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top, COMDAT
; _this$ = ecx

; 129  : 		{	// return last element of mutable stack

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	lea	eax, DWORD PTR $T2[ebp]
	push	esi
	push	1
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN12@top
$LN11@top:
	mov	esi, DWORD PTR [esi]
$LN12@top:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	shr	ecx, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	and	edx, 3
	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1393 : 		return (this->_Mysize() == 0);

	cmp	DWORD PTR [ecx+16], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 121  : 		}

	ret	0
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push, COMDAT
; _this$ = ecx

; 107  : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp

; 109  : 		}

	pop	ebp

; 108  : 		c.push_back(_STD move(_Val));

	jmp	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 28   : 		{	// construct with empty container

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 28   : 		{	// construct with empty container

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN34@stack
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN100@stack:
$LN34@stack:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 29   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN99@stack:
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy, COMDAT
; _this$ = ecx

; 1841 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1393 : 		return (this->_Mysize() == 0);

	cmp	DWORD PTR [esi+16], 0

; 1842 : 		_Alpty _Almap(this->_Getal());
; 1843 : 		while (!empty())

	je	SHORT $LN3@Tidy
	npad	7
$LL2@Tidy:

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN29@Tidy

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN29@Tidy:

; 1393 : 		return (this->_Mysize() == 0);

	cmp	DWORD PTR [esi+16], 0

; 1842 : 		_Alpty _Almap(this->_Getal());
; 1843 : 		while (!empty())

	jne	SHORT $LL2@Tidy
$LN3@Tidy:
	push	edi

; 1845 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN5@Tidy
	npad	5
$LL4@Tidy:

; 1846 : 			{	// free storage for a block and destroy pointer
; 1847 : 			if (this->_Map()[--_Block] != pointer())

	mov	eax, DWORD PTR [esi+4]
	dec	edi
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN7@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1845 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	test	edi, edi
	jne	SHORT $LL4@Tidy
$LN5@Tidy:

; 1848 : 				{	// free block and destroy its pointer
; 1849 : 				this->_Getal().deallocate(this->_Map()[_Block], _DEQUESIZ);
; 1850 : 				this->_Getal().destroy(_STD addressof(this->_Map()[_Block]));
; 1851 : 				}
; 1852 : 			}
; 1853 : 
; 1854 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR [esi+4]
	pop	edi
	test	ecx, ecx
	je	SHORT $LN198@Tidy

; 1855 : 			_Almap.deallocate(this->_Map(),

	mov	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN192@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN232@Tidy:
$LN192@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN193@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN194@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN233@Tidy:
$LN194@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN195@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN234@Tidy:
$LN195@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN196@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN235@Tidy:
$LN196@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN197@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN236@Tidy:
$LN197@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN193@Tidy:

; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN198@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1857 : 		this->_Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0

; 1858 : 		this->_Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1859 : 		}

	ret	0
$LN231@Tidy:
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Myptr$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
__Myboff$1$ = -4					; size = 4
__Newmap$1$ = 8						; size = 4
__Count$ = 8						; size = 4
__Almap$ = 11						; size = 1
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap, COMDAT
; _this$ = ecx

; 1785 : 		{	// grow map by at least _Count pointers, _Mapsize() a power of 2

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1786 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1787 : 			"The _Xlen() test should always be performed.");
; 1788 : 
; 1789 : 		typedef typename _Alpty::pointer _Blockptr;
; 1790 : 		_Alpty _Almap(this->_Getal());
; 1791 : 		size_type _Newsize = 0 < this->_Mapsize() ? this->_Mapsize() : 1;

	mov	edx, DWORD PTR __Count$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, 1
	mov	DWORD PTR _this$1$[ebp], edi
	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	cmovne	esi, ecx
	npad	2
$LL2@Growmap:

; 1792 : 		while (_Newsize - this->_Mapsize() < _Count
; 1793 : 			|| _Newsize < _DEQUEMAPSIZ)

	mov	eax, esi
	sub	eax, ecx
	cmp	eax, edx
	jb	SHORT $LN4@Growmap
	cmp	esi, 8
	jae	SHORT $LN3@Growmap
$LN4@Growmap:

; 1794 : 			{	// scale _Newsize to 2^N >= _Mapsize() + _Count
; 1795 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	eax, 268435455				; 0fffffffH
	sub	eax, esi
	cmp	eax, esi
	jb	$LN338@Growmap

; 1796 : 				_Xlen();	// result too long
; 1797 : 			_Newsize *= 2;

	add	esi, esi

; 1798 : 			}

	jmp	SHORT $LL2@Growmap
$LN3@Growmap:

; 1799 : 		_Count = _Newsize - this->_Mapsize();
; 1800 : 
; 1801 : 		size_type _Myboff = this->_Myoff() / _DEQUESIZ;

	mov	ebx, DWORD PTR [edi+12]
	sub	esi, ecx
	shr	ebx, 2
	mov	DWORD PTR __Myboff$1$[ebp], ebx

; 1802 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize() + _Count);

	lea	eax, DWORD PTR [ecx+esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1805 : 		_Myptr = _Uninitialized_copy(this->_Map() + _Myboff,

	mov	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi+8]
	shl	ebx, 2
	shl	edi, 2
	mov	DWORD PTR __Newmap$1$[ebp], eax
	lea	edx, DWORD PTR [ecx+ebx]
	add	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, edx
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	edx, DWORD PTR [edi+ebx]
	mov	DWORD PTR __Myptr$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1808 : 		if (_Myboff <= _Count)

	cmp	DWORD PTR __Myboff$1$[ebp], esi
	ja	SHORT $LN6@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ebx+4]

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, eax
	mov	ebx, DWORD PTR __Myboff$1$[ebp]
	sub	edi, eax
	lea	ecx, DWORD PTR [ebx*4]
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	mov	eax, DWORD PTR __imp__memmove
	push	edx
	call	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, esi
	sub	eax, ebx
	shl	eax, 2
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Myptr$1$[ebp]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR __Newmap$1$[ebp]
	mov	ecx, ebx
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	0
	push	edi
	call	_memset
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1818 : 		else

	jmp	SHORT $LN343@Growmap
$LN6@Growmap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	edi, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1820 : 			_Uninitialized_copy(this->_Map(),

	lea	ebx, DWORD PTR [esi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	eax, DWORD PTR __imp__memmove
	push	ebx
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	push	edx
	call	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1823 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	mov	edi, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1823 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	lea	eax, DWORD PTR [ebx+edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, eax
	lea	ecx, DWORD PTR [edx*4]
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	DWORD PTR __Newmap$1$[ebp]
	call	DWORD PTR __imp__memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Newmap$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR __Newmap$1$[ebp]
$LN343@Growmap:
	mov	ebx, DWORD PTR _this$1$[ebp]
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1832 : 		if (this->_Map() != _Mapptr())

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN8@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR [ebx+8]
	push	eax
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN8@Growmap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1836 : 		this->_Map() = _Newmap;	// point at new

	mov	DWORD PTR [ebx+4], edi

; 1837 : 		this->_Mapsize() += _Count;

	add	DWORD PTR [ebx+8], esi
	pop	edi
	pop	esi
	pop	ebx

; 1838 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN338@Growmap:

; 1776 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN345@Growmap:
$LN344@Growmap:
	int	3
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen, COMDAT
; _this$ = ecx

; 1776 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back, COMDAT
; _this$ = ecx

; 1504 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1505 : 		if (empty())
; 1506 : 			_DEBUG_ERROR("deque empty before pop");
; 1507 : 		else
; 1508 : 			{	// something to erase, do it
; 1509 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1510 : 			_Orphan_off(_Newoff);
; 1511 : 			size_type _Block = this->_Getblock(_Newoff);
; 1512 : 			this->_Getal().destroy(
; 1513 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1514 : 			if (--this->_Mysize() == 0)
; 1515 : 				this->_Myoff() = 0;
; 1516 : 			}
; 1517 : 
; 1518 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1519 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1520 : 		size_type _Block = this->_Getblock(_Newoff);
; 1521 : 		this->_Getal().destroy(
; 1522 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [ecx+16], -1
	jne	SHORT $LN2@pop_back

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [ecx+12], 0
$LN2@pop_back:

; 1525 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1526 : 		}

	ret	0
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 12
$T2 = -12						; size = 12
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back, COMDAT
; _this$ = ecx

; 1447 : 		{	// return last element of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1448 : 		return (*(end() - 1));

	lea	eax, DWORD PTR $T2[ebp]
	push	esi
	push	1
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN10@back
$LN9@back:
	mov	esi, DWORD PTR [esi]
$LN10@back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	shr	ecx, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	and	edx, 3
	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty, COMDAT
; _this$ = ecx

; 1392 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 1393 : 		return (this->_Mysize() == 0);
; 1394 : 		}

	ret	0
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size, COMDAT
; _this$ = ecx

; 1388 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1389 : 		}

	ret	0
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = ecx

; 1289 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1290 : 		return (iterator(this->_Myoff() + this->_Mysize(),

	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1292 : 		}

	pop	ebp
	ret	4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 1243 : 		{	// destroy the deque

	push	esi
	mov	esi, ecx

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 1245 : 		}

	ret	0
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back, COMDAT
; _this$ = ecx

; 1158 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1160 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+16]
	add	eax, ecx
	test	al, 3
	jne	SHORT $LN2@push_back
	lea	eax, DWORD PTR [ecx+4]
	shr	eax, 2
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN2@push_back
	push	1
	mov	ecx, esi
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@push_back:
	mov	eax, DWORD PTR [esi+8]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [eax*4-1]
	and	DWORD PTR [esi+12], eax
	mov	edi, DWORD PTR [esi+16]
	add	edi, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, edi
	shr	eax, 2
	dec	ecx
	and	ecx, eax

; 1160 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	lea	ebx, DWORD PTR [ecx*4]
	cmp	DWORD PTR [ebx+eax], 0
	jne	SHORT $LN3@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	ecx, ecx
	jne	SHORT $LN113@push_back
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN177@push_back:
$LN113@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1160 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+eax], ecx
$LN3@push_back:

; 1161 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [esi+4]
	and	edi, 3
	mov	eax, DWORD PTR [ebx+eax]
	lea	ecx, DWORD PTR [eax+edi*4]
	pop	edi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN159@push_back
	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN159@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1164 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]
	pop	esi

; 1165 : 		}

	pop	ebp
	ret	4
$LN176@push_back:
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 979  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 979  : 		{	// construct empty deque

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN31@deque
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN96@deque:
$LN31@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 980  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@deque:
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::~_Deque_val<std::_Deque_simple_types<Json::Value *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::~_Deque_val<std::_Deque_simple_types<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock, COMDAT
; _this$ = ecx

; 767  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp

; 768  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR __Off$[ebp]
	dec	eax
	shr	ecx, 2
	and	eax, ecx

; 770  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 764  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize, COMDAT
; _this$ = ecx

; 941  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 942  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize, COMDAT
; _this$ = ecx

; 936  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 937  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myoff, COMDAT
; _this$ = ecx

; 926  : 		return (_Get_data()._Myoff);

	lea	eax, DWORD PTR [ecx+12]

; 927  : 		}

	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mapsize, COMDAT
; _this$ = ecx

; 916  : 		return (_Get_data()._Mapsize);

	lea	eax, DWORD PTR [ecx+8]

; 917  : 		}

	ret	0
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Map@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAPAPAVValue@Json@@XZ
_TEXT	SEGMENT
?_Map@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAPAPAVValue@Json@@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Map, COMDAT
; _this$ = ecx

; 906  : 		return (_Get_data()._Map);

	lea	eax, DWORD PTR [ecx+4]

; 907  : 		}

	ret	0
?_Map@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAPAPAVValue@Json@@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Map
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data, COMDAT
; _this$ = ecx

; 901  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 902  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data, COMDAT
; _this$ = ecx

; 896  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 897  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal, COMDAT
; _this$ = ecx

; 891  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 892  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal, COMDAT
; _this$ = ecx

; 886  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 887  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 876  : 		_Get_data()._Orphan_all();
; 877  : 		}

	ret	0
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myproxy, COMDAT
; _this$ = ecx

; 866  : 		return (_Get_data()._Myproxy);

	mov	eax, ecx

; 867  : 		}

	ret	0
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 850  : 		{	// destroy proxy

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 857  : 		}

	ret	0
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 841  : 		{	// construct proxy

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 841  : 		{	// construct proxy

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN20@Alloc_prox
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN83@Alloc_prox:
$LN20@Alloc_prox:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
	pop	esi

; 847  : 		}

	ret	0
$LN82@Alloc_prox:
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 822  : 		{	// destroy proxy

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 823  : 		_Free_proxy();
; 824  : 		}

	ret	0
??1?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 808  : 		{	// default construct allocator

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN28@Deque_allo
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN92@Deque_allo:
$LN28@Deque_allo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 809  : 		_Alloc_proxy();
; 810  : 		}

	mov	eax, esi
	pop	esi
	ret	0
$LN91@Deque_allo:
??0?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getblock, COMDAT
; _this$ = ecx

; 802  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR __Off$[ebp]
	dec	eax
	shr	ecx, 2
	and	eax, ecx

; 803  : 		return (_Get_data()._Getblock(_Off));
; 804  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ PROC	; std::allocator<Json::Value *>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ENDP	; std::allocator<Json::Value *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ PROC		; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ENDP		; std::allocator<Json::Value *>::allocator<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z
_TEXT	SEGMENT
_token$ = 8						; size = 4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z PROC	; Json::Reader::skipCommentTokens, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 248  :    if ( features_.allowComments_ )

	cmp	BYTE PTR [esi+108], 0
	je	$LN5@skipCommen
	push	edi
	mov	edi, DWORD PTR _token$[ebp]
$LL4@skipCommen:

; 351  :    while ( current_ != end_ )

	mov	edx, DWORD PTR [esi+68]
	cmp	DWORD PTR [esi+72], edx
	je	SHORT $LN78@skipCommen
	npad	4
$LL28@skipCommen:

; 352  :    {
; 353  :       Char c = *current_;

	mov	ecx, DWORD PTR [esi+72]
	mov	al, BYTE PTR [ecx]

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	cmp	al, 32					; 00000020H
	je	SHORT $LN32@skipCommen
	cmp	al, 9
	je	SHORT $LN32@skipCommen
	cmp	al, 13					; 0000000dH
	je	SHORT $LN32@skipCommen
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN78@skipCommen
$LN32@skipCommen:

; 355  :          ++current_;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+72], eax
	cmp	eax, edx
	jne	SHORT $LL28@skipCommen
$LN78@skipCommen:

; 277  :    token.start_ = current_;

	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [edi+4], eax

; 810  :    if ( current_ == end_ )

	mov	eax, DWORD PTR [esi+72]
	cmp	eax, DWORD PTR [esi+68]
	jne	SHORT $LN35@skipCommen

; 811  :       return 0;

	xor	cl, cl
	jmp	SHORT $LN34@skipCommen
$LN35@skipCommen:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+72], eax
$LN34@skipCommen:

; 280  :    switch ( c )

	movsx	eax, cl
	cmp	eax, 125				; 0000007dH
	ja	SHORT $LN76@skipCommen
	movzx	eax, BYTE PTR $LN77@skipCommen[eax]
	jmp	DWORD PTR $LN80@skipCommen[eax*4]
$LN11@skipCommen:

; 281  :    {
; 282  :    case '{':
; 283  :       token.type_ = tokenObjectBegin;

	mov	DWORD PTR [edi], 1

; 284  :       break;

	jmp	SHORT $LN25@skipCommen
$LN12@skipCommen:

; 285  :    case '}':
; 286  :       token.type_ = tokenObjectEnd;

	mov	DWORD PTR [edi], 2

; 287  :       break;

	jmp	SHORT $LN25@skipCommen
$LN13@skipCommen:

; 288  :    case '[':
; 289  :       token.type_ = tokenArrayBegin;

	mov	DWORD PTR [edi], 3

; 290  :       break;

	jmp	SHORT $LN25@skipCommen
$LN14@skipCommen:

; 291  :    case ']':
; 292  :       token.type_ = tokenArrayEnd;

	mov	DWORD PTR [edi], 4

; 293  :       break;

	jmp	SHORT $LN25@skipCommen
$LN15@skipCommen:

; 294  :    case '"':
; 295  :       token.type_ = tokenString;
; 296  :       ok = readString();

	mov	ecx, esi
	mov	DWORD PTR [edi], 5
	call	?readString@Reader@Json@@AAE_NXZ	; Json::Reader::readString

; 297  :       break;

	jmp	SHORT $LN9@skipCommen
$LN16@skipCommen:

; 298  :    case '/':
; 299  :       token.type_ = tokenComment;
; 300  :       ok = readComment();

	mov	ecx, esi
	mov	DWORD PTR [edi], 12			; 0000000cH
	call	?readComment@Reader@Json@@AAE_NXZ	; Json::Reader::readComment
$LN9@skipCommen:

; 337  :    default:
; 338  :       ok = false;
; 339  :       break;
; 340  :    }
; 341  :    if ( !ok )

	test	al, al
	jne	SHORT $LN25@skipCommen
$LN76@skipCommen:

; 342  :       token.type_ = tokenError;

	mov	DWORD PTR [edi], 13			; 0000000dH
$LN25@skipCommen:

; 249  :    {
; 250  :       do
; 251  :       {
; 252  :          readToken( token );
; 253  :       }
; 254  :       while ( token.type_ == tokenComment );

	cmp	DWORD PTR [edi], 12			; 0000000cH

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [edi+8], eax

; 249  :    {
; 250  :       do
; 251  :       {
; 252  :          readToken( token );
; 253  :       }
; 254  :       while ( token.type_ == tokenComment );

	je	$LL4@skipCommen
	pop	edi
	pop	esi

; 259  :    }
; 260  : }

	pop	ebp
	ret	4
$LN17@skipCommen:

; 314  :       readNumber();

	mov	ecx, esi
	mov	DWORD PTR [edi], 6
	call	?readNumber@Reader@Json@@AAEXXZ		; Json::Reader::readNumber

; 315  :       break;

	jmp	SHORT $LN25@skipCommen
$LN18@skipCommen:

; 316  :    case 't':
; 317  :       token.type_ = tokenTrue;

	mov	DWORD PTR [edi], 7

; 366  :    if ( end_ - current_ < patternLength )

	mov	eax, DWORD PTR [esi+68]
	mov	edx, DWORD PTR [esi+72]
	sub	eax, edx
	cmp	eax, 3
	jl	SHORT $LN76@skipCommen

; 367  :       return false;
; 368  :    int index = patternLength;

	mov	ecx, 3
	npad	1
$LL38@skipCommen:

; 370  :       if ( current_[index] != pattern[index] )

	mov	al, BYTE PTR [edx+ecx-1]
	dec	ecx
	cmp	al, BYTE PTR ??_C@_03FFDNHNKN@rue?$AA@[ecx]
	jne	SHORT $LN76@skipCommen

; 369  :    while ( index-- )

	test	ecx, ecx
	jne	SHORT $LL38@skipCommen

; 371  :          return false;
; 372  :    current_ += patternLength;

	lea	eax, DWORD PTR [edx+3]
	mov	DWORD PTR [esi+72], eax

; 319  :       break;

	jmp	SHORT $LN25@skipCommen
$LN19@skipCommen:

; 320  :    case 'f':
; 321  :       token.type_ = tokenFalse;

	mov	DWORD PTR [edi], 8

; 366  :    if ( end_ - current_ < patternLength )

	mov	eax, DWORD PTR [esi+68]
	mov	edx, DWORD PTR [esi+72]
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN76@skipCommen

; 367  :       return false;
; 368  :    int index = patternLength;

	mov	ecx, 4
$LL44@skipCommen:

; 370  :       if ( current_[index] != pattern[index] )

	mov	al, BYTE PTR [edx+ecx-1]
	dec	ecx
	cmp	al, BYTE PTR ??_C@_04KCECFHEP@alse?$AA@[ecx]
	jne	$LN76@skipCommen

; 369  :    while ( index-- )

	test	ecx, ecx
	jne	SHORT $LL44@skipCommen

; 371  :          return false;
; 372  :    current_ += patternLength;

	lea	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+72], eax

; 323  :       break;

	jmp	$LN25@skipCommen
$LN20@skipCommen:

; 324  :    case 'n':
; 325  :       token.type_ = tokenNull;

	mov	DWORD PTR [edi], 9

; 366  :    if ( end_ - current_ < patternLength )

	mov	eax, DWORD PTR [esi+68]
	mov	edx, DWORD PTR [esi+72]
	sub	eax, edx
	cmp	eax, 3
	jl	$LN76@skipCommen

; 367  :       return false;
; 368  :    int index = patternLength;

	mov	ecx, 3
	npad	3
$LL50@skipCommen:

; 370  :       if ( current_[index] != pattern[index] )

	mov	al, BYTE PTR [edx+ecx-1]
	dec	ecx
	cmp	al, BYTE PTR ??_C@_03KNPGGKC@ull?$AA@[ecx]
	jne	$LN76@skipCommen

; 369  :    while ( index-- )

	test	ecx, ecx
	jne	SHORT $LL50@skipCommen

; 371  :          return false;
; 372  :    current_ += patternLength;

	lea	eax, DWORD PTR [edx+3]
	mov	DWORD PTR [esi+72], eax

; 327  :       break;

	jmp	$LN25@skipCommen
$LN21@skipCommen:

; 328  :    case ',':
; 329  :       token.type_ = tokenArraySeparator;

	mov	DWORD PTR [edi], 10			; 0000000aH

; 330  :       break;

	jmp	$LN25@skipCommen
$LN22@skipCommen:

; 331  :    case ':':
; 332  :       token.type_ = tokenMemberSeparator;

	mov	DWORD PTR [edi], 11			; 0000000bH

; 333  :       break;

	jmp	$LN25@skipCommen
$LN23@skipCommen:

; 334  :    case 0:
; 335  :       token.type_ = tokenEndOfStream;

	mov	DWORD PTR [edi], 0

; 336  :       break;

	jmp	$LN25@skipCommen
$LN5@skipCommen:

; 255  :    }
; 256  :    else
; 257  :    {
; 258  :       readToken( token );

	push	DWORD PTR _token$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	pop	esi

; 259  :    }
; 260  : }

	pop	ebp
	ret	4
	npad	2
$LN80@skipCommen:
	DD	$LN23@skipCommen
	DD	$LN15@skipCommen
	DD	$LN21@skipCommen
	DD	$LN17@skipCommen
	DD	$LN16@skipCommen
	DD	$LN22@skipCommen
	DD	$LN13@skipCommen
	DD	$LN14@skipCommen
	DD	$LN19@skipCommen
	DD	$LN20@skipCommen
	DD	$LN18@skipCommen
	DD	$LN11@skipCommen
	DD	$LN12@skipCommen
	DD	$LN76@skipCommen
$LN77@skipCommen:
	DB	0
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	1
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	2
	DB	3
	DB	13					; 0000000dH
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	6
	DB	13					; 0000000dH
	DB	7
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	8
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	9
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	10					; 0000000aH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	11					; 0000000bH
	DB	13					; 0000000dH
	DB	12					; 0000000cH
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ENDP	; Json::Reader::skipCommentTokens
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
_placement$ = 16					; size = 4
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z PROC ; Json::Reader::addComment, COMDAT
; _this$ = ecx

; 409  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 410  :    assert( collectComments_ );
; 411  :    if ( placement == commentAfterOnSameLine )

	cmp	DWORD PTR _placement$[ebp], 1
	mov	edi, DWORD PTR _begin$[ebp]
	mov	esi, DWORD PTR _end$[ebp]
	jne	SHORT $LN2@addComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	edi, esi
	je	SHORT $LN132@addComment

; 906  : 			assign(_First, _Last - _First);

	sub	esi, edi
	lea	ecx, DWORD PTR $T3[ebp]
	push	esi
	push	edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN132@addComment:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 414  :       lastValue_->setComment( std::string( begin, end ), placement );

	mov	ecx, DWORD PTR [ebx+80]
	lea	eax, DWORD PTR $T3[ebp]
	push	1
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN395@addComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 416  :    else

	jmp	SHORT $LN495@addComment
$LN2@addComment:
	cmp	DWORD PTR [ebx+100], 0

; 417  :    {
; 418  :       if ( !commentsBefore_.empty() )

	je	SHORT $LN4@addComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 419  :          commentsBefore_ += "\n";

	lea	ecx, DWORD PTR [ebx+84]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN4@addComment:

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	edi, esi
	je	SHORT $LN383@addComment

; 906  : 			assign(_First, _Last - _First);

	sub	esi, edi
	lea	ecx, DWORD PTR $T2[ebp]
	push	esi
	push	edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN383@addComment:

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 420  :       commentsBefore_ += std::string( begin, end );

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 420  :       commentsBefore_ += std::string( begin, end );

	lea	ecx, DWORD PTR [ebx+84]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN395@addComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
$LN495@addComment:
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN395@addComment:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 422  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ENDP ; Json::Reader::addComment
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
_line$ = -64						; size = 4
_column$ = -60						; size = 4
_buffer$ = -56						; size = 51
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_location$ = 12						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 848  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _location$[ebp]

; 849  :    int line, column;
; 850  :    getLocationLineAndColumn( location, line, column );

	lea	edx, DWORD PTR _column$[ebp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	lea	edx, DWORD PTR _line$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	push	edx
	push	eax
	call	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn

; 852  :    sprintf( buffer, "Line %d, Column %d", line, column );

	push	DWORD PTR _column$[ebp]
	lea	eax, DWORD PTR _buffer$[ebp]
	push	DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
	push	eax
	call	_sprintf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 852  :    sprintf( buffer, "Line %d, Column %d", line, column );

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	jne	SHORT $LN119@getLocatio
	xor	eax, eax
	jmp	SHORT $LN120@getLocatio
$LN119@getLocatio:
	lea	eax, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [eax+1]
$LL121@getLocatio:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL121@getLocatio
	sub	eax, edx
$LN120@getLocatio:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	lea	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, esi
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 854  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_location$ = 8						; size = 4
_line$ = 12						; size = 4
_column$ = 16						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 820  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 821  :    Location current = begin_;
; 822  :    Location lastLineStart = current;
; 823  :    line = 0;

	mov	edx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	push	esi

; 824  :    while ( current < location  &&  current != end_ )

	mov	esi, DWORD PTR _location$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	DWORD PTR [edx], 0
	push	edi
	mov	edi, eax
	cmp	eax, esi
	jae	SHORT $LN12@getLocatio
	push	ebx
	npad	1
$LL2@getLocatio:
	mov	ebx, eax
	cmp	eax, DWORD PTR [ecx+68]
	je	SHORT $LN13@getLocatio

; 825  :    {
; 826  :       Char c = *current++;

	mov	cl, BYTE PTR [eax]
	inc	eax

; 827  :       if ( c == '\r' )

	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN4@getLocatio

; 828  :       {
; 829  :          if ( *current == '\n' )
; 830  :             ++current;
; 831  :          lastLineStart = current;
; 832  :          ++line;

	cmp	BYTE PTR [eax], 10			; 0000000aH
	cmovne	eax, ebx
	inc	eax
	jmp	SHORT $LN14@getLocatio
$LN4@getLocatio:

; 833  :       }
; 834  :       else if ( c == '\n' )

	cmp	cl, 10					; 0000000aH
	jne	SHORT $LN7@getLocatio
$LN14@getLocatio:

; 835  :       {
; 836  :          lastLineStart = current;
; 837  :          ++line;

	inc	DWORD PTR [edx]
	mov	edi, eax
$LN7@getLocatio:

; 824  :    while ( current < location  &&  current != end_ )

	mov	ecx, DWORD PTR _this$1$[ebp]
	cmp	eax, esi
	jb	SHORT $LL2@getLocatio
$LN13@getLocatio:
	pop	ebx
$LN12@getLocatio:

; 838  :       }
; 839  :    }
; 840  :    // column & line start at 1
; 841  :    column = int(location - lastLineStart) + 1;

	mov	eax, DWORD PTR _column$[ebp]
	sub	esi, edi
	inc	esi
	pop	edi
	mov	DWORD PTR [eax], esi

; 842  :    ++line;

	inc	DWORD PTR [edx]
	pop	esi

; 843  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?getNextChar@Reader@Json@@AAEDXZ
_TEXT	SEGMENT
?getNextChar@Reader@Json@@AAEDXZ PROC			; Json::Reader::getNextChar, COMDAT
; _this$ = ecx

; 809  : {

	mov	edx, ecx

; 810  :    if ( current_ == end_ )

	mov	ecx, DWORD PTR [edx+72]
	cmp	ecx, DWORD PTR [edx+68]
	jne	SHORT $LN2@getNextCha

; 811  :       return 0;

	xor	al, al

; 813  : }

	ret	0
$LN2@getNextCha:

; 812  :    return *current_++;

	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx+72], ecx

; 813  : }

	ret	0
?getNextChar@Reader@Json@@AAEDXZ ENDP			; Json::Reader::getNextChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?currentValue@Reader@Json@@AAEAAVValue@2@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 12
$T2 = -12						; size = 12
?currentValue@Reader@Json@@AAEAAVValue@2@XZ PROC	; Json::Reader::currentValue, COMDAT
; _this$ = ecx

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	lea	eax, DWORD PTR $T2[ebp]
	push	esi
	push	1
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN14@currentVal
$LN13@currentVal:
	mov	eax, DWORD PTR [eax]
$LN14@currentVal:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [esi+8]
	mov	edx, esi
	mov	ecx, DWORD PTR [eax+8]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 803  :    return *(nodes_.top());

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	shr	edx, 2
	and	edx, ecx

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 803  :    return *(nodes_.top());

	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 804  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?currentValue@Reader@Json@@AAEAAVValue@2@XZ ENDP	; Json::Reader::currentValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_skipUntilToken$ = 16					; size = 4
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z PROC ; Json::Reader::addErrorAndRecover, COMDAT
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 795  :    addError( message, token );

	push	0
	push	DWORD PTR _token$[ebp]
	mov	esi, ecx
	push	DWORD PTR _message$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 796  :    return recoverFromError( skipUntilToken );

	push	DWORD PTR _skipUntilToken$[ebp]
	mov	ecx, esi
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	pop	esi

; 797  : }

	pop	ebp
	ret	12					; 0000000cH
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ENDP ; Json::Reader::addErrorAndRecover
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z
_TEXT	SEGMENT
_skip$ = -12						; size = 12
_skipUntilToken$ = 8					; size = 4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z PROC ; Json::Reader::recoverFromError, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 776  :    int errorCount = int(errors_.size());

	mov	ebx, DWORD PTR _skipUntilToken$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+36]
$LL2@recoverFro:

; 777  :    Token skip;
; 778  :    while ( true )
; 779  :    {
; 780  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN4@recoverFro

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN4@recoverFro:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$[ebp]
	cmp	eax, ebx
	je	SHORT $LN21@recoverFro
	test	eax, eax
	jne	SHORT $LL2@recoverFro
$LN21@recoverFro:

; 783  :          break;
; 784  :    }
; 785  :    errors_.resize( errorCount );

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
	pop	edi
	pop	esi

; 786  :    return false;

	xor	al, al
	pop	ebx

; 787  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ENDP ; Json::Reader::recoverFromError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
_TEXT	SEGMENT
_info$ = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_extra$ = 16						; size = 4
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z PROC ; Json::Reader::addError, COMDAT
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	edx, DWORD PTR _message$[ebp]
	mov	eax, DWORD PTR _token$[ebp]
	mov	edi, DWORD PTR _extra$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _info$[ebp+32], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _info$[ebp+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _info$[ebp+12], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 765  :    info.token_ = token;

	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _info$[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	lea	eax, DWORD PTR _info$[ebp+12]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 764  :    ErrorInfo info;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 765  :    info.token_ = token;

	movq	QWORD PTR _info$[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	eax, edx
	je	SHORT $LN119@addError

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	edx
	mov	ecx, eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN119@addError:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 768  :    errors_.push_back( info );

	lea	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR _info$[ebp+36], edi
	push	eax
	lea	ecx, DWORD PTR [esi+20]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _info$[ebp+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN361@addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _info$[ebp+12]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN361@addError:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 769  :    return false;

	xor	al, al

; 770  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0:
	lea	ecx, DWORD PTR _info$[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ENDP ; Json::Reader::addError
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -72					; size = 4
_token$GSCopy$1$ = -68					; size = 4
$T2 = -64						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeEscapeSequence, COMDAT
; _this$ = ecx

; 738  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi
	mov	eax, DWORD PTR _token$[ebp]
	mov	ebx, DWORD PTR _current$[ebp]
	mov	esi, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR _token$GSCopy$1$[ebp], eax

; 739  :    if ( end - current < 4 )

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR [ebx]
	cmp	eax, 4
	jge	SHORT $LN5@decodeUnic
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	60					; 0000003cH
	push	OFFSET ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T3[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 740  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	push	DWORD PTR [ebx]
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR _token$GSCopy$1$[ebp]
	mov	ecx, edi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T3[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 740  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	$LN358@decodeUnic
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T3[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 740  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	jmp	$LN462@decodeUnic
$LN5@decodeUnic:

; 741  :    unicode = 0;

	mov	DWORD PTR [esi], 0

; 742  :    for ( int index =0; index < 4; ++index )

	xor	edi, edi
$LL4@decodeUnic:

; 743  :    {
; 744  :       Char c = *current++;

	mov	eax, DWORD PTR [ebx]
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [ebx], eax

; 745  :       unicode *= 16;
; 746  :       if ( c >= '0'  &&  c <= '9' )

	mov	al, cl
	mov	edx, DWORD PTR [esi]
	sub	al, 48					; 00000030H
	shl	edx, 4
	mov	DWORD PTR [esi], edx
	cmp	al, 9
	ja	SHORT $LN6@decodeUnic

; 747  :          unicode += c - '0';

	movsx	eax, cl
	add	eax, -48				; ffffffd0H
	jmp	SHORT $LN463@decodeUnic
$LN6@decodeUnic:

; 748  :       else if ( c >= 'a'  &&  c <= 'f' )

	mov	al, cl
	sub	al, 97					; 00000061H
	cmp	al, 5
	ja	SHORT $LN8@decodeUnic

; 749  :          unicode += c - 'a' + 10;

	movsx	eax, cl
	add	eax, -87				; ffffffa9H
	jmp	SHORT $LN463@decodeUnic
$LN8@decodeUnic:

; 750  :       else if ( c >= 'A'  &&  c <= 'F' )

	mov	al, cl
	sub	al, 65					; 00000041H
	cmp	al, 5
	ja	SHORT $LN10@decodeUnic

; 751  :          unicode += c - 'A' + 10;

	movsx	eax, cl
	add	eax, -55				; ffffffc9H
$LN463@decodeUnic:
	add	eax, edx
	inc	edi
	mov	DWORD PTR [esi], eax
	cmp	edi, 4
	jl	SHORT $LL4@decodeUnic

; 754  :    }
; 755  :    return true;

	mov	al, 1
	jmp	SHORT $LN1@decodeUnic
$LN10@decodeUnic:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	66					; 00000042H
	push	OFFSET ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T2[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 753  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

	push	DWORD PTR [ebx]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	DWORD PTR _token$GSCopy$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T2[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 753  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN358@decodeUnic
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T2[ebp]
$LN462@decodeUnic:
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN358@decodeUnic:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 753  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

	mov	al, bl
$LN1@decodeUnic:

; 756  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeEscapeSequence
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
_surrogatePair$2 = -76					; size = 4
_this$GSCopy$1$ = -72					; size = 4
_token$GSCopy$1$ = -68					; size = 4
$T3 = -64						; size = 24
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeCodePoint, COMDAT
; _this$ = ecx

; 708  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], eax
	mov	edi, DWORD PTR _unicode$[ebp]

; 709  : 
; 710  :    if ( !decodeUnicodeEscapeSequence( token, current, end, unicode ) )

	mov	ebx, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR _token$[ebp]
	mov	esi, DWORD PTR _current$[ebp]
	push	edi
	push	ebx
	push	esi
	mov	DWORD PTR _token$GSCopy$1$[ebp], ecx
	push	ecx
	mov	ecx, eax
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	test	al, al
	jne	SHORT $LN2@decodeUnic
$LN7@decodeUnic:

; 711  :       return false;

	xor	al, al
	jmp	$LN1@decodeUnic
$LN2@decodeUnic:

; 712  :    if (unicode >= 0xD800 && unicode <= 0xDBFF)

	mov	eax, DWORD PTR [edi]
	cmp	eax, 55296				; 0000d800H
	jb	$LN6@decodeUnic
	cmp	eax, 56319				; 0000dbffH
	ja	$LN6@decodeUnic

; 713  :    {
; 714  :       // surrogate pairs
; 715  :       if (end - current < 6)

	mov	ecx, DWORD PTR [esi]
	mov	eax, ebx
	sub	eax, ecx
	cmp	eax, 6
	jge	SHORT $LN4@decodeUnic

; 716  :          return addError( "additional six characters expected to parse unicode surrogate pair.", token, current );

	push	OFFSET ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T4[ebp]
	push	DWORD PTR _token$GSCopy$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	lea	ecx, DWORD PTR $T4[ebp]
	mov	bl, al
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, bl
	jmp	SHORT $LN1@decodeUnic
$LN4@decodeUnic:

; 717  :       unsigned int surrogatePair;
; 718  :       if (*(current++) == '\\' && *(current++)== 'u')

	mov	al, BYTE PTR [ecx]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi], edx
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN5@decodeUnic
	mov	cl, BYTE PTR [edx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi], eax
	cmp	cl, 117					; 00000075H
	jne	SHORT $LN5@decodeUnic

; 719  :       {
; 720  :          if (decodeUnicodeEscapeSequence( token, current, end, surrogatePair ))

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _surrogatePair$2[ebp]
	push	eax
	push	ebx
	push	esi
	push	DWORD PTR _token$GSCopy$1$[ebp]
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	test	al, al
	je	$LN7@decodeUnic

; 721  :          {
; 722  :             unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _surrogatePair$2[ebp]
	and	ecx, 1023				; 000003ffH
	add	ecx, 64					; 00000040H
	and	eax, 1023				; 000003ffH
	shl	ecx, 10					; 0000000aH
	add	ecx, eax
	mov	DWORD PTR [edi], ecx
$LN6@decodeUnic:

; 729  :    }
; 730  :    return true;

	mov	al, 1
$LN1@decodeUnic:

; 731  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN5@decodeUnic:

; 723  :          } 
; 724  :          else
; 725  :             return false;
; 726  :       } 
; 727  :       else
; 728  :          return addError( "expecting another \\u token to begin the second half of a unicode surrogate pair", token, current );

	push	OFFSET ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	DWORD PTR _token$GSCopy$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	lea	ecx, DWORD PTR $T3[ebp]
	mov	bl, al
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, bl
	jmp	SHORT $LN1@decodeUnic
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeCodePoint
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T2 = -144						; size = 12
$T3 = -132						; size = 12
$T4 = -120						; size = 16
_value$ = -104						; size = 8
$T5 = -96						; size = 24
$T6 = -72						; size = 24
_buffer$7 = -72						; size = 24
_buffer$8 = -48						; size = 32
$T9 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeDouble, COMDAT
; _this$ = ecx

; 621  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _token$[ebp]
	xorps	xmm0, xmm0

; 622  :    double value = 0;

	movsd	QWORD PTR _value$[ebp], xmm0

; 623  :    const int bufferSize = 32;
; 624  :    int count;
; 625  :    int length = int(token.end_ - token.start_);

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, ecx
	mov	eax, DWORD PTR [edi+4]
	sub	esi, eax

; 626  :    if ( length <= bufferSize )

	cmp	esi, 32					; 00000020H
	jg	SHORT $LN2@decodeDoub

; 627  :    {
; 628  :       Char buffer[bufferSize];
; 629  :       memcpy( buffer, token.start_, length );

	push	esi
	push	eax
	lea	eax, DWORD PTR _buffer$8[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 630  :       buffer[length] = 0;

	cmp	esi, 32					; 00000020H
	jae	SHORT $LN6@decodeDoub

; 631  :       count = sscanf( buffer, "%lf", &value );

	lea	eax, DWORD PTR _value$[ebp]
	mov	BYTE PTR _buffer$8[ebp+esi], 0
	push	eax
	lea	eax, DWORD PTR _buffer$8[ebp]
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
	push	eax
	call	_sscanf
	mov	esi, eax

; 632  :    }
; 633  :    else

	jmp	SHORT $LN720@decodeDoub
$LN6@decodeDoub:

; 630  :       buffer[length] = 0;

	call	___report_rangecheckfailure
$LN721@decodeDoub:
$LN2@decodeDoub:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _buffer$7[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _buffer$7[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _buffer$7[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	eax, ecx
	je	SHORT $LN152@decodeDoub

; 906  : 			assign(_First, _Last - _First);

	sub	ecx, eax
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _buffer$7[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _buffer$7[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR _buffer$7[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jae	SHORT $LN153@decodeDoub
$LN152@decodeDoub:
	lea	eax, DWORD PTR _buffer$7[ebp]
$LN153@decodeDoub:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 636  :       count = sscanf( buffer.c_str(), "%lf", &value );

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
	push	eax
	call	_sscanf
	mov	esi, eax
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _buffer$7[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN162@decodeDoub

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR _buffer$7[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
$LN720@decodeDoub:
	add	esp, 12					; 0000000cH
$LN162@decodeDoub:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 639  :    if ( count != 1 )

	cmp	esi, 1
	je	$LN4@decodeDoub

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T6[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T6[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T6[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	ecx, eax
	je	SHORT $LN385@decodeDoub

; 906  : 			assign(_First, _Last - _First);

	sub	eax, ecx
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T6[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN385@decodeDoub:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	eax, DWORD PTR $T9[ebp]
	push	OFFSET ??_C@_01GEODFPGF@?8?$AA@
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 24					; 00000018H
	push	0
	push	edi
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T5[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN393@decodeDoub
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN393@decodeDoub:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T9[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T5[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T5[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN498@decodeDoub
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T9[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN498@decodeDoub:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T6[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T9[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T9[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T9[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN603@decodeDoub
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T6[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN603@decodeDoub:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	al, bl
	jmp	SHORT $LN1@decodeDoub
$LN4@decodeDoub:

; 641  :    currentValue() = value;

	movsd	xmm0, QWORD PTR _value$[ebp]
	lea	ecx, DWORD PTR $T4[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	??0Value@Json@@QAE@N@Z			; Json::Value::Value
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, ebx
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN715@decodeDoub
$LN714@decodeDoub:
	mov	ecx, DWORD PTR [ecx]
$LN715@decodeDoub:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [eax+8]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	lea	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, esi

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	and	edx, eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 642  :    return true;

	mov	al, 1
$LN1@decodeDoub:

; 643  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN719@decodeDoub:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeDouble
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_end$1$ = -88						; size = 4
_unicode$2 = -84					; size = 4
_this$GSCopy$1$ = -80					; size = 4
_token$GSCopy$1$ = -76					; size = 4
_current$ = -72						; size = 4
_c$1$ = -65						; size = 1
$T3 = -64						; size = 24
$T4 = -64						; size = 24
$T5 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_decoded$ = 12						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 659  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	ebx, DWORD PTR _token$[ebp]
	mov	esi, DWORD PTR _decoded$[ebp]
	mov	DWORD PTR _token$GSCopy$1$[ebp], ebx

; 660  :    decoded.reserve( token.end_ - token.start_ - 2 );

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	edi, DWORD PTR [esi+16]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 660  :    decoded.reserve( token.end_ - token.start_ - 2 );

	sub	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	edi, eax
	ja	SHORT $LN72@decodeStri
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN72@decodeStri

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, esi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN72@decodeStri

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN67@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN68@decodeStri
$LN67@decodeStri:
	mov	eax, esi
$LN68@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN72@decodeStri:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 661  :    Location current = token.start_ + 1; // skip '"'

	mov	edi, DWORD PTR [ebx+4]

; 662  :    Location end = token.end_ - 1;      // do not include '"'

	mov	ecx, DWORD PTR [ebx+8]
	inc	edi
	dec	ecx
	mov	DWORD PTR _end$1$[ebp], ecx

; 663  :    while ( current != end )

	cmp	edi, ecx
	je	$LN3@decodeStri
$LL2@decodeStri:

; 664  :    {
; 665  :       Char c = *current++;

	mov	dl, BYTE PTR [edi]
	inc	edi
	mov	BYTE PTR _c$1$[ebp], dl

; 666  :       if ( c == '"' )

	cmp	dl, 34					; 00000022H
	je	$LN3@decodeStri

; 667  :          break;
; 668  :       else if ( c == '\\' )

	cmp	dl, 92					; 0000005cH
	jne	$LN8@decodeStri

; 669  :       {
; 670  :          if ( current == end )

	cmp	edi, ecx
	je	$LN705@decodeStri

; 672  :          Char escape = *current++;

	mov	al, BYTE PTR [edi]
	inc	edi

; 673  :          switch ( escape )

	movsx	eax, al
	add	eax, -34				; ffffffdeH
	mov	DWORD PTR _current$[ebp], edi
	cmp	eax, 83					; 00000053H
	ja	$LN21@decodeStri
	movzx	eax, BYTE PTR $LN712@decodeStri[eax]
	jmp	DWORD PTR $LN719@decodeStri[eax*4]
$LN11@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	34					; 00000022H
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 675  :          case '"': decoded += '"'; break;

	jmp	$LN699@decodeStri
$LN12@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	47					; 0000002fH
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 676  :          case '/': decoded += '/'; break;

	jmp	$LN699@decodeStri
$LN13@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	92					; 0000005cH
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 677  :          case '\\': decoded += '\\'; break;

	jmp	$LN699@decodeStri
$LN14@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	8
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 678  :          case 'b': decoded += '\b'; break;

	jmp	$LN699@decodeStri
$LN15@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	12					; 0000000cH
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 679  :          case 'f': decoded += '\f'; break;

	jmp	$LN699@decodeStri
$LN16@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	10					; 0000000aH
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 680  :          case 'n': decoded += '\n'; break;

	jmp	$LN699@decodeStri
$LN17@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	13					; 0000000dH
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 681  :          case 'r': decoded += '\r'; break;

	jmp	$LN699@decodeStri
$LN18@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	9
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 682  :          case 't': decoded += '\t'; break;

	jmp	$LN699@decodeStri
$LN19@decodeStri:

; 683  :          case 'u':
; 684  :             {
; 685  :                unsigned int unicode;
; 686  :                if ( !decodeUnicodeCodePoint( token, current, end, unicode ) )

	lea	eax, DWORD PTR _unicode$2[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _current$[ebp]
	push	eax
	push	ebx
	call	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
	test	al, al
	je	$LN706@decodeStri

; 688  :                decoded += codePointToUTF8(unicode);

	push	DWORD PTR _unicode$2[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::codePointToUTF8
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 688  :                decoded += codePointToUTF8(unicode);

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 688  :                decoded += codePointToUTF8(unicode);

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN713@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN713@decodeStri:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 695  :       else

	mov	edi, DWORD PTR _current$[ebp]
	jmp	SHORT $LN699@decodeStri
$LN8@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, 1
	jbe	$LN708@decodeStri

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	ebx, DWORD PTR [ecx+1]

; 2225 : 		if (max_size() < _Newsize)

	cmp	ebx, -2					; fffffffeH
	ja	$LN708@decodeStri

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], ebx
	jae	SHORT $LN554@decodeStri

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	dl, BYTE PTR _c$1$[ebp]

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	ebx, ebx

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN714@decodeStri
$LN718@decodeStri:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	mov	ecx, DWORD PTR [esi+16]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN661@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN662@decodeStri
$LN554@decodeStri:

; 2232 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN718@decodeStri

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN631@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	jmp	SHORT $LN714@decodeStri
$LN631@decodeStri:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	jmp	SHORT $LN714@decodeStri
$LN661@decodeStri:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
$LN662@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], dl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN694@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN695@decodeStri
$LN694@decodeStri:
	mov	eax, esi
$LN695@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ebx+eax], 0
$LN714@decodeStri:
	mov	ebx, DWORD PTR _token$GSCopy$1$[ebp]
$LN699@decodeStri:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 663  :    while ( current != end )

	mov	ecx, DWORD PTR _end$1$[ebp]
	cmp	edi, ecx
	jne	$LL2@decodeStri
$LN3@decodeStri:

; 696  :       {
; 697  :          decoded += c;
; 698  :       }
; 699  :    }
; 700  :    return true;

	mov	al, 1
$LN1@decodeStri:

; 701  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN706@decodeStri:

; 687  :                   return false;

	xor	al, al
	jmp	SHORT $LN1@decodeStri
$LN21@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	29					; 0000001dH
	push	OFFSET ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T5[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T5[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T5[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 692  :             return addError( "Bad escape sequence in string", token, current );

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T5[ebp]
	push	edi
	push	ebx
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T5[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 692  :             return addError( "Bad escape sequence in string", token, current );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN80@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 692  :             return addError( "Bad escape sequence in string", token, current );

	mov	al, bl
	jmp	SHORT $LN1@decodeStri
$LN705@decodeStri:

; 671  :             return addError( "Empty escape sequence in string", token, current );

	push	OFFSET ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T4[ebp]
	push	edi
	push	ebx
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T4[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 671  :             return addError( "Empty escape sequence in string", token, current );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN80@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN80@decodeStri:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 671  :             return addError( "Empty escape sequence in string", token, current );

	mov	al, bl
	jmp	$LN1@decodeStri
$LN708@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN720@decodeStri:
$LN716@decodeStri:
$LN719@decodeStri:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 701  : }

	DD	$LN11@decodeStri
	DD	$LN12@decodeStri
	DD	$LN13@decodeStri
	DD	$LN14@decodeStri
	DD	$LN15@decodeStri
	DD	$LN16@decodeStri
	DD	$LN17@decodeStri
	DD	$LN18@decodeStri
	DD	$LN19@decodeStri
	DD	$LN21@decodeStri
$LN712@decodeStri:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Reader::decodeString
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T2 = -80						; size = 12
$T3 = -68						; size = 12
$T4 = -56						; size = 16
_decoded$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 648  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	eax, DWORD PTR _token$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _decoded$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _decoded$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _decoded$[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 650  :    if ( !decodeString( token, decoded ) )

	lea	ecx, DWORD PTR _decoded$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	push	eax
	mov	ecx, esi
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	test	al, al
	jne	SHORT $LN2@decodeStri
	xor	bl, bl
	jmp	SHORT $LN6@decodeStri
$LN2@decodeStri:

; 652  :    currentValue() = decoded;

	lea	eax, DWORD PTR _decoded$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::Value
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 652  :    currentValue() = decoded;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, esi
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN131@decodeStri
$LN130@decodeStri:
	mov	ecx, DWORD PTR [ecx]
$LN131@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [eax+8]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 652  :    currentValue() = decoded;

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 652  :    currentValue() = decoded;

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	shr	edx, 2

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	and	edx, eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 652  :    currentValue() = decoded;

	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 653  :    return true;

	mov	bl, 1
$LN6@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _decoded$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN239@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _decoded$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN239@decodeStri:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 653  :    return true;

	mov	al, bl

; 654  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR _decoded$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeString
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T2 = -112						; size = 16
$T3 = -108						; size = 12
_token$GSCopy$1$ = -96					; size = 4
_this$GSCopy$1$ = -92					; size = 4
$T4 = -88						; size = 24
$T5 = -64						; size = 24
$T6 = -52						; size = 12
$T7 = -40						; size = 24
$T8 = -32						; size = 16
$T9 = -32						; size = 16
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeNumber, COMDAT
; _this$ = ecx

; 583  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx
	mov	esi, DWORD PTR _token$[ebp]

; 584  :    bool isDouble = false;

	xor	al, al
	mov	DWORD PTR _token$GSCopy$1$[ebp], esi

; 585  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, edx
	mov	edi, DWORD PTR [esi+8]
	cmp	ecx, edi
	je	SHORT $LN7@decodeNumb
$LL4@decodeNumb:

; 586  :    {
; 587  :       isDouble = isDouble  

	test	al, al
	jne	SHORT $LN17@decodeNumb
	mov	al, BYTE PTR [ecx]

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	cmp	al, 46					; 0000002eH
	je	SHORT $LN17@decodeNumb
	cmp	al, 101					; 00000065H
	je	SHORT $LN17@decodeNumb
	cmp	al, 69					; 00000045H
	je	SHORT $LN17@decodeNumb
	cmp	al, 43					; 0000002bH
	je	SHORT $LN17@decodeNumb

; 586  :    {
; 587  :       isDouble = isDouble  

	cmp	al, 45					; 0000002dH
	jne	SHORT $LN18@decodeNumb
	cmp	ecx, edx
	jne	SHORT $LN17@decodeNumb
$LN18@decodeNumb:
	xor	al, al
	jmp	SHORT $LN19@decodeNumb
$LN17@decodeNumb:
	mov	al, 1
$LN19@decodeNumb:

; 585  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

	inc	ecx
	cmp	ecx, edi
	jne	SHORT $LL4@decodeNumb

; 588  :                  ||  in( *inspect, '.', 'e', 'E', '+' )  
; 589  :                  ||  ( *inspect == '-'  &&  inspect != token.start_ );
; 590  :    }
; 591  :    if ( isDouble )

	test	al, al
	je	SHORT $LN7@decodeNumb

; 592  :       return decodeDouble( token );

	push	esi
	mov	ecx, ebx
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	jmp	$LN1@decodeNumb
$LN7@decodeNumb:

; 593  :    Location current = token.start_;

	mov	esi, edx

; 594  :    bool isNegative = *current == '-';

	mov	bh, BYTE PTR [esi]
	cmp	bh, 45					; 0000002dH

; 595  :    if ( isNegative )

	jne	SHORT $LN20@decodeNumb

; 596  :       ++current;
; 597  :    Value::UInt threshold = (isNegative ? Value::UInt(-Value::minInt) 
; 598  :                                        : Value::maxUInt) / 10;

	mov	ecx, DWORD PTR ?minInt@Value@Json@@2HB	; Json::Value::minInt
	inc	esi
	neg	ecx
	jmp	SHORT $LN21@decodeNumb
$LN20@decodeNumb:
	mov	ecx, DWORD PTR ?maxUInt@Value@Json@@2IB	; Json::Value::maxUInt
$LN21@decodeNumb:
	mov	eax, -858993459				; cccccccdH
	mul	ecx

; 599  :    Value::UInt value = 0;

	xor	eax, eax
	shr	edx, 3

; 600  :    while ( current < token.end_ )

	cmp	esi, edi
	jae	SHORT $LN6@decodeNumb
$LL5@decodeNumb:

; 601  :    {
; 602  :       Char c = *current++;

	mov	bl, BYTE PTR [esi]
	inc	esi

; 603  :       if ( c < '0'  ||  c > '9' )

	cmp	bl, 48					; 00000030H
	jl	SHORT $LN10@decodeNumb
	cmp	bl, 57					; 00000039H
	jg	SHORT $LN10@decodeNumb

; 605  :       if ( value >= threshold )

	cmp	eax, edx
	jae	SHORT $LN492@decodeNumb

; 607  :       value = value * 10 + Value::UInt(c - '0');

	lea	ecx, DWORD PTR [eax+eax*4]
	movsx	eax, bl
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H
	cmp	esi, edi
	jb	SHORT $LL5@decodeNumb
$LN6@decodeNumb:
	cmp	bh, 45					; 0000002dH

; 608  :    }
; 609  :    if ( isNegative )

	jne	$LN12@decodeNumb

; 610  :       currentValue() = -Value::Int( value );

	neg	eax
	lea	ecx, DWORD PTR $T9[ebp]
	push	eax
	call	??0Value@Json@@QAE@H@Z			; Json::Value::Value
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T6[ebp]
	push	1
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jne	$LN485@decodeNumb
	jmp	$LN486@decodeNumb
$LN492@decodeNumb:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 606  :          return decodeDouble( token );

	mov	esi, DWORD PTR _token$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	esi
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	jmp	$LN1@decodeNumb
$LN10@decodeNumb:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	mov	esi, DWORD PTR _token$GSCopy$1$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T7[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T7[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T7[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN156@decodeNumb

; 906  : 			assign(_First, _Last - _First);

	sub	edi, eax
	lea	ecx, DWORD PTR $T7[ebp]
	push	edi
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN156@decodeNumb:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 604  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	OFFSET ??_C@_01GEODFPGF@?8?$AA@
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	0
	push	esi
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T5[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 604  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN164@decodeNumb
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN164@decodeNumb:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T4[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T5[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T5[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN269@decodeNumb
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN269@decodeNumb:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T7[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T4[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T4[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN374@decodeNumb
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T7[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN374@decodeNumb:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 604  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	al, bl
	jmp	$LN1@decodeNumb
$LN485@decodeNumb:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR [ecx]
$LN486@decodeNumb:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [eax+8]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	lea	eax, DWORD PTR $T9[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, esi

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	and	edx, eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	SHORT $LN501@decodeNumb
$LN12@decodeNumb:

; 611  :    else if ( value <= Value::UInt(Value::maxInt) )
; 612  :       currentValue() = Value::Int( value );

	push	eax
	cmp	eax, DWORD PTR ?maxInt@Value@Json@@2HB	; Json::Value::maxInt
	ja	SHORT $LN14@decodeNumb
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0Value@Json@@QAE@H@Z			; Json::Value::Value
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T8[ebp]

; 613  :    else

	jmp	SHORT $LN501@decodeNumb
$LN14@decodeNumb:

; 614  :       currentValue() = value;

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Value@Json@@QAE@I@Z			; Json::Value::Value
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T2[ebp]
$LN501@decodeNumb:
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 615  :    return true;

	mov	al, 1
$LN1@decodeNumb:

; 616  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeNumber
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T2 = -84						; size = 16
$T3 = -68						; size = 12
_endArray$4 = -68					; size = 12
$T5 = -56						; size = 4
_skip$6 = -52						; size = 12
$T7 = -52						; size = 12
_token$8 = -52						; size = 12
$T9 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readArray, COMDAT
; _this$ = ecx

; 540  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 541  :    currentValue() = Value( arrayValue );

	push	6
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 541  :    currentValue() = Value( arrayValue );

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, esi
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN29@readArray
$LN28@readArray:
	mov	edi, DWORD PTR [edi]
$LN29@readArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	eax, edx
	mov	ecx, DWORD PTR [edi+8]

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	dec	ecx
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [edi+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 541  :    currentValue() = Value( arrayValue );

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+ecx*4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 541  :    currentValue() = Value( arrayValue );

	mov	ecx, DWORD PTR [eax+edx*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 351  :    while ( current_ != end_ )

	mov	edx, DWORD PTR [esi+68]
	cmp	DWORD PTR [esi+72], edx
	je	SHORT $LN35@readArray
$LL33@readArray:

; 352  :    {
; 353  :       Char c = *current_;

	mov	ecx, DWORD PTR [esi+72]
	mov	al, BYTE PTR [ecx]

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	cmp	al, 32					; 00000020H
	je	SHORT $LN37@readArray
	cmp	al, 9
	je	SHORT $LN37@readArray
	cmp	al, 13					; 0000000dH
	je	SHORT $LN37@readArray
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN35@readArray
$LN37@readArray:

; 355  :          ++current_;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+72], eax
	cmp	eax, edx
	jne	SHORT $LL33@readArray
$LN35@readArray:

; 542  :    skipSpaces();
; 543  :    if ( *current_ == ']' ) // empty array

	mov	eax, DWORD PTR [esi+72]
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LN6@readArray

; 544  :    {
; 545  :       Token endArray;
; 546  :       readToken( endArray );

	lea	eax, DWORD PTR _endArray$4[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 547  :       return true;

	mov	al, 1
	jmp	$LN1@readArray
$LN6@readArray:

; 548  :    }
; 549  :    int index = 0;

	xor	edi, edi
$LL2@readArray:

; 552  :       Value &value = currentValue()[ index++ ];

	push	edi
	mov	ecx, esi
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]

; 553  :       nodes_.push( &value );

	mov	DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	mov	ecx, esi
	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 552  :       Value &value = currentValue()[ index++ ];

	inc	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	push	eax
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 554  :       bool ok = readValue();

	mov	ecx, esi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN393@readArray

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN393@readArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 561  :       ok = readToken( token );

	mov	ecx, esi
	test	al, al
	je	$LN588@readArray
	lea	eax, DWORD PTR _token$8[ebp]
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 562  :       while ( token.type_ == tokenComment  &&  ok )

	mov	ecx, DWORD PTR _token$8[ebp]
	cmp	ecx, 12					; 0000000cH
	jne	SHORT $LN5@readArray
	npad	1
$LL4@readArray:
	test	al, al
	je	SHORT $LN9@readArray

; 563  :       {
; 564  :          ok = readToken( token );

	lea	eax, DWORD PTR _token$8[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	ecx, DWORD PTR _token$8[ebp]
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LL4@readArray
$LN5@readArray:

; 565  :       }
; 566  :       bool badTokenType = ( token.type_ == tokenArraySeparator  &&  
; 567  :                             token.type_ == tokenArrayEnd );
; 568  :       if ( !ok  ||  badTokenType )

	test	al, al
	je	SHORT $LN9@readArray

; 571  :                                     token, 
; 572  :                                     tokenArrayEnd );
; 573  :       }
; 574  :       if ( token.type_ == tokenArrayEnd )

	cmp	ecx, 4
	jne	SHORT $LL2@readArray

; 575  :          break;
; 576  :    }
; 577  :    return true;

	mov	al, 1
	jmp	$LN1@readArray
$LN9@readArray:

; 570  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 

	push	OFFSET ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 795  :    addError( message, token );

	push	0
	lea	eax, DWORD PTR _token$8[ebp]

; 570  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 795  :    addError( message, token );

	push	eax
	lea	eax, DWORD PTR $T9[ebp]
	mov	ecx, esi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 776  :    int errorCount = int(errors_.size());

	mov	edi, DWORD PTR [esi+36]
	npad	1
$LL461@readArray:

; 777  :    Token skip;
; 778  :    while ( true )
; 779  :    {
; 780  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$6[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN463@readArray

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN463@readArray:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$6[ebp]
	cmp	eax, 4
	je	SHORT $LN591@readArray
	test	eax, eax
	jne	SHORT $LL461@readArray
$LN591@readArray:

; 783  :          break;
; 784  :    }
; 785  :    errors_.resize( errorCount );

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T9[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN485@readArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T9[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN485@readArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 570  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 

	xor	al, al
	jmp	SHORT $LN1@readArray
$LN588@readArray:

; 555  :       nodes_.pop();
; 556  :       if ( !ok ) // error already set
; 557  :          return recoverFromError( tokenArrayEnd );

	push	4
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
$LN1@readArray:

; 578  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readArray
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T2 = -104						; size = 4
_skip$3 = -100						; size = 12
_skip$4 = -100						; size = 12
_skip$5 = -100						; size = 12
$T6 = -100						; size = 12
_colon$7 = -100						; size = 12
_name$ = -88						; size = 24
$T8 = -64						; size = 24
$T9 = -56						; size = 16
_tokenName$ = -52					; size = 12
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -28						; size = 12
_comma$13 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readObject, COMDAT
; _this$ = ecx

; 481  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _name$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _name$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _name$[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 484  :    currentValue() = Value( objectValue );

	push	7
	lea	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 484  :    currentValue() = Value( objectValue );

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	lea	eax, DWORD PTR $T12[ebp]
	mov	ecx, esi
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN154@readObject
$LN153@readObject:
	mov	edi, DWORD PTR [edi]
$LN154@readObject:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	eax, edx
	mov	ecx, DWORD PTR [edi+8]

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	dec	ecx
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [edi+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 484  :    currentValue() = Value( objectValue );

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+ecx*4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 484  :    currentValue() = Value( objectValue );

	mov	ecx, DWORD PTR [eax+edx*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T9[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 485  :    while ( readToken( tokenName ) )

	lea	eax, DWORD PTR _tokenName$[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$LN3@readObject
$LL2@readObject:

; 486  :    {
; 487  :       bool initialTokenOk = true;
; 488  :       while ( tokenName.type_ == tokenComment  &&  initialTokenOk )

	mov	eax, DWORD PTR _tokenName$[ebp]
	mov	cl, 1
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN1522@readObject
	npad	1
$LL4@readObject:
	test	cl, cl
	je	$LN3@readObject

; 489  :          initialTokenOk = readToken( tokenName );

	lea	eax, DWORD PTR _tokenName$[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	cl, al
	mov	eax, DWORD PTR _tokenName$[ebp]
	cmp	eax, 12					; 0000000cH
	je	SHORT $LL4@readObject

; 490  :       if  ( !initialTokenOk )

	test	cl, cl
	je	$LN3@readObject
$LN1522@readObject:

; 492  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

	cmp	eax, 2
	je	$LN1523@readObject

; 493  :          return true;
; 494  :       if ( tokenName.type_ != tokenString )

	cmp	eax, 5
	jne	$LN3@readObject
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 498  :       if ( !decodeString( tokenName, name ) )

	lea	eax, DWORD PTR _name$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _tokenName$[ebp]
	push	eax
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString

; 499  :          return recoverFromError( tokenObjectEnd );
; 500  : 
; 501  :       Token colon;
; 502  :       if ( !readToken( colon ) ||  colon.type_ != tokenMemberSeparator )

	mov	ecx, esi
	test	al, al
	je	$LN1502@readObject
	lea	eax, DWORD PTR _colon$7[ebp]
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$LN13@readObject
	cmp	DWORD PTR _colon$7[ebp], 11		; 0000000bH
	jne	$LN13@readObject

; 505  :                                     colon, 
; 506  :                                     tokenObjectEnd );
; 507  :       }
; 508  :       Value &value = currentValue()[ name ];

	lea	eax, DWORD PTR _name$[ebp]
	mov	ecx, esi
	push	eax
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]

; 509  :       nodes_.push( &value );

	mov	DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	mov	ecx, esi
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 510  :       bool ok = readValue();

	mov	ecx, esi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN1069@readObject

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN1069@readObject:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 517  :             ||  ( comma.type_ != tokenObjectEnd  &&  

	mov	ecx, esi
	test	al, al
	je	$LN1502@readObject
	lea	eax, DWORD PTR _comma$13[ebp]
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$LN16@readObject
	mov	eax, DWORD PTR _comma$13[ebp]
	cmp	eax, 2
	je	SHORT $LN15@readObject
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN15@readObject
	cmp	eax, 12					; 0000000cH
	jne	$LN16@readObject
$LN15@readObject:

; 522  :                                     comma, 
; 523  :                                     tokenObjectEnd );
; 524  :       }
; 525  :       bool finalizeTokenOk = true;

	mov	cl, 1

; 526  :       while ( comma.type_ == tokenComment &&

	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN7@readObject
$LL6@readObject:
	test	cl, cl
	je	SHORT $LN7@readObject

; 527  :               finalizeTokenOk )
; 528  :          finalizeTokenOk = readToken( comma );

	lea	eax, DWORD PTR _comma$13[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	cl, al
	mov	eax, DWORD PTR _comma$13[ebp]
	cmp	eax, 12					; 0000000cH
	je	SHORT $LL6@readObject
$LN7@readObject:

; 529  :       if ( comma.type_ == tokenObjectEnd )

	cmp	eax, 2
	je	$LN1504@readObject

; 485  :    while ( readToken( tokenName ) )

	lea	eax, DWORD PTR _tokenName$[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	$LL2@readObject
$LN3@readObject:

; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 

	push	OFFSET ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 795  :    addError( message, token );

	push	0
	lea	eax, DWORD PTR _tokenName$[ebp]

; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 

	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 795  :    addError( message, token );

	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	mov	ecx, esi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 776  :    int errorCount = int(errors_.size());

	mov	edi, DWORD PTR [esi+36]
$LL1263@readObject:

; 777  :    Token skip;
; 778  :    while ( true )
; 779  :    {
; 780  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$4[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN1265@readObject

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN1265@readObject:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$4[ebp]
	cmp	eax, 2
	je	SHORT $LN1507@readObject
	test	eax, eax
	jne	SHORT $LL1263@readObject
$LN1507@readObject:

; 783  :          break;
; 784  :    }
; 785  :    errors_.resize( errorCount );

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T10[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 

	xor	bl, bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN1287@readObject
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T10[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN1287@readObject:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T10[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T10[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T10[ebp], 0
$LN1282@readObject:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _name$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN1525@readObject
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _name$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN1525@readObject:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 

	mov	al, bl

; 533  :                               tokenName, 
; 534  :                               tokenObjectEnd );
; 535  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN16@readObject:

; 521  :          return addErrorAndRecover( "Missing ',' or '}' in object declaration", 

	push	OFFSET ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 795  :    addError( message, token );

	push	0
	lea	eax, DWORD PTR _comma$13[ebp]

; 521  :          return addErrorAndRecover( "Missing ',' or '}' in object declaration", 

	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 795  :    addError( message, token );

	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	mov	ecx, esi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 776  :    int errorCount = int(errors_.size());

	mov	edi, DWORD PTR [esi+36]
$LL1137@readObject:

; 777  :    Token skip;
; 778  :    while ( true )
; 779  :    {
; 780  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$3[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN1139@readObject

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN1139@readObject:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$3[ebp]
	cmp	eax, 2
	je	SHORT $LN1505@readObject
	test	eax, eax
	jne	SHORT $LL1137@readObject
$LN1505@readObject:

; 783  :          break;
; 784  :    }
; 785  :    errors_.resize( errorCount );

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T8[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 521  :          return addErrorAndRecover( "Missing ',' or '}' in object declaration", 

	xor	bl, bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	$LN1282@readObject
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T8[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	jmp	$LN1282@readObject
$LN1502@readObject:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 513  :          return recoverFromError( tokenObjectEnd );

	push	2
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	bl, al
	jmp	$LN1282@readObject
$LN13@readObject:

; 504  :          return addErrorAndRecover( "Missing ':' after object member name", 

	push	OFFSET ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 795  :    addError( message, token );

	push	0
	lea	eax, DWORD PTR _colon$7[ebp]

; 504  :          return addErrorAndRecover( "Missing ':' after object member name", 

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 795  :    addError( message, token );

	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	mov	ecx, esi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 776  :    int errorCount = int(errors_.size());

	mov	edi, DWORD PTR [esi+36]
$LL180@readObject:

; 777  :    Token skip;
; 778  :    while ( true )
; 779  :    {
; 780  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$5[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN182@readObject

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN182@readObject:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$5[ebp]
	cmp	eax, 2
	je	SHORT $LN1506@readObject
	test	eax, eax
	jne	SHORT $LL180@readObject
$LN1506@readObject:

; 783  :          break;
; 784  :    }
; 785  :    errors_.resize( errorCount );

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T11[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 504  :          return addErrorAndRecover( "Missing ':' after object member name", 

	xor	bl, bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	$LN1282@readObject
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T11[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	jmp	$LN1282@readObject
$LN1523@readObject:
	cmp	DWORD PTR _name$[ebp+16], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 492  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

	jne	$LN3@readObject
$LN1504@readObject:
	mov	bl, 1
	jmp	$LN1282@readObject
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR _name$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readObject
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readValue@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
$T2 = -88						; size = 12
$T3 = -76						; size = 12
$T4 = -64						; size = 12
_token$ = -52						; size = 12
$T5 = -40						; size = 24
$T6 = -32						; size = 16
$T7 = -32						; size = 16
$T8 = -32						; size = 16
$T9 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?readValue@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readValue, COMDAT
; _this$ = ecx

; 196  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readValue@Reader@Json@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 197  :    Token token;
; 198  :    skipCommentTokens( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 199  :    bool successful = true;
; 200  : 
; 201  :    if ( collectComments_  &&  !commentsBefore_.empty() )

	cmp	BYTE PTR [edi+110], 0
	mov	bl, 1
	je	SHORT $LN4@readValue
	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN4@readValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T4[ebp]
	mov	ecx, edi
	push	eax
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN44@readValue
$LN43@readValue:
	mov	esi, DWORD PTR [esi]
$LN44@readValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	eax, edx
	mov	ecx, DWORD PTR [esi+8]

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	dec	ecx
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 203  :       currentValue().setComment( commentsBefore_, commentBefore );

	push	0
	lea	esi, DWORD PTR [edi+84]
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+ecx*4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 203  :       currentValue().setComment( commentsBefore_, commentBefore );

	mov	ecx, DWORD PTR [eax+edx*4]
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@readValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 208  :    switch ( token.type_ )

	mov	eax, DWORD PTR _token$[ebp]
	dec	eax
	cmp	eax, 8
	ja	$LN12@readValue
	jmp	DWORD PTR $LN294@readValue[eax*4]
$LN5@readValue:

; 209  :    {
; 210  :    case tokenObjectBegin:
; 211  :       successful = readObject( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readObject
	mov	bl, al

; 212  :       break;

	jmp	$LN2@readValue
$LN6@readValue:

; 213  :    case tokenArrayBegin:
; 214  :       successful = readArray( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readArray
	mov	bl, al

; 215  :       break;

	jmp	SHORT $LN2@readValue
$LN7@readValue:

; 216  :    case tokenNumber:
; 217  :       successful = decodeNumber( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeNumber
	mov	bl, al

; 218  :       break;

	jmp	SHORT $LN2@readValue
$LN8@readValue:

; 219  :    case tokenString:
; 220  :       successful = decodeString( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeString
	mov	bl, al

; 221  :       break;

	jmp	SHORT $LN2@readValue
$LN9@readValue:

; 222  :    case tokenTrue:
; 223  :       currentValue() = true;

	push	1
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0Value@Json@@QAE@_N@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T8[ebp]

; 224  :       break;

	jmp	SHORT $LN293@readValue
$LN10@readValue:

; 225  :    case tokenFalse:
; 226  :       currentValue() = false;

	push	0
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0Value@Json@@QAE@_N@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	eax, DWORD PTR $T7[ebp]

; 227  :       break;

	jmp	SHORT $LN293@readValue
$LN11@readValue:

; 228  :    case tokenNull:
; 229  :       currentValue() = Value();

	push	0
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 2
$LN293@readValue:
	push	eax
	mov	ecx, edi
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN2@readValue:

; 233  :    }
; 234  : 
; 235  :    if ( collectComments_ )

	cmp	BYTE PTR [edi+110], 0
	je	$LN177@readValue

; 237  :       lastValueEnd_ = current_;

	mov	eax, DWORD PTR [edi+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	mov	ecx, edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 237  :       lastValueEnd_ = current_;

	mov	DWORD PTR [edi+76], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	lea	eax, DWORD PTR $T3[ebp]
	push	1
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN289@readValue
$LN288@readValue:
	mov	esi, DWORD PTR [esi]
$LN289@readValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	shr	ecx, 2
	and	ecx, eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 238  :       lastValue_ = &currentValue();

	mov	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 238  :       lastValue_ = &currentValue();

	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [edi+80], eax

; 239  :    }
; 240  : 
; 241  :    return successful;

	jmp	SHORT $LN177@readValue
$LN12@readValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	46					; 0000002eH
	push	OFFSET ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
	lea	ecx, DWORD PTR $T5[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T5[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T5[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 232  :       return addError( "Syntax error: value, object or array expected.", token );

	push	0
	lea	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	mov	ecx, edi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T5[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 232  :       return addError( "Syntax error: value, object or array expected.", token );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN177@readValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN177@readValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 232  :       return addError( "Syntax error: value, object or array expected.", token );

	mov	al, bl

; 242  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN294@readValue:
	DD	$LN5@readValue
	DD	$LN12@readValue
	DD	$LN6@readValue
	DD	$LN12@readValue
	DD	$LN8@readValue
	DD	$LN7@readValue
	DD	$LN9@readValue
	DD	$LN10@readValue
	DD	$LN11@readValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readValue@Reader@Json@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?readValue@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readValue
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readNumber@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
?readNumber@Reader@Json@@AAEXXZ PROC			; Json::Reader::readNumber, COMDAT
; _this$ = ecx

; 453  : {

	push	esi

; 454  :    while ( current_ != end_ )

	mov	esi, DWORD PTR [ecx+68]
	cmp	DWORD PTR [ecx+72], esi
	je	SHORT $LN17@readNumber
	npad	7
$LL2@readNumber:

; 455  :    {
; 456  :       if ( !(*current_ >= '0'  &&  *current_ <= '9')  &&

	mov	edx, DWORD PTR [ecx+72]
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jl	SHORT $LN5@readNumber
	cmp	al, 57					; 00000039H
	jle	SHORT $LN9@readNumber
$LN5@readNumber:

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	cmp	al, 46					; 0000002eH
	je	SHORT $LN9@readNumber
	cmp	al, 101					; 00000065H
	je	SHORT $LN9@readNumber
	cmp	al, 69					; 00000045H
	je	SHORT $LN9@readNumber
	cmp	al, 43					; 0000002bH
	je	SHORT $LN9@readNumber
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN17@readNumber
$LN9@readNumber:

; 457  :            !in( *current_, '.', 'e', 'E', '+', '-' ) )
; 458  :          break;
; 459  :       ++current_;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx+72], eax
	cmp	eax, esi
	jne	SHORT $LL2@readNumber
$LN17@readNumber:
	pop	esi

; 460  :    }
; 461  : }

	ret	0
?readNumber@Reader@Json@@AAEXXZ ENDP			; Json::Reader::readNumber
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readString@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readString@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readString, COMDAT
; _this$ = ecx

; 466  :    Char c = 0;
; 467  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [ecx+72]
	xor	dl, dl
	push	esi
	mov	esi, DWORD PTR [ecx+68]
	cmp	eax, esi
	je	SHORT $LN18@readString
$LN9@readString:

; 812  :    return *current_++;

	mov	dl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [ecx+72], eax

; 468  :    {
; 469  :       c = getNextChar();
; 470  :       if ( c == '\\' )

	cmp	dl, 92					; 0000005cH
	jne	SHORT $LN4@readString

; 810  :    if ( current_ == end_ )

	cmp	eax, esi
	je	SHORT $LN6@readString

; 811  :       return 0;
; 812  :    return *current_++;

	inc	eax
	mov	DWORD PTR [ecx+72], eax

; 813  : }

	jmp	SHORT $LN6@readString
$LN4@readString:

; 471  :          getNextChar();
; 472  :       else if ( c == '"' )

	cmp	dl, 34					; 00000022H
	je	SHORT $LN19@readString
$LN6@readString:

; 466  :    Char c = 0;
; 467  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [ecx+72]
	cmp	eax, esi
	jne	SHORT $LN9@readString
$LN18@readString:
	cmp	dl, 34					; 00000022H
$LN19@readString:
	sete	al
	pop	esi

; 473  :          break;
; 474  :    }
; 475  :    return c == '"';
; 476  : }

	ret	0
?readString@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readCppStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readCppStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCppStyleComment, COMDAT
; _this$ = ecx

; 440  : {

	push	esi
	mov	esi, ecx

; 441  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+68]
	cmp	eax, edx
	je	SHORT $LN20@readCppSty
$LN22@readCppSty:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+72], eax

; 442  :    {
; 443  :       Char c = getNextChar();
; 444  :       if (  c == '\r'  ||  c == '\n' )

	cmp	cl, 13					; 0000000dH
	je	SHORT $LN20@readCppSty
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN20@readCppSty

; 441  :    while ( current_ != end_ )

	cmp	eax, edx
	jne	SHORT $LN22@readCppSty
$LN20@readCppSty:

; 445  :          break;
; 446  :    }
; 447  :    return true;

	mov	al, 1
	pop	esi

; 448  : }

	ret	0
?readCppStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCppStyleComment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readCStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readCStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCStyleComment, COMDAT
; _this$ = ecx

; 427  : {

	push	esi
	mov	esi, ecx

; 428  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+68]
	cmp	eax, edx
	je	SHORT $LN17@readCStyle
$LN19@readCStyle:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+72], eax

; 429  :    {
; 430  :       Char c = getNextChar();
; 431  :       if ( c == '*'  &&  *current_ == '/' )

	cmp	cl, 42					; 0000002aH
	jne	SHORT $LN4@readCStyle
	cmp	BYTE PTR [eax], 47			; 0000002fH
	je	SHORT $LN17@readCStyle
$LN4@readCStyle:

; 428  :    while ( current_ != end_ )

	cmp	eax, edx
	jne	SHORT $LN19@readCStyle
$LN17@readCStyle:

; 810  :    if ( current_ == end_ )

	mov	eax, DWORD PTR [esi+72]
	cmp	eax, edx
	jne	SHORT $LN10@readCStyle

; 811  :       return 0;

	xor	cl, cl
	cmp	cl, 47					; 0000002fH
	pop	esi
	sete	al

; 432  :          break;
; 433  :    }
; 434  :    return getNextChar() == '/';
; 435  : }

	ret	0
$LN10@readCStyle:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, 47					; 0000002fH
	mov	DWORD PTR [esi+72], eax
	pop	esi
	sete	al

; 432  :          break;
; 433  :    }
; 434  :    return getNextChar() == '/';
; 435  : }

	ret	0
?readCStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCStyleComment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_commentBegin$1$ = -4					; size = 4
?readComment@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readComment, COMDAT
; _this$ = ecx

; 379  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 380  :    Location commentBegin = current_ - 1;

	mov	eax, DWORD PTR [esi+72]

; 810  :    if ( current_ == end_ )

	mov	ecx, DWORD PTR [esi+68]

; 380  :    Location commentBegin = current_ - 1;

	lea	edx, DWORD PTR [eax-1]
	mov	DWORD PTR _commentBegin$1$[ebp], edx

; 810  :    if ( current_ == end_ )

	cmp	eax, ecx
	je	SHORT $LN27@readCommen

; 811  :       return 0;
; 812  :    return *current_++;

	mov	bl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+72], eax

; 381  :    Char c = getNextChar();
; 382  :    bool successful = false;
; 383  :    if ( c == '*' )

	cmp	bl, 42					; 0000002aH
	jne	SHORT $LN2@readCommen

; 384  :       successful = readCStyleComment();

	mov	ecx, esi
	call	?readCStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCStyleComment

; 386  :       successful = readCppStyleComment();
; 387  :    if ( !successful )

	test	al, al
	jne	SHORT $LN34@readCommen
$LN27@readCommen:
	pop	esi

; 388  :       return false;

	xor	al, al
	pop	ebx

; 402  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@readCommen:

; 385  :    else if ( c == '/' )

	cmp	bl, 47					; 0000002fH
	jne	SHORT $LN27@readCommen

; 441  :    while ( current_ != end_ )

	cmp	eax, ecx
	je	SHORT $LN5@readCommen
	npad	1
$LL15@readCommen:

; 810  :    if ( current_ == end_ )

	cmp	eax, ecx
	je	SHORT $LN29@readCommen

; 811  :       return 0;
; 812  :    return *current_++;

	mov	dl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+72], eax

; 444  :       if (  c == '\r'  ||  c == '\n' )

	cmp	dl, 13					; 0000000dH
	je	SHORT $LN34@readCommen
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN34@readCommen
$LN29@readCommen:

; 403  : 
; 404  : 
; 405  : void 
; 406  : Reader::addComment( Location begin, 
; 407  :                     Location end, 
; 408  :                     CommentPlacement placement )
; 409  : {
; 410  :    assert( collectComments_ );
; 411  :    if ( placement == commentAfterOnSameLine )
; 412  :    {
; 413  :       assert( lastValue_ != 0 );
; 414  :       lastValue_->setComment( std::string( begin, end ), placement );
; 415  :    }
; 416  :    else
; 417  :    {
; 418  :       if ( !commentsBefore_.empty() )
; 419  :          commentsBefore_ += "\n";
; 420  :       commentsBefore_ += std::string( begin, end );
; 421  :    }
; 422  : }
; 423  : 
; 424  : 
; 425  : bool 
; 426  : Reader::readCStyleComment()
; 427  : {
; 428  :    while ( current_ != end_ )
; 429  :    {
; 430  :       Char c = getNextChar();
; 431  :       if ( c == '*'  &&  *current_ == '/' )
; 432  :          break;
; 433  :    }
; 434  :    return getNextChar() == '/';
; 435  : }
; 436  : 
; 437  : 
; 438  : bool 
; 439  : Reader::readCppStyleComment()
; 440  : {
; 441  :    while ( current_ != end_ )

	cmp	DWORD PTR [esi+72], ecx
	jne	SHORT $LL15@readCommen
$LN34@readCommen:
	mov	edx, DWORD PTR _commentBegin$1$[ebp]
$LN5@readCommen:

; 389  : 
; 390  :    if ( collectComments_ )

	cmp	BYTE PTR [esi+110], 0
	je	SHORT $LN6@readCommen

; 391  :    {
; 392  :       CommentPlacement placement = commentBefore;
; 393  :       if ( lastValueEnd_  &&  !containsNewLine( lastValueEnd_, commentBegin ) )

	mov	eax, DWORD PTR [esi+76]
	push	edi
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN32@readCommen
	push	edx
	push	eax
	call	?containsNewLine@Json@@YA_NPBD0@Z	; Json::containsNewLine
	add	esp, 8
	test	al, al
	jne	SHORT $LN32@readCommen

; 394  :       {
; 395  :          if ( c != '*'  ||  !containsNewLine( commentBegin, current_ ) )

	cmp	bl, 42					; 0000002aH
	mov	ebx, DWORD PTR _commentBegin$1$[ebp]
	jne	SHORT $LN9@readCommen
	push	DWORD PTR [esi+72]
	push	ebx
	call	?containsNewLine@Json@@YA_NPBD0@Z	; Json::containsNewLine
	add	esp, 8
	test	al, al
	jne	SHORT $LN8@readCommen
$LN9@readCommen:

; 396  :             placement = commentAfterOnSameLine;

	mov	edi, 1

; 397  :       }
; 398  : 
; 399  :       addComment( commentBegin, current_, placement );

	mov	ecx, esi
	push	edi
	push	DWORD PTR [esi+72]
	push	ebx
	call	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
	pop	edi
	pop	esi

; 400  :    }
; 401  :    return true;

	mov	al, 1
	pop	ebx

; 402  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@readCommen:
	mov	ebx, DWORD PTR _commentBegin$1$[ebp]
$LN8@readCommen:

; 397  :       }
; 398  : 
; 399  :       addComment( commentBegin, current_, placement );

	push	edi
	push	DWORD PTR [esi+72]
	mov	ecx, esi
	push	ebx
	call	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
	pop	edi
$LN6@readCommen:

; 400  :    }
; 401  :    return true;

	pop	esi
	mov	al, 1
	pop	ebx

; 402  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readComment@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readComment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?match@Reader@Json@@AAE_NPBDH@Z
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
_patternLength$ = 12					; size = 4
?match@Reader@Json@@AAE_NPBDH@Z PROC			; Json::Reader::match, COMDAT
; _this$ = ecx

; 365  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	push	esi

; 366  :    if ( end_ - current_ < patternLength )

	mov	esi, DWORD PTR _patternLength$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+68]
	mov	edi, DWORD PTR [ebx+72]
	sub	eax, edi
	cmp	eax, esi
	jge	SHORT $LN4@match
$LN8@match:
	pop	edi
	pop	esi

; 367  :       return false;

	xor	al, al
	pop	ebx

; 374  : }

	pop	ebp
	ret	8
$LN4@match:

; 368  :    int index = patternLength;

	mov	edx, esi

; 369  :    while ( index-- )

	test	esi, esi
	je	SHORT $LN9@match

; 370  :       if ( current_[index] != pattern[index] )

	mov	eax, DWORD PTR _pattern$[ebp]
	sub	edi, eax
	lea	ecx, DWORD PTR [eax+esi]
	npad	2
$LL2@match:
	mov	al, BYTE PTR [edi+ecx-1]
	lea	ecx, DWORD PTR [ecx-1]
	dec	edx
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN8@match

; 369  :    while ( index-- )

	test	edx, edx
	jne	SHORT $LL2@match

; 370  :       if ( current_[index] != pattern[index] )

	mov	edi, DWORD PTR [ebx+72]
$LN9@match:

; 371  :          return false;
; 372  :    current_ += patternLength;

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	mov	DWORD PTR [ebx+72], eax

; 373  :    return true;

	mov	al, 1
	pop	esi
	pop	ebx

; 374  : }

	pop	ebp
	ret	8
?match@Reader@Json@@AAE_NPBDH@Z ENDP			; Json::Reader::match
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?skipSpaces@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
?skipSpaces@Reader@Json@@AAEXXZ PROC			; Json::Reader::skipSpaces, COMDAT
; _this$ = ecx

; 350  : {

	push	esi

; 351  :    while ( current_ != end_ )

	mov	esi, DWORD PTR [ecx+68]
	cmp	DWORD PTR [ecx+72], esi
	je	SHORT $LN11@skipSpaces
	npad	7
$LL2@skipSpaces:

; 352  :    {
; 353  :       Char c = *current_;

	mov	edx, DWORD PTR [ecx+72]
	mov	al, BYTE PTR [edx]

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	cmp	al, 32					; 00000020H
	je	SHORT $LN6@skipSpaces
	cmp	al, 9
	je	SHORT $LN6@skipSpaces
	cmp	al, 13					; 0000000dH
	je	SHORT $LN6@skipSpaces
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN11@skipSpaces
$LN6@skipSpaces:

; 355  :          ++current_;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx+72], eax
	cmp	eax, esi
	jne	SHORT $LL2@skipSpaces
$LN11@skipSpaces:
	pop	esi

; 356  :       else
; 357  :          break;
; 358  :    }
; 359  : }

	ret	0
?skipSpaces@Reader@Json@@AAEXXZ ENDP			; Json::Reader::skipSpaces
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
_token$ = 8						; size = 4
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readToken, COMDAT
; _this$ = ecx

; 275  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 351  :    while ( current_ != end_ )

	mov	edx, DWORD PTR [edi+68]
	cmp	DWORD PTR [edi+72], edx
	je	SHORT $LN35@readToken
	npad	1
$LL21@readToken:

; 352  :    {
; 353  :       Char c = *current_;

	mov	ecx, DWORD PTR [edi+72]
	mov	al, BYTE PTR [ecx]

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	cmp	al, 32					; 00000020H
	je	SHORT $LN25@readToken
	cmp	al, 9
	je	SHORT $LN25@readToken
	cmp	al, 13					; 0000000dH
	je	SHORT $LN25@readToken
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN35@readToken
$LN25@readToken:

; 355  :          ++current_;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi+72], eax
	cmp	eax, edx
	jne	SHORT $LL21@readToken
$LN35@readToken:

; 276  :    skipSpaces();
; 277  :    token.start_ = current_;

	mov	esi, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+4], eax

; 810  :    if ( current_ == end_ )

	mov	eax, DWORD PTR [edi+72]
	cmp	eax, DWORD PTR [edi+68]
	jne	SHORT $LN28@readToken

; 811  :       return 0;

	xor	cl, cl
	jmp	SHORT $LN27@readToken
$LN28@readToken:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [edi+72], eax
$LN27@readToken:

; 278  :    Char c = getNextChar();
; 279  :    bool ok = true;
; 280  :    switch ( c )

	movsx	eax, cl
	cmp	eax, 125				; 0000007dH
	ja	$LN33@readToken
	movzx	eax, BYTE PTR $LN34@readToken[eax]
	jmp	DWORD PTR $LN38@readToken[eax*4]
$LN4@readToken:

; 281  :    {
; 282  :    case '{':
; 283  :       token.type_ = tokenObjectBegin;

	mov	DWORD PTR [esi], 1

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN5@readToken:

; 284  :       break;
; 285  :    case '}':
; 286  :       token.type_ = tokenObjectEnd;

	mov	DWORD PTR [esi], 2

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN6@readToken:

; 287  :       break;
; 288  :    case '[':
; 289  :       token.type_ = tokenArrayBegin;

	mov	DWORD PTR [esi], 3

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN7@readToken:

; 290  :       break;
; 291  :    case ']':
; 292  :       token.type_ = tokenArrayEnd;

	mov	DWORD PTR [esi], 4

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN8@readToken:

; 293  :       break;
; 294  :    case '"':
; 295  :       token.type_ = tokenString;
; 296  :       ok = readString();

	mov	ecx, edi
	mov	DWORD PTR [esi], 5
	call	?readString@Reader@Json@@AAE_NXZ	; Json::Reader::readString

; 297  :       break;

	jmp	SHORT $LN2@readToken
$LN9@readToken:

; 298  :    case '/':
; 299  :       token.type_ = tokenComment;
; 300  :       ok = readComment();

	mov	ecx, edi
	mov	DWORD PTR [esi], 12			; 0000000cH
	call	?readComment@Reader@Json@@AAE_NXZ	; Json::Reader::readComment

; 301  :       break;

	jmp	SHORT $LN2@readToken
$LN10@readToken:

; 302  :    case '0':
; 303  :    case '1':
; 304  :    case '2':
; 305  :    case '3':
; 306  :    case '4':
; 307  :    case '5':
; 308  :    case '6':
; 309  :    case '7':
; 310  :    case '8':
; 311  :    case '9':
; 312  :    case '-':
; 313  :       token.type_ = tokenNumber;
; 314  :       readNumber();

	mov	ecx, edi
	mov	DWORD PTR [esi], 6
	call	?readNumber@Reader@Json@@AAEXXZ		; Json::Reader::readNumber

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN11@readToken:

; 315  :       break;
; 316  :    case 't':
; 317  :       token.type_ = tokenTrue;
; 318  :       ok = match( "rue", 3 );

	push	3
	mov	DWORD PTR [esi], 7
	push	OFFSET ??_C@_03FFDNHNKN@rue?$AA@

; 319  :       break;

	jmp	SHORT $LN36@readToken
$LN12@readToken:

; 320  :    case 'f':
; 321  :       token.type_ = tokenFalse;
; 322  :       ok = match( "alse", 4 );

	push	4
	mov	DWORD PTR [esi], 8
	push	OFFSET ??_C@_04KCECFHEP@alse?$AA@

; 323  :       break;

	jmp	SHORT $LN36@readToken
$LN13@readToken:

; 324  :    case 'n':
; 325  :       token.type_ = tokenNull;
; 326  :       ok = match( "ull", 3 );

	push	3
	mov	DWORD PTR [esi], 9
	push	OFFSET ??_C@_03KNPGGKC@ull?$AA@
$LN36@readToken:
	mov	ecx, edi
	call	?match@Reader@Json@@AAE_NPBDH@Z		; Json::Reader::match
$LN2@readToken:

; 336  :       break;
; 337  :    default:
; 338  :       ok = false;
; 339  :       break;
; 340  :    }
; 341  :    if ( !ok )

	test	al, al
	jne	SHORT $LN18@readToken
$LN33@readToken:

; 342  :       token.type_ = tokenError;

	mov	DWORD PTR [esi], 13			; 0000000dH
$LN18@readToken:

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN14@readToken:

; 327  :       break;
; 328  :    case ',':
; 329  :       token.type_ = tokenArraySeparator;

	mov	DWORD PTR [esi], 10			; 0000000aH

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN15@readToken:

; 330  :       break;
; 331  :    case ':':
; 332  :       token.type_ = tokenMemberSeparator;

	mov	DWORD PTR [esi], 11			; 0000000bH

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN16@readToken:

; 333  :       break;
; 334  :    case 0:
; 335  :       token.type_ = tokenEndOfStream;

	mov	DWORD PTR [esi], 0

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
	npad	1
$LN38@readToken:
	DD	$LN16@readToken
	DD	$LN8@readToken
	DD	$LN14@readToken
	DD	$LN10@readToken
	DD	$LN9@readToken
	DD	$LN15@readToken
	DD	$LN6@readToken
	DD	$LN7@readToken
	DD	$LN12@readToken
	DD	$LN13@readToken
	DD	$LN11@readToken
	DD	$LN4@readToken
	DD	$LN5@readToken
	DD	$LN33@readToken
$LN34@readToken:
	DB	0
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	1
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	2
	DB	3
	DB	13					; 0000000dH
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	6
	DB	13					; 0000000dH
	DB	7
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	8
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	9
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	10					; 0000000aH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	11					; 0000000bH
	DB	13					; 0000000dH
	DB	12					; 0000000cH
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
_TEXT	SEGMENT
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_token$ = 12						; size = 4
_message$ = 16						; size = 4
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z PROC ; Json::Reader::expectToken, COMDAT
; _this$ = ecx

; 265  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _token$[ebp]
	mov	esi, DWORD PTR _message$[ebp]

; 266  :    readToken( token );

	push	edi
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 267  :    if ( token.type_ != type )

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR _type$[ebp]
	je	SHORT $LN2@expectToke
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0

; 523  : 		return (*_First == 0 ? 0

	jne	SHORT $LN119@expectToke
	xor	ecx, ecx
	jmp	SHORT $LN120@expectToke
$LN119@expectToke:
	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL226@expectToke:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL226@expectToke
	sub	ecx, edx
$LN120@expectToke:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	esi
	lea	ecx, DWORD PTR $T2[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 268  :       return addError( message, token );

	push	0
	push	edi
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	mov	ecx, ebx
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T2[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 268  :       return addError( message, token );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN127@expectToke
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN127@expectToke:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 268  :       return addError( message, token );

	mov	al, bl
	jmp	SHORT $LN1@expectToke
$LN2@expectToke:

; 269  :    return true;

	mov	al, 1
$LN1@expectToke:

; 270  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ENDP ; Json::Reader::expectToken
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??_GErrorInfo@Reader@Json@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z PROC		; Json::Reader::ErrorInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+32]
	lea	esi, DWORD PTR [edi+12]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN13@scalar:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN105@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN105@scalar:
	test	BYTE PTR ___flags$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	je	SHORT $LN112@scalar
	push	40					; 00000028H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN112@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z ENDP		; Json::Reader::ErrorInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z PROC		; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	push	edi
	mov	edi, ecx

; 782  : 		assign(_Right, 0, npos);

	push	-1
	movq	xmm0, QWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+12]
	push	0
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
	mov	eax, edi
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z ENDP		; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??1ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??1ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::~ErrorInfo, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@ErrorInfo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+12]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN9@ErrorInfo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@ErrorInfo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	ret	0
$LN101@ErrorInfo:
	mov	BYTE PTR [esi+12], 0
	pop	esi
	ret	0
??1ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::~ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??0ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+32], 15			; 0000000fH
	mov	eax, ecx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+12], 0
	ret	0
??0ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T2 = -124						; size = 12
_itError$3 = -112					; size = 12
___$ReturnUdt$GSCopy$ = -100				; size = 4
$T4 = -96						; size = 4
_this$GSCopy$1$ = -92					; size = 4
$T5 = -88						; size = 24
$T6 = -88						; size = 24
$T7 = -88						; size = 24
$T8 = -64						; size = 24
$T9 = -64						; size = 24
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Reader::getFormatedErrorMessages, COMDAT
; _this$ = ecx

; 859  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T4[ebp], 0
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [esi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN121@getFormate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN122@getFormate
$LN121@getFormate:
	mov	eax, esi
$LN122@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 871  :    return formattedMessage;

	lea	ebx, DWORD PTR [ecx+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR _itError$3[ebp]
	mov	DWORD PTR $T4[ebp], 1
	push	eax
	mov	ecx, ebx
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, ebx
	push	eax
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 468  : 		return (this->_Myoff == _Right._Myoff);

	mov	edi, DWORD PTR _itError$3[ebp+8]
	cmp	edi, DWORD PTR [eax+8]

; 473  : 		return (!(*this == _Right));

	setne	al
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 862  :          itError != errors_.end();

	test	al, al
	je	$LN1086@getFormate
	npad	2
$LL4@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR _itError$3[ebp]
	test	eax, eax
	je	SHORT $LN141@getFormate
$LN140@getFormate:
	mov	eax, DWORD PTR [eax]
$LN141@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 865  :       const ErrorInfo &error = *itError;

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 865  :       const ErrorInfo &error = *itError;

	mov	ebx, DWORD PTR [eax+ecx*4]

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	lea	eax, DWORD PTR $T7[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	DWORD PTR [ebx+4]
	push	eax
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	push	eax
	lea	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	OFFSET ??_C@_02KAOAMBHJ@?$CK?5?$AA@
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	eax
	lea	eax, DWORD PTR $T9[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T9[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN234@getFormate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR $T9[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN229@getFormate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN1062@getFormate

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN1062@getFormate

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN1062@getFormate

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN1062@getFormate

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN229@getFormate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN234@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T12[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T9[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T9[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T9[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN352@getFormate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR $T12[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN347@getFormate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN1062@getFormate

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN1062@getFormate

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN1062@getFormate

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN1062@getFormate

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN347@getFormate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN352@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T7[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T12[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T12[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T12[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN469@getFormate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR $T7[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN464@getFormate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN1062@getFormate

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN1062@getFormate

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN1062@getFormate

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN1062@getFormate

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN464@getFormate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN469@getFormate:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 867  :       formattedMessage += "  " + error.message_ + "\n";

	lea	eax, DWORD PTR [ebx+12]
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 867  :       formattedMessage += "  " + error.message_ + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T11[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 867  :       formattedMessage += "  " + error.message_ + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN590@getFormate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR $T11[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN585@getFormate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN1062@getFormate

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN1062@getFormate

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN1062@getFormate

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN1062@getFormate

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN585@getFormate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN590@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T6[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T11[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T11[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T11[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 867  :       formattedMessage += "  " + error.message_ + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN707@getFormate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN702@getFormate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN1062@getFormate

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN1062@getFormate

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN1062@getFormate

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN1062@getFormate

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN702@getFormate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN707@getFormate:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 868  :       if ( error.extra_ )

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	$LN2@getFormate

; 869  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	push	OFFSET ??_C@_04JBAOJHKB@See?5?$AA@
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 869  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T10[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN748@getFormate

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T10[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN748@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T8[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T10[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T10[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T10[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN853@getFormate

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T8[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN853@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T5[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T8[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T8[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T8[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 869  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN2@getFormate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@getFormate:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 862  :          itError != errors_.end();

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 368  : 		++_Myoff;

	inc	edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 862  :          itError != errors_.end();

	lea	ecx, DWORD PTR [ecx+20]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edi, DWORD PTR [eax+8]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 862  :          itError != errors_.end();

	jne	$LL4@getFormate
$LN1086@getFormate:

; 871  :    return formattedMessage;

	mov	eax, esi

; 872  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN1062@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN1089@getFormate:
$LN1088@getFormate:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 1
	je	$LN8@getFormate
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@getFormate:
	ret	0
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Reader::getFormatedErrorMessages
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_doc$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 137  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR _sin$[ebp]
	mov	ebx, DWORD PTR _root$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _doc$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _doc$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _doc$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 151  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	push	-1
	lea	ecx, DWORD PTR _doc$[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 145  :    std::string doc;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 151  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	push	ecx
	push	eax
	call	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 126  :    document_ = document;

	lea	esi, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 151  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	lea	eax, DWORD PTR _doc$[ebp]
	cmp	esi, eax
	je	SHORT $LN123@parse

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN123@parse:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN271@parse
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN271@parse:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 129  :    return parse( begin, end, root, collectComments );

	push	DWORD PTR _collectComments$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [edi+56]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 129  :    return parse( begin, end, root, collectComments );

	mov	ecx, edi
	push	ebx
	add	eax, esi
	push	eax
	push	esi
	call	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ; Json::Reader::parse
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _doc$[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 147  :    return parse( doc, root, collectComments );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN391@parse
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _doc$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN391@parse:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 147  :    return parse( doc, root, collectComments );

	mov	al, bl

; 148  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0:
	lea	ecx, DWORD PTR _doc$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
_TEXT	SEGMENT
_token$ = -64						; size = 12
_endDoc$GSCopy$1$ = -52					; size = 4
_beginDoc$GSCopy$1$ = -48				; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_beginDoc$ = 8						; size = 4
_endDoc$ = 12						; size = 4
_root$ = 16						; size = 4
_collectComments$ = 20					; size = 1
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z PROC	; Json::Reader::parse, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	eax, DWORD PTR _endDoc$[ebp]
	xor	ecx, ecx
	cmp	BYTE PTR [esi+108], cl
	mov	edx, DWORD PTR _beginDoc$[ebp]
	mov	edi, DWORD PTR _root$[ebp]
	mov	DWORD PTR _endDoc$GSCopy$1$[ebp], eax

; 161  :    end_ = endDoc;

	mov	DWORD PTR [esi+68], eax
	movzx	eax, BYTE PTR _collectComments$[ebp]
	cmovne	ecx, eax
	mov	DWORD PTR _beginDoc$GSCopy$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 162  :    collectComments_ = collectComments;

	mov	BYTE PTR [esi+110], cl

; 166  :    commentsBefore_ = "";

	lea	ecx, DWORD PTR [esi+84]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 160  :    begin_ = beginDoc;

	mov	DWORD PTR [esi+64], edx

; 163  :    current_ = begin_;

	mov	DWORD PTR [esi+72], edx

; 164  :    lastValueEnd_ = 0;

	mov	DWORD PTR [esi+76], 0

; 165  :    lastValue_ = 0;

	mov	DWORD PTR [esi+80], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 167  :    errors_.clear();

	lea	ecx, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1675 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
	cmp	DWORD PTR [esi+16], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 168  :    while ( !nodes_.empty() )

	je	SHORT $LN3@parse
	npad	1
$LL2@parse:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN38@parse

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN38@parse:
	cmp	DWORD PTR [esi+16], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 168  :    while ( !nodes_.empty() )

	jne	SHORT $LL2@parse
$LN3@parse:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 170  :    nodes_.push( &root );

	mov	DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	push	eax
	mov	ecx, esi
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 172  :    bool successful = readValue();

	mov	ecx, esi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
	mov	bl, al

; 173  :    Token token;
; 174  :    skipCommentTokens( token );

	mov	ecx, esi
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 175  :    if ( collectComments_  &&  !commentsBefore_.empty() )

	cmp	BYTE PTR [esi+110], 0
	je	SHORT $LN5@parse
	cmp	DWORD PTR [esi+100], 0
	lea	eax, DWORD PTR [esi+84]
	je	SHORT $LN5@parse

; 176  :       root.setComment( commentsBefore_, commentAfter );

	push	2
	push	eax
	mov	ecx, edi
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
$LN5@parse:

; 177  :    if ( features_.strictRoot_ )

	cmp	BYTE PTR [esi+109], 0
	je	SHORT $LN7@parse

; 178  :    {
; 179  :       if ( !root.isArray()  &&  !root.isObject() )

	mov	ecx, edi
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	test	al, al
	jne	SHORT $LN7@parse
	mov	ecx, edi
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	test	al, al
	jne	SHORT $LN7@parse

; 180  :       {
; 181  :          // Set error location to start of doc, ideally should be first token found in doc
; 182  :          token.type_ = tokenError;
; 183  :          token.start_ = beginDoc;

	mov	eax, DWORD PTR _beginDoc$GSCopy$1$[ebp]

; 184  :          token.end_ = endDoc;
; 185  :          addError( "A valid JSON document must be either an array or an object value.",

	lea	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _token$[ebp+4], eax
	mov	eax, DWORD PTR _endDoc$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
	mov	DWORD PTR _token$[ebp], 13		; 0000000dH
	mov	DWORD PTR _token$[ebp+8], eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	0
	lea	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, esi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 186  :                    token );
; 187  :          return false;

	xor	al, al
	jmp	SHORT $LN1@parse
$LN7@parse:

; 188  :       }
; 189  :    }
; 190  :    return successful;

	mov	al, bl
$LN1@parse:

; 191  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ENDP	; Json::Reader::parse
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_document$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 125  : {

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	mov	eax, DWORD PTR _document$[ebp]
	push	esi
	push	edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 125  : {

	mov	edi, ecx

; 126  :    document_ = document;

	lea	esi, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	esi, eax
	je	SHORT $LN4@parse

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@parse:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN151@parse
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN151@parse:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 129  :    return parse( begin, end, root, collectComments );

	push	DWORD PTR _collectComments$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [edi+56]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 129  :    return parse( begin, end, root, collectComments );

	mov	ecx, edi
	push	DWORD PTR _root$[ebp]
	add	eax, esi
	push	eax
	push	esi
	call	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ; Json::Reader::parse
	pop	edi
	pop	esi

; 130  : }

	pop	ebp
	ret	12					; 0000000cH
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ??0Reader@Json@@QAE@ABVFeatures@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_features$ = 8						; size = 4
??0Reader@Json@@QAE@ABVFeatures@1@@Z PROC		; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN40@Reader
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN422@Reader:
$LN40@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 117  : {

	lea	edi, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 117  : {

	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [edi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [edi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [edi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN135@Reader
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN423@Reader:
$LN135@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 116  :    : features_( features )

	mov	eax, DWORD PTR _features$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+60], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+56], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+104], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+100], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+84], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 116  :    : features_( features )

	mov	ax, WORD PTR [eax]
	mov	WORD PTR [esi+108], ax

; 118  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN421@Reader:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@ABVFeatures@1@@Z ENDP		; Json::Reader::Reader
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ??0Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Reader@Json@@QAE@XZ PROC				; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 111  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN40@Reader
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN426@Reader:
$LN40@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 111  : {

	lea	edi, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 111  : {

	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [edi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [edi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [edi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN135@Reader
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN427@Reader:
$LN135@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 112  : }

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+60], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+56], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+104], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+100], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+84], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 20   :    : allowComments_( true )

	mov	WORD PTR [esi+108], 1

; 112  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN425@Reader:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@XZ ENDP				; Json::Reader::Reader
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 65   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 66   :     {
; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, DWORD PTR __Message$[ebp]
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept

; 163  : 		{	// construct from message string

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN17@runtime_er
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN17@runtime_er:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h

; 52   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 53   :     {

	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$1[ebp], edx

; 55   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR __InitData$1[ebp]
	push	eax
	mov	BYTE PTR __InitData$1[ebp+4], 1
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept

; 163  : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 164  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jae	SHORT $LN2@Check_offs

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN18@Check_offs:
$LN2@Check_offs:

; 2272 : 			_Xran();
; 2273 : 		}

	pop	ebp
	ret	4
$LN17@Check_offs:
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 2249 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN57@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN57@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	eax, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ebx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	ebx
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN96@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
$LN96@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN17@Inside
$LN16@Inside:
	mov	esi, ecx
$LN17@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	edx, esi
	jb	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN30@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN31@Inside
$LN30@Inside:
	mov	esi, ecx
$LN31@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [ecx+16]
	add	eax, esi
	cmp	eax, edx
	jbe	SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

	mov	al, 1
	pop	esi

; 2244 : 		}

	pop	ebp
	ret	4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2244 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	esi

; 2225 : 		if (max_size() < _Newsize)

	mov	esi, DWORD PTR __Newsize$[ebp]
	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN2@Grow

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN90@Grow:
$LN2@Grow:

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], esi
	jae	SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [ecx+16]
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	esi, esi
	pop	esi
	setne	al

; 2235 : 		}

	pop	ebp
	ret	8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN5@Grow
	cmp	esi, 16					; 00000010H
	jae	SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

	mov	eax, DWORD PTR [ecx+16]
	cmp	esi, eax
	cmovb	eax, esi
	push	eax
	push	1
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	test	esi, esi
	pop	esi
	setne	al

; 2235 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $LN88@Grow

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], esi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN80@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN80@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
	test	esi, esi
$LN88@Grow:
	setne	al
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2235 : 		}

	pop	ebp
	ret	8
$LN89@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, eax
	or	edi, 15					; 0000000fH

; 2184 : 		if (max_size() < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

	jmp	SHORT $LN108@Copy
$LN2@Copy:
	mov	ebx, DWORD PTR [esi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

	mov	eax, -2					; fffffffeH

; 2189 : 			_Newres = this->_Myres()

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN108@Copy

; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	edi, -2					; fffffffeH
$LN108@Copy:

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 51   : 	if (_Count == 0)

	test	eax, eax
	jne	SHORT $LN136@Copy

; 52   : 		return (_Ptr);

	xor	ebx, ebx
	jmp	SHORT $LN19@Copy
$LN136@Copy:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)
; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;
; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN138@Copy

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN140@Copy

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN443@Copy:
$LN140@Copy:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	eax, eax
	jne	SHORT $LN141@Copy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN444@Copy:
$LN141@Copy:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

	jmp	SHORT $LN19@Copy
$LN138@Copy:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	ebx, ebx
	jne	SHORT $LN19@Copy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN445@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

	mov	eax, $LN440@Copy
	ret	0
$LN440@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	mov	eax, DWORD PTR __Oldlen$[ebp]
	test	eax, eax
	je	SHORT $LN274@Copy

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN265@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN266@Copy
$LN265@Copy:
	mov	ecx, esi
$LN266@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN274@Copy
	push	eax
	push	ecx
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN274@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN278@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN278@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN370@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN371@Copy
$LN370@Copy:
	mov	eax, esi
$LN371@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Oldlen$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2212 : 		this->_Myres() = _Newres;

	mov	DWORD PTR [esi+20], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN434@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, ebx
$LN434@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR _this$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN156@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN156@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN249@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN249@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	call	__CxxThrowException@8
$LN446@Copy:
$LN442@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

	push	ebp
	mov	ebp, esp

; 2175 : 		if (_Count == 1)

	mov	eax, DWORD PTR __Count$[ebp]
	mov	edx, ecx
	cmp	eax, 1
	jne	SHORT $LN2@Chassign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN16@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN16@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	eax, DWORD PTR __Off$[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx+eax], cl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Chassign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN33@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN33@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

	push	ebp
	mov	ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	DWORD PTR __Size$[ebp], eax
	cmovbe	eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 1793 : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	eax, DWORD PTR __Newcap$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, eax
	ja	SHORT $LN47@reserve
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN47@reserve

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN47@reserve

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN42@reserve
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN42@reserve:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
$LN47@reserve:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1800 : 		}

	pop	ebp
	ret	4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1780 : 		{	// determine new length, padding with _Ch elements as needed

	push	ebp
	mov	ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, edx
	ja	SHORT $LN2@resize

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN25@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN25@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1785 : 		}

	pop	ebp
	ret	8
$LN2@resize:

; 1782 : 			_Eos(_Newsize);
; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	sub	eax, edx
	mov	DWORD PTR __Newsize$[ebp], eax

; 1785 : 		}

	pop	ebp

; 1782 : 			_Eos(_Newsize);
; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1775 : 		{	// determine new length, padding with null elements as needed

	push	ebp
	mov	ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, edx
	ja	SHORT $LN4@resize

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN27@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN27@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1777 : 		}

	pop	ebp
	ret	4
$LN4@resize:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1777 : 		}

	pop	ebp
	ret	4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1772 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1766 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1761 : 		}

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN13@c_str

; 1743 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 1744 : 		}

	ret	0
$LN13@c_str:

; 1743 : 		return (this->_Myptr());

	mov	eax, ecx

; 1744 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1688 : 		return (this->_Myptr()[_Off]);

	mov	eax, DWORD PTR __Off$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN13@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1688 : 		return (this->_Myptr()[_Off]);

	add	eax, ecx

; 1689 : 		}

	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, ecx
	jae	SHORT $LN7@erase

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN94@erase:
$LN7@erase:

; 1348 : 		_Check_offset(_Off);
; 1349 : 		if (this->_Mysize() - _Off <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, ecx
	cmp	eax, edx
	ja	SHORT $LN2@erase

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN41@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN41@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1359 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1351 : 		else if (0 < _Count)

	test	edx, edx
	je	SHORT $LN90@erase

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN58@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN59@erase
$LN58@erase:
	mov	eax, esi
$LN59@erase:

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN74@erase
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	push	ebx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN74@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi
	pop	ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN85@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN85@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN90@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN93@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jae	SHORT $LN4@erase

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN38@erase:
$LN4@erase:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN29@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	pop	ebp
	ret	4
$LN29@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	pop	ebp
	ret	4
$LN37@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@insert
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi

; 1274 : 		}

	pop	ebp
	ret	8
$LN5@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@insert:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@insert
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi

; 1274 : 		}

	pop	ebp
	ret	8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
tv774 = -4						; size = 4
__Off$ = 8						; size = 4
tv775 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN21@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN22@insert
$LN21@insert:
	mov	eax, esi
$LN22@insert:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN35@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN36@insert
$LN35@insert:
	mov	edx, esi
$LN36@insert:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN58@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN59@insert
$LN58@insert:
	mov	eax, esi
$LN59@insert:

; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))
; 1253 : 			return (insert(_Off, *this,

	push	DWORD PTR __Count$[ebp]
	sub	ebx, eax
	mov	ecx, esi
	push	ebx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@insert:

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN63@insert

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN265@insert:
$LN63@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);
; 1256 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, ecx
	not	eax
	cmp	eax, edx
	ja	SHORT $LN3@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN266@insert:
$LN3@insert:
	push	edi

; 1257 : 			_Xlen();	// result too long
; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+edx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

	test	edx, edx
	je	$LN258@insert

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN99@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN267@insert:
$LN99@insert:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN100@insert

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	edx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1259 : 		if (0 < _Count && _Grow(_Num))

	je	$LN258@insert
$LN263@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN203@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv775[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN204@insert
$LN100@insert:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN263@insert

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN177@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN177@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN203@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv775[ebp], esi
$LN204@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN217@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv774[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN218@insert
$LN217@insert:
	mov	DWORD PTR tv774[ebp], esi
$LN218@insert:

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN224@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv775[ebp]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv774[ebp]
	add	eax, ecx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	mov	ecx, DWORD PTR __Off$[ebp]
	add	esp, 12					; 0000000cH
$LN224@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN235@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN236@insert
$LN235@insert:
	mov	edx, esi
$LN236@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	je	SHORT $LN242@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN242@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN253@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN253@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN258@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN264@insert:
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv859 = 8						; size = 4
tv856 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv848 = 16						; size = 4
__Roff$ = 16						; size = 4
tv861 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN10@insert

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN286@insert:
$LN10@insert:

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Roff$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, edx
	jae	SHORT $LN26@insert

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN287@insert:
$LN26@insert:

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, edx
	cmp	edi, eax
	cmova	edi, eax

; 1224 : 		_Check_offset(_Off);
; 1225 : 		_Right._Check_offset(_Roff);
; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1227 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
	cmp	eax, edi
	ja	SHORT $LN2@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN288@insert:
$LN2@insert:

; 1228 : 			_Xlen();	// result too long
; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

	test	edi, edi
	je	$LN279@insert

; 2225 : 		if (max_size() < _Newsize)

	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN74@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN289@insert:
$LN74@insert:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], ebx
	jae	SHORT $LN75@insert

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	ebx, ebx

; 1231 : 		if (0 < _Count && _Grow(_Num))

	je	$LN279@insert
$LN283@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN178@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv861[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN179@insert
$LN75@insert:

; 2232 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN283@insert

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN152@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN152@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN178@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv861[ebp], esi
$LN179@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN192@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN193@insert
$LN192@insert:
	mov	ecx, esi
$LN193@insert:

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Off$[ebp]
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN199@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv861[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ecx+edx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	mov	edx, DWORD PTR __Off$[ebp]
	add	esp, 12					; 0000000cH
$LN199@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1236 : 			if (this == &_Right)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	esi, eax
	jne	SHORT $LN4@insert
	mov	eax, DWORD PTR __Roff$[ebp]
	cmp	edx, eax
	lea	ecx, DWORD PTR [eax+edi]
	cmovae	ecx, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR tv848[ebp], ecx
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN210@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv859[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN211@insert
$LN210@insert:
	mov	DWORD PTR tv859[ebp], esi
$LN211@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN224@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN225@insert
$LN224@insert:
	mov	ecx, esi
$LN225@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN263@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv848[ebp]
	add	eax, DWORD PTR tv859[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [ecx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1240 : 			else

	jmp	SHORT $LN284@insert
$LN4@insert:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN242@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN242@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN256@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv856[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN257@insert
$LN256@insert:
	mov	DWORD PTR tv856[ebp], esi
$LN257@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN263@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

	add	eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv856[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memcpy
$LN284@insert:
	add	esp, 12					; 0000000cH
$LN263@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN274@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN274@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
$LN279@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN285@insert:
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@assign
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@assign:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@assign
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN21@assign
$LN20@assign:
	mov	eax, esi
$LN21@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN34@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN35@assign
$LN34@assign:
	mov	edx, esi
$LN35@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN57@assign

; 1168 : 			return (assign(*this,

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1168 : 			return (assign(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN57@assign:

; 1168 : 			return (assign(*this,

	push	DWORD PTR __Count$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1168 : 			return (assign(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 2225 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN62@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN188@assign:
$LN62@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN63@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

	je	SHORT $LN181@assign
$LN186@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN158@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN159@assign
$LN63@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN186@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN140@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN140@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1177 : 		}

	pop	ebp
	ret	8
$LN158@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
$LN159@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN165@assign
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN165@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN176@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN176@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN181@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN187@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jae	SHORT $LN7@assign

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN209@assign:
$LN7@assign:

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, ecx
	cmp	edi, eax
	cmova	edi, eax

; 1150 : 		_Right._Check_offset(_Roff);
; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1152 : 
; 1153 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	lea	eax, DWORD PTR [ecx+edi]

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], eax
	jae	SHORT $LN38@assign

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN210@assign:
$LN38@assign:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN63@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN63@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN71@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN211@assign:
$LN71@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN72@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1155 : 		else if (_Grow(_Count))

	je	SHORT $LN203@assign
$LN207@assign:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN166@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN166@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN180@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN181@assign
$LN72@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN207@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN149@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN149@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN180@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN181@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN187@assign
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1157 : 			_Traits::copy(this->_Myptr(),

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN187@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN198@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN198@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN203@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN208@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ebx

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, ebx
	ja	SHORT $LN2@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN142@append:
$LN2@append:

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+ebx]

; 1116 : 		if (0 < _Count && _Grow(_Num))

	test	ebx, ebx
	je	SHORT $LN136@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN143@append:
$LN27@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN28@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN136@append
$LN140@append:

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, esi
	push	ebx
	push	DWORD PTR [esi+16]
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN131@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN28@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN140@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN105@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN105@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1122 : 		}

	pop	ebp
	ret	8
$LN131@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN136@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN141@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@append
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1108 : 		}

	pop	ebp
	ret	4
$LN5@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@append:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@append
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1108 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN21@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN22@append
$LN21@append:
	mov	eax, esi
$LN22@append:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN35@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN36@append
$LN35@append:
	mov	edx, esi
$LN36@append:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN58@append

; 1090 : 			return (append(*this,

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1090 : 			return (append(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN58@append:

; 1090 : 			return (append(*this,

	push	DWORD PTR __Count$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1090 : 			return (append(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR [esi+16]
	mov	eax, edx
	mov	ecx, DWORD PTR __Count$[ebp]
	not	eax
	cmp	eax, ecx
	ja	SHORT $LN3@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN218@append:
$LN3@append:
	push	edi

; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

	test	ecx, ecx
	je	$LN211@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN84@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN219@append:
$LN84@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN85@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1096 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN211@append
$LN216@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN179@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN180@append
$LN85@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN216@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN162@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN162@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1102 : 		}

	pop	ebp
	ret	8
$LN179@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN180@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	ecx, ecx
	je	SHORT $LN195@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN195@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN206@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN206@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN211@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN217@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jae	SHORT $LN6@append

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN202@append:
$LN6@append:

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR [esi+16]

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	sub	eax, ecx

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, eax
	cmova	ecx, eax

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, edx
	not	eax

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	DWORD PTR __Count$[ebp], ecx

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	cmp	eax, ecx
	ja	SHORT $LN2@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN203@append:
$LN2@append:

; 1074 : 			_Xlen();	// result too long
; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

	test	ecx, ecx
	je	$LN196@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN55@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN204@append:
$LN55@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN56@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1077 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN196@append
$LN200@append:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN150@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN150@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN164@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN165@append
$LN56@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN200@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN133@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN133@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN164@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN165@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	ecx, ecx
	je	SHORT $LN180@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ecx
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN180@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN191@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN191@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN196@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN201@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1066 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1059 : 		{	// append 1 * _Ch

	push	ebp
	mov	ebp, esp

; 1060 : 		return (append((size_type)1, _Ch));

	push	DWORD PTR __Ch$[ebp]
	push	1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1061 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1054 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN7@operator
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1055 : 		return (append(_Ptr));
; 1056 : 		}

	pop	ebp
	ret	4
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL9@operator:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL9@operator
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1055 : 		return (append(_Ptr));
; 1056 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1049 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1050 : 		return (append(_Right));
; 1051 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN7@operator
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1040 : 		return (assign(_Ptr));
; 1041 : 		}

	pop	ebp
	ret	4
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL9@operator:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL9@operator
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1040 : 		return (assign(_Ptr));
; 1041 : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 1024 : 		if (this != &_Right)

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN136@operator

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN136@operator:

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);
; 1034 : 			}
; 1035 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1036 : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN6@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN6@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN98@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
$LN98@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 961  : 		{	// assign by moving _Right

	mov	edi, ecx

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN3@Assign_rv
	push	eax
	push	esi
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN3@Assign_rv
$LN2@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN84@Assign_rv
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
$LN84@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN231@Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	pop	ebp
	ret	4
$LN231@Assign_rv:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	pop	ebp
	ret	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	esi, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPBD0Urandom_access_iterator_tag@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPBD0Urandom_access_iterator_tag@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct, COMDAT
; _this$ = ecx

; 904  : 		{	// initialize from [_First, _Last), const pointers

	push	ebp
	mov	ebp, esp

; 905  : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	cmp	edx, eax
	je	SHORT $LN2@Construct

; 906  : 			assign(_First, _Last - _First);

	sub	eax, edx
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Construct:

; 907  : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPBD0Urandom_access_iterator_tag@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	ecx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN115@basic_stri
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN115@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, ecx
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL117@basic_stri:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL117@basic_stri
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 796  : 		}

	mov	eax, ecx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 796  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 735  : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 730  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 725  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

	mov	eax, ecx

; 715  : 		}

	ret	0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 708  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 703  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 698  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 693  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

	ret	4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 590  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 590  : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 583  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 584  : 		}

	ret	0
$LN11@Myptr:

; 583  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 584  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 579  : 		}

	ret	0
$LN11@Myptr:

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 579  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 499  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate
$LN15@allocate:

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN10@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN11@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN11@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN15@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN17@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 875  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	or	eax, -1

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 750  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@allocate:
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN3@Getcont

; 185  : 		}

	ret	0
$LN3@Getcont:

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 185  : 		}

	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 149  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Parent$[ebp]
	test	eax, eax
	je	SHORT $LN3@Adopt

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@Adopt:

; 173  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 174  : 			}
; 175  : 		}

	pop	ebp
	ret	4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 142  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 143  : 		_Lockit _Lock(_LOCK_DEBUG);
; 144  : 		_Orphan_me();
; 145  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 146  : 		}

	ret	0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 124  : 		{	// assign an iterator

	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN12@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

	test	eax, eax
	je	SHORT $LN12@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN12@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN12@operator:

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 
; 137  : 		return (*this);

	mov	eax, ecx

; 138  : 		}

	pop	ebp
	ret	4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 119  : 		{	// copy an iterator

	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Right$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN15@Iterator_b

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN15@Iterator_b

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN15@Iterator_b:

; 120  : 		*this = _Right;
; 121  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0

; 115  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 216  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 217  : 	if (_Myproxy != 0)
; 218  : 		{	// proxy allocated, drain it
; 219  : 		_Lockit _Lock(_LOCK_DEBUG);
; 220  : 
; 221  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 222  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 223  : 			(*_Pnext)->_Myproxy = 0;
; 224  : 		_Myproxy->_Myfirstiter = 0;
; 225  : 		}
; 226  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 227  : 	}

	ret	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 95   : 		_Orphan_all();
; 96   : 		}

	ret	0
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 81   : 		}

	mov	eax, ecx
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 67   : 		: _Mycont(0), _Myfirstiter(0)

	mov	DWORD PTR [ecx], 0

; 69   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

	or	eax, -1

; 607  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 594  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 595  : 		return (_Left == _Right);
; 596  : 		}

	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 588  : 		{	// convert character to metacharacter

	push	ebp
	mov	ebp, esp

; 589  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, BYTE PTR [eax]

; 590  : 		}

	pop	ebp
	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 582  : 		{	// convert metacharacter to character

	push	ebp
	mov	ebp, esp

; 583  : 		return ((_Elem)_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	al, BYTE PTR [eax]

; 584  : 		}

	pop	ebp
	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 565  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 566  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR __Count$[ebp]
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	push	DWORD PTR __First$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 561  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	pop	ebp
	ret	0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

	mov	DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	pop	ebp

; 553  : 		return (_Count == 0 ? _First1

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp
	ret	0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

	mov	DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp

; 530  : 		return (_Count == 0 ? _First1

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 523  : 		return (*_First == 0 ? 0

	mov	eax, DWORD PTR __First$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	pop	ebp
	ret	0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

	lea	edx, DWORD PTR [eax+1]
$LL5@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@length
	sub	eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

	push	ebp
	mov	ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 90   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
	test	ecx, ecx
	cmovne	eax, ecx

; 90   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 85   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 68   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 53   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __InitData$[ebp], eax
	lea	edx, DWORD PTR [esi+4]
	mov	BYTE PTR __InitData$[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

	push	edx
	lea	eax, DWORD PTR __InitData$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 56   :     }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2261 : {

	push	ebp
	mov	ebp, esp

; 2167 :     return __stdio_common_vsscanf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_scanf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2262 :     int _Result;
; 2263 :     va_list _ArgList;
; 2264 :     __crt_va_start(_ArgList, _Format);
; 2265 :     _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2266 :     __crt_va_end(_ArgList);
; 2267 :     return _Result;
; 2268 : }

	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2166 : {

	push	ebp
	mov	ebp, esp

; 2167 :     return __stdio_common_vsscanf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_scanf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2168 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2169 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2170 : }

	pop	ebp
	ret	0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1391 : }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ??0Features@Json@@QAE@XZ
_TEXT	SEGMENT
??0Features@Json@@QAE@XZ PROC				; Json::Features::Features, COMDAT
; _this$ = ecx

; 20   :    : allowComments_( true )

	mov	WORD PTR [ecx], 1

; 23   : }

	mov	eax, ecx
	ret	0
??0Features@Json@@QAE@XZ ENDP				; Json::Features::Features
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?strictMode@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?strictMode@Features@Json@@SA?AV12@XZ PROC		; Json::Features::strictMode, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp

; 36   :    Features features;
; 37   :    features.allowComments_ = false;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	WORD PTR [eax], 256			; 00000100H

; 38   :    features.strictRoot_ = true;
; 39   :    return features;
; 40   : }

	pop	ebp
	ret	0
?strictMode@Features@Json@@SA?AV12@XZ ENDP		; Json::Features::strictMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?all@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?all@Features@Json@@SA?AV12@XZ PROC			; Json::Features::all, COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 20   :    : allowComments_( true )

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	WORD PTR [eax], 1

; 29   :    return Features();
; 30   : }

	pop	ebp
	ret	0
?all@Features@Json@@SA?AV12@XZ ENDP			; Json::Features::all
_TEXT	ENDS
END
