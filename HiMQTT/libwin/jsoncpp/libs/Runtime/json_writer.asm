; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\lonycell\Downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT

PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf_s
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?hex@std@@YAAAVios_base@1@AAV21@@Z		; std::hex
PUBLIC	?uppercase@std@@YAAAVios_base@1@AAV21@@Z	; std::uppercase
PUBLIC	??1Writer@Json@@UAE@XZ				; Json::Writer::~Writer
PUBLIC	??_GWriter@Json@@UAEPAXI@Z			; Json::Writer::`scalar deleting destructor'
PUBLIC	??0FastWriter@Json@@QAE@XZ			; Json::FastWriter::FastWriter
PUBLIC	??1FastWriter@Json@@UAE@XZ			; Json::FastWriter::~FastWriter
PUBLIC	?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ ; Json::FastWriter::enableYAMLCompatibility
PUBLIC	?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::FastWriter::write
PUBLIC	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z	; Json::FastWriter::writeValue
PUBLIC	??_GFastWriter@Json@@UAEPAXI@Z			; Json::FastWriter::`scalar deleting destructor'
PUBLIC	??0StyledWriter@Json@@QAE@XZ			; Json::StyledWriter::StyledWriter
PUBLIC	??1StyledWriter@Json@@UAE@XZ			; Json::StyledWriter::~StyledWriter
PUBLIC	?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::StyledWriter::write
PUBLIC	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
PUBLIC	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue
PUBLIC	?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::isMultineArray
PUBLIC	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
PUBLIC	?writeIndent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::writeIndent
PUBLIC	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
PUBLIC	?indent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::indent
PUBLIC	?unindent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::unindent
PUBLIC	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
PUBLIC	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
PUBLIC	?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::hasCommentForValue
PUBLIC	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
PUBLIC	?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
PUBLIC	??_GStyledWriter@Json@@UAEPAXI@Z		; Json::StyledWriter::`scalar deleting destructor'
PUBLIC	??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::StyledStreamWriter
PUBLIC	??1StyledStreamWriter@Json@@QAE@XZ		; Json::StyledStreamWriter::~StyledStreamWriter
PUBLIC	?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z ; Json::StyledStreamWriter::write
PUBLIC	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
PUBLIC	?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeArrayValue
PUBLIC	?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::isMultineArray
PUBLIC	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
PUBLIC	?writeIndent@StyledStreamWriter@Json@@AAEXXZ	; Json::StyledStreamWriter::writeIndent
PUBLIC	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
PUBLIC	?indent@StyledStreamWriter@Json@@AAEXXZ		; Json::StyledStreamWriter::indent
PUBLIC	?unindent@StyledStreamWriter@Json@@AAEXXZ	; Json::StyledStreamWriter::unindent
PUBLIC	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue
PUBLIC	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine
PUBLIC	?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::hasCommentForValue
PUBLIC	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
PUBLIC	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
PUBLIC	??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z ; Json::operator<<
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_7Writer@Json@@6B@				; Json::Writer::`vftable'
PUBLIC	??_7FastWriter@Json@@6B@			; Json::FastWriter::`vftable'
PUBLIC	??_7StyledWriter@Json@@6B@			; Json::StyledWriter::`vftable'
PUBLIC	??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@		; `string'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@	; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_02MCKKLHBJ@?2?$CC?$AA@			; `string'
PUBLIC	??_C@_02HDBGODGB@?2?2?$AA@			; `string'
PUBLIC	??_C@_02DCNDPIBM@?2b?$AA@			; `string'
PUBLIC	??_C@_02FGLPDNBI@?2f?$AA@			; `string'
PUBLIC	??_C@_02JOGGLHBA@?2n?$AA@			; `string'
PUBLIC	??_C@_02HIBBOKEN@?2r?$AA@			; `string'
PUBLIC	??_C@_02COELENML@?2t?$AA@			; `string'
PUBLIC	??_C@_02DHFAHMIK@?2u?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_04MLLLIHIP@null?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_02MCILKGOH@?$HL?$HN?$AA@			; `string'
PUBLIC	??_C@_03MCPBMLDJ@?5?3?5?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
PUBLIC	??_C@_02PFNDMDBO@?$FL?5?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_02DHOGEDBE@?5?$FN?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_01GPOEFGEJ@?7?$AA@			; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R4FastWriter@Json@@6B@			; Json::FastWriter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFastWriter@Json@@@8			; Json::FastWriter `RTTI Type Descriptor'
PUBLIC	??_R3FastWriter@Json@@8				; Json::FastWriter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FastWriter@Json@@8				; Json::FastWriter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FastWriter@Json@@8		; Json::FastWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Writer@Json@@8			; Json::Writer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVWriter@Json@@@8				; Json::Writer `RTTI Type Descriptor'
PUBLIC	??_R3Writer@Json@@8				; Json::Writer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Writer@Json@@8				; Json::Writer::`RTTI Base Class Array'
PUBLIC	??_R4StyledWriter@Json@@6B@			; Json::StyledWriter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVStyledWriter@Json@@@8			; Json::StyledWriter `RTTI Type Descriptor'
PUBLIC	??_R3StyledWriter@Json@@8			; Json::StyledWriter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StyledWriter@Json@@8			; Json::StyledWriter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@StyledWriter@Json@@8		; Json::StyledWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4Writer@Json@@6B@				; Json::Writer::`RTTI Complete Object Locator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__strpbrk:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	?type@Value@Json@@QBE?AW4ValueType@2@XZ:PROC	; Json::Value::type
EXTRN	?asCString@Value@Json@@QBEPBDXZ:PROC		; Json::Value::asCString
EXTRN	?asInt@Value@Json@@QBEHXZ:PROC			; Json::Value::asInt
EXTRN	?asUInt@Value@Json@@QBEIXZ:PROC			; Json::Value::asUInt
EXTRN	?asDouble@Value@Json@@QBENXZ:PROC		; Json::Value::asDouble
EXTRN	?asBool@Value@Json@@QBE_NXZ:PROC		; Json::Value::asBool
EXTRN	?isArray@Value@Json@@QBE_NXZ:PROC		; Json::Value::isArray
EXTRN	?isObject@Value@Json@@QBE_NXZ:PROC		; Json::Value::isObject
EXTRN	?size@Value@Json@@QBEIXZ:PROC			; Json::Value::size
EXTRN	??AValue@Json@@QBEABV01@I@Z:PROC		; Json::Value::operator[]
EXTRN	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Json::Value::operator[]
EXTRN	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ:PROC ; Json::Value::getMemberNames
EXTRN	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z:PROC ; Json::Value::hasComment
EXTRN	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z:PROC ; Json::Value::getComment
EXTRN	??_EWriter@Json@@UAEPAXI@Z:PROC			; Json::Writer::`vector deleting destructor'
EXTRN	??_EFastWriter@Json@@UAEPAXI@Z:PROC		; Json::FastWriter::`vector deleting destructor'
EXTRN	??_EStyledWriter@Json@@UAEPAXI@Z:PROC		; Json::StyledWriter::`vector deleting destructor'
EXTRN	__imp_?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z:PROC
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R4Writer@Json@@6B@
rdata$r	SEGMENT
??_R4Writer@Json@@6B@ DD 00H				; Json::Writer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWriter@Json@@@8
	DD	FLAT:??_R3Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allo'
	DB	'cator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	050H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@StyledWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StyledWriter@Json@@8 DD FLAT:??_R0?AVStyledWriter@Json@@@8 ; Json::StyledWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2StyledWriter@Json@@8
rdata$r	SEGMENT
??_R2StyledWriter@Json@@8 DD FLAT:??_R1A@?0A@EA@StyledWriter@Json@@8 ; Json::StyledWriter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3StyledWriter@Json@@8
rdata$r	SEGMENT
??_R3StyledWriter@Json@@8 DD 00H			; Json::StyledWriter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVStyledWriter@Json@@@8
data$r	SEGMENT
??_R0?AVStyledWriter@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::StyledWriter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVStyledWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R4StyledWriter@Json@@6B@
rdata$r	SEGMENT
??_R4StyledWriter@Json@@6B@ DD 00H			; Json::StyledWriter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVStyledWriter@Json@@@8
	DD	FLAT:??_R3StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2Writer@Json@@8
rdata$r	SEGMENT
??_R2Writer@Json@@8 DD FLAT:??_R1A@?0A@EA@Writer@Json@@8 ; Json::Writer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Writer@Json@@8
rdata$r	SEGMENT
??_R3Writer@Json@@8 DD 00H				; Json::Writer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWriter@Json@@@8
data$r	SEGMENT
??_R0?AVWriter@Json@@@8 DD FLAT:??_7type_info@@6B@	; Json::Writer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Writer@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Writer@Json@@8 DD FLAT:??_R0?AVWriter@Json@@@8 ; Json::Writer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@FastWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FastWriter@Json@@8 DD FLAT:??_R0?AVFastWriter@Json@@@8 ; Json::FastWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FastWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2FastWriter@Json@@8
rdata$r	SEGMENT
??_R2FastWriter@Json@@8 DD FLAT:??_R1A@?0A@EA@FastWriter@Json@@8 ; Json::FastWriter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3FastWriter@Json@@8
rdata$r	SEGMENT
??_R3FastWriter@Json@@8 DD 00H				; Json::FastWriter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FastWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFastWriter@Json@@@8
data$r	SEGMENT
??_R0?AVFastWriter@Json@@@8 DD FLAT:??_7type_info@@6B@	; Json::FastWriter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFastWriter@Json@@', 00H
data$r	ENDS
;	COMDAT ??_R4FastWriter@Json@@6B@
rdata$r	SEGMENT
??_R4FastWriter@Json@@6B@ DD 00H			; Json::FastWriter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFastWriter@Json@@@8
	DD	FLAT:??_R3FastWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7?$AA@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7?$AA@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHOGEDBE@?5?$FN?$AA@
CONST	SEGMENT
??_C@_02DHOGEDBE@?5?$FN?$AA@ DB ' ]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFNDMDBO@?$FL?5?$AA@
CONST	SEGMENT
??_C@_02PFNDMDBO@?$FL?5?$AA@ DB '[ ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCPBMLDJ@?5?3?5?$AA@
CONST	SEGMENT
??_C@_03MCPBMLDJ@?5?3?5?$AA@ DB ' : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCILKGOH@?$HL?$HN?$AA@
CONST	SEGMENT
??_C@_02MCILKGOH@?$HL?$HN?$AA@ DB '{}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null?$AA@
CONST	SEGMENT
??_C@_04MLLLIHIP@null?$AA@ DB 'null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHFAHMIK@?2u?$AA@
CONST	SEGMENT
??_C@_02DHFAHMIK@?2u?$AA@ DB '\u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02COELENML@?2t?$AA@
CONST	SEGMENT
??_C@_02COELENML@?2t?$AA@ DB '\t', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBBOKEN@?2r?$AA@
CONST	SEGMENT
??_C@_02HIBBOKEN@?2r?$AA@ DB '\r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOGGLHBA@?2n?$AA@
CONST	SEGMENT
??_C@_02JOGGLHBA@?2n?$AA@ DB '\n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLPDNBI@?2f?$AA@
CONST	SEGMENT
??_C@_02FGLPDNBI@?2f?$AA@ DB '\f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCNDPIBM@?2b?$AA@
CONST	SEGMENT
??_C@_02DCNDPIBM@?2b?$AA@ DB '\b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBGODGB@?2?2?$AA@
CONST	SEGMENT
??_C@_02HDBGODGB@?2?2?$AA@ DB '\\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCKKLHBJ@?2?$CC?$AA@
CONST	SEGMENT
??_C@_02MCKKLHBJ@?2?$CC?$AA@ DB '\"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
CONST	SEGMENT
??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@ DB '"\', 08H, 0cH, 0aH, 0dH, 09H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	050H
CONST	ENDS
;	COMDAT ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@
CONST	SEGMENT
??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@ DB '%#.16g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7StyledWriter@Json@@6B@
CONST	SEGMENT
??_7StyledWriter@Json@@6B@ DD FLAT:??_R4StyledWriter@Json@@6B@ ; Json::StyledWriter::`vftable'
	DD	FLAT:??_EStyledWriter@Json@@UAEPAXI@Z
	DD	FLAT:?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
CONST	ENDS
;	COMDAT ??_7FastWriter@Json@@6B@
CONST	SEGMENT
??_7FastWriter@Json@@6B@ DD FLAT:??_R4FastWriter@Json@@6B@ ; Json::FastWriter::`vftable'
	DD	FLAT:??_EFastWriter@Json@@UAEPAXI@Z
	DD	FLAT:?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
CONST	ENDS
;	COMDAT ??_7Writer@Json@@6B@
CONST	SEGMENT
??_7Writer@Json@@6B@ DD FLAT:??_R4Writer@Json@@6B@	; Json::Writer::`vftable'
	DD	FLAT:??_EWriter@Json@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z$0
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z$0
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z$1
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z$1
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z$2
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z$2
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$17 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$17
__ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$15
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$12
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$10
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3
__ehfuncinfo$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z$1
__ehfuncinfo$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$99
	DD	03H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$100
	DD	04H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$102
	DD	02H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$4
	DD	06H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0
__ehfuncinfo$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
__ehfuncinfo$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
__ehfuncinfo$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
__ehfuncinfo$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$53 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$53
__ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$88
__ehfuncinfo$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0
__ehfuncinfo$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
__ehfuncinfo$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?indent@StyledWriter@Json@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?indent@StyledWriter@Json@@AAEXXZ$0
__ehfuncinfo$?indent@StyledWriter@Json@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?indent@StyledWriter@Json@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2
__ehfuncinfo$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
	sub	ecx, DWORD PTR [ecx-4]
	jmp	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	pop	ebp
	ret	8
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	pop	ebp
	ret	0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN13@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN105@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
$LN105@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	pop	ebp
	ret	8
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 863  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN15@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN15@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN107@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	pop	ebp
	ret	0
$LN107@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	pop	ebp
	ret	0
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	mov	eax, ecx
	ret	4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	push	ebx

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	ebx, DWORD PTR __Last$[ebp]
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	cmp	esi, ebx
	je	$LN407@Uninitiali
	push	edi
	mov	edi, DWORD PTR __Dest$[ebp]
	add	esi, 20					; 00000014H
	npad	6
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN2@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	cmp	DWORD PTR [esi], 16			; 00000010H
	jae	SHORT $LN165@Uninitiali

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR [esi-4]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN166@Uninitiali
	push	eax
	lea	eax, DWORD PTR [esi-20]
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN166@Uninitiali
$LN165@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi-20]
	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	DWORD PTR [esi-20], 0
$LN166@Uninitiali:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi-4]
	mov	DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+20], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi-4], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN394@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi-20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN395@Uninitiali
$LN394@Uninitiali:
	lea	eax, DWORD PTR [esi-20]
$LN395@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	esi, 24					; 00000018H
	add	edi, 24					; 00000018H
	lea	ecx, DWORD PTR [esi-20]
	cmp	ecx, ebx
	jne	SHORT $LL4@Uninitiali

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 285  : 	}

	pop	ebp
	ret	0
$LN407@Uninitiali:

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	pop	esi
	pop	ebx

; 285  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_move_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Ptr_move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 810  : 	return {};

	xor	al, al

; 811  : 	}

	ret	0
??$_Ptr_move_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN17@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN17@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN109@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
$LN109@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@PAV10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@PAV10@@Z PROC ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 458  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@PAV10@@Z ENDP ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z PROC ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 428  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 429  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ENDP ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1099 : 	{	// destroy [_First, _Last), no special optimization

	push	ebp
	mov	ebp, esp
	push	esi

; 1100 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	cmp	esi, edi
	je	SHORT $LN149@Destroy_ra
	add	esi, 20					; 00000014H
$LL4@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN104@Destroy_ra
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi-20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN99@Destroy_ra

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	SHORT $LN145@Destroy_ra

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	SHORT $LN145@Destroy_ra

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	SHORT $LN145@Destroy_ra

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	SHORT $LN145@Destroy_ra

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN99@Destroy_ra:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN104@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi-4], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN127@Destroy_ra
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi-20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN128@Destroy_ra
$LN127@Destroy_ra:
	lea	eax, DWORD PTR [esi-20]
$LN128@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	add	esi, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	lea	eax, DWORD PTR [esi-20]
	cmp	eax, edi
	jne	SHORT $LL4@Destroy_ra
$LN149@Destroy_ra:
	pop	edi
	pop	esi

; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	pop	ebp
	ret	0
$LN145@Destroy_ra:

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN152@Destroy_ra:
$LN151@Destroy_ra:
	int	3
??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN8@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z$1:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN8@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z$1:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 16					; 00000010H

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Ptr$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 143  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 99   : 			: _Myostr(_Ostr)

	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [edi], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN6@sentry

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@sentry:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+esi+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN2@sentry
	mov	ecx, DWORD PTR [eax+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN2@sentry:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 127  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 99   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi

; 100  : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+12]
	adc	edx, DWORD PTR [ecx+4]

; 69   : 		}

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with stream offset

	push	ebp
	mov	ebp, esp

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	eax, DWORD PTR __Off$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Off$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 44   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	movq	QWORD PTR [ecx+16], xmm0
	pop	ebp
	ret	8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 598  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 598  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z$2:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR _<_Args_0>$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z$2:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z PROC ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	0
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ENDP ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 8
$T3 = -36						; size = 8
__Ok$ = -36						; size = 8
$T4 = -28						; size = 1
__State$ = -24						; size = 4
__Size$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
$T5 = 12						; size = 1
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 170  : 	{	// insert a string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 175  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	ebx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 175  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	edx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	DWORD PTR __Size$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+ebx+36]
	mov	esi, DWORD PTR [ecx+ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

	test	eax, eax
	jl	SHORT $LN17@operator
	jg	SHORT $LN135@operator
	test	esi, esi
	je	SHORT $LN17@operator
$LN135@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	DWORD PTR $T3[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

	cmp	esi, edx
	jbe	SHORT $LN17@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	DWORD PTR $T2[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

	sub	esi, edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	esi, esi
$LN18@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 99   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], ebx

; 100  : 			{	// lock the stream buffer, if there
; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN47@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN47@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ebx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN43@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [eax+ebx+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN43@operator
	cmp	ecx, ebx
	je	SHORT $LN43@operator

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN43@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+ebx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 179  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 180  : 
; 181  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 182  : 		_State |= ios_base::badbit;

	mov	edi, 4

; 183  : 	else

	jmp	$LN22@operator
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+ebx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 186  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	eax, 64					; 00000040H
	je	SHORT $LN132@operator
	npad	1
$LL4@operator:

; 187  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	esi, esi
	je	SHORT $LN3@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T4[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN2@operator

; 189  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 190  : 					{	// insertion failed, quit
; 191  : 					_State |= ios_base::badbit;

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi

; 192  : 					break;

	jmp	SHORT $LL137@operator
$LN2@operator:

; 187  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	dec	esi
	jmp	SHORT $LL4@operator
$LN3@operator:
	test	edi, edi

; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

	jne	SHORT $LL137@operator
$LN132@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR __Str$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN95@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN95@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

	push	0
	push	DWORD PTR __Size$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

	push	ecx
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Size$1$[ebp]
	jne	SHORT $LN136@operator
	test	edx, edx
	jne	SHORT $LN136@operator
$LL137@operator:

; 199  : 		else
; 200  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	esi, esi
	je	SHORT $LN6@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T5[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN5@operator

; 202  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 203  : 					{	// insertion failed, quit
; 204  : 					_State |= ios_base::badbit;

	or	edi, 4

; 205  : 					break;

	jmp	SHORT $LN6@operator
$LN5@operator:

; 199  : 		else
; 200  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	dec	esi
	jmp	SHORT $LL137@operator
$LN136@operator:

; 197  : 				!= (streamsize)_Size)
; 198  : 				_State |= ios_base::badbit;

	mov	edi, 4
$LN6@operator:

; 206  : 					}
; 207  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
	jmp	SHORT $LN142@operator
__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 208  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN142@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 209  : 		}
; 210  : 
; 211  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	edi
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 130  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 133  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN113@operator
	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN113@operator:

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+esi+56]
	test	ecx, ecx
	je	SHORT $LN138@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN138@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 212  : 	return (_Ostr);

	mov	eax, ebx

; 213  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$7:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$15:
	call	___std_terminate
	ret	0
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$16:
	call	___std_terminate
	ret	0
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2417 : 	{	// return NTCS + string

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR __Left$[ebp]
	push	esi
	mov	DWORD PTR $T1[ebp], 0
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN9@operator
	xor	eax, eax
	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	eax, edx
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL143@operator:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL143@operator
	sub	eax, esi
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR __Right$[ebp]
	push	eax
	push	edx
	push	0
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	push	eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 2418 : 	return (_STD move(_Right.insert(0, _Left)));

	mov	eax, esi
	pop	esi

; 2419 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++, COMDAT
; _this$ = ecx

; 113  : 		++_Ptr;

	add	DWORD PTR [ecx], 24			; 00000018H

; 341  : 		++*(_Mybase *)this;
; 342  : 		return (*this);

	mov	eax, ecx

; 343  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*, COMDAT
; _this$ = ecx

; 331  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 332  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 314  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Compat, COMDAT
; _this$ = ecx

; 262  : 		}

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 219  : 		return (!(*this == _Right));
; 220  : 		}

	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 213  : 		_Compat(_Right);
; 214  : 		return (_Ptr == _Right._Ptr);
; 215  : 		}

	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)
; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 103  : 			_SCL_SECURE_OUT_OF_RANGE;
; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

	add	DWORD PTR [ecx], 24			; 00000018H

; 114  : 		return (*this);

	mov	eax, ecx

; 115  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)
; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 74   : 			_SCL_SECURE_OUT_OF_RANGE;
; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
;	COMDAT ??$?6DU?$char_traits@D@std@@_J@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@_J@0@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
__Manip$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@_J@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@_J@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,__int64>, COMDAT

; 526  : 	{	// insert by calling function with output stream and argument

	push	ebp
	mov	ebp, esp
	push	esi

; 527  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	esi, DWORD PTR __Ostr$[ebp]
	test	esi, esi
	jne	SHORT $LN3@operator
	xor	eax, eax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	add	eax, esi
$LN4@operator:
	mov	ecx, DWORD PTR __Manip$[ebp]
	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	ecx
	add	esp, 12					; 0000000cH

; 528  : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 529  : 	}

	pop	ebp
	ret	0
??$?6DU?$char_traits@D@std@@_J@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@_J@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
;	COMDAT ??$?6DU?$char_traits@D@std@@D@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
__Manip$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@D@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,char>, COMDAT

; 58   : 	{	// set fill character in output stream

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 119  : 		_Fillch = _Newfill;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Manip$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx+eax+64], cl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip

; 64   : 	}

	pop	ebp
	ret	0
??$?6DU?$char_traits@D@std@@D@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
;	COMDAT ??0?$_Fillobj@D@std@@QAE@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??0?$_Fillobj@D@std@@QAE@D@Z PROC			; std::_Fillobj<char>::_Fillobj<char>, COMDAT
; _this$ = ecx

; 25   : 		{	// construct from fill character

	push	ebp
	mov	ebp, esp

; 24   : 		: _Fill(_Ch)

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx], al

; 26   : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Fillobj@D@std@@QAE@D@Z ENDP			; std::_Fillobj<char>::_Fillobj<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
;	COMDAT ??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ch$ = 12						; size = 1
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z PROC		; std::setfill<char>, COMDAT

; 34   : 	{	// return a _Fillobj manipulator

	push	ebp
	mov	ebp, esp

; 24   : 		: _Fill(_Ch)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl

; 35   : 	return (_Fillobj<_Elem>(_Ch));
; 36   : 	}

	pop	ebp
	ret	0
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z ENDP		; std::setfill<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
__Ok$ = -36						; size = 8
__Pad$2 = -28						; size = 8
$T3 = -24						; size = 1
$T4 = -24						; size = 1
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 826  : 	{	// insert a char into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 99   : 			: _Myostr(_Ostr)

	mov	ecx, DWORD PTR __Ostr$[ebp]

; 827  : 	typedef char _Elem;
; 828  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 829  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi

; 99   : 			: _Myostr(_Ostr)

	mov	edi, ecx

; 827  : 	typedef char _Elem;
; 828  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 829  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], esi

; 99   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	edx, edx
	je	SHORT $LN27@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+4]
	mov	ecx, edi
$LN27@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ecx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN23@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	eax, DWORD PTR [eax+ecx+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	eax, eax
	je	SHORT $LN23@operator
	cmp	eax, ecx
	je	SHORT $LN23@operator

; 125  : 				_Ostr.tie()->flush();

	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	ecx, DWORD PTR __Ostr$[ebp]
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	add	edx, ecx

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [edx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 830  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 831  : 
; 832  : 	if (_Ok)

	test	al, al
	je	$LN20@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	ebx, DWORD PTR [edx+36]
	mov	edi, DWORD PTR [edx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 834  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	test	ebx, ebx
	jg	SHORT $LN15@operator
	jl	SHORT $LN108@operator
	cmp	edi, 1
	ja	SHORT $LN15@operator
$LN108@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$2[ebp], xmm0
	mov	ebx, DWORD PTR __Pad$2[ebp+4]
	mov	edi, DWORD PTR __Pad$2[ebp]
	jmp	SHORT $LN16@operator
$LN15@operator:
	sub	edi, 1
	sbb	ebx, 0
$LN16@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [edx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 837  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	eax, 64					; 00000040H
	je	SHORT $LN106@operator
$LL4@operator:

; 838  : 			for (; _State == ios_base::goodbit && 0 < _Pad;

	test	esi, esi
	jne	$LN6@operator
	test	ebx, ebx
	jl	SHORT $LN106@operator
	jg	SHORT $LN109@operator
	test	edi, edi
	je	SHORT $LN106@operator
$LN109@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 840  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T4[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 840  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	mov	ecx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 840  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	eax, 4
	cmove	esi, eax
	add	edi, -1
	mov	DWORD PTR __State$[ebp], esi
	adc	ebx, -1
	jmp	SHORT $LL4@operator
$LN106@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 845  : 			&& _Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 845  : 			&& _Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [eax+ecx+56]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 845  : 			&& _Traits::eq_int_type(_Traits::eof(),

	test	al, al
	mov	eax, 4
	cmovne	esi, eax
$LN114@operator:
	mov	DWORD PTR __State$[ebp], esi

; 846  : 				_Ostr.rdbuf()->sputc(_Ch)))
; 847  : 			_State |= ios_base::badbit;
; 848  : 
; 849  : 		for (; _State == ios_base::goodbit && 0 < _Pad;

	test	esi, esi
	jne	SHORT $LN6@operator
	test	ebx, ebx
	jl	SHORT $LN6@operator
	jg	SHORT $LN110@operator
	test	edi, edi
	je	SHORT $LN6@operator
$LN110@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 851  : 			if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T3[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 851  : 			if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 851  : 			if (_Traits::eq_int_type(_Traits::eof(),

	mov	eax, 4
	cmove	esi, eax
	add	edi, -1
	adc	ebx, -1
	jmp	SHORT $LN114@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:

; 852  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 853  : 				_State |= ios_base::badbit;
; 854  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN21@operator
	ret	0
$LN21@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	esi, DWORD PTR __State$[ebp]
$LN6@operator:
	mov	edi, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN20@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 858  : 	_Ostr.setstate(_State);

	mov	ebx, DWORD PTR __Ostr$[ebp]
	push	0
	push	esi
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 858  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 130  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN86@operator

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, edi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN86@operator:

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+edi+56]
	test	ecx, ecx
	je	SHORT $LN111@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN111@operator:

; 859  : 	return (_Ostr);

	mov	eax, ebx

; 860  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$10:
	call	___std_terminate
	ret	0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$11:
	call	___std_terminate
	ret	0
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -36						; size = 8
__Pad$ = -36						; size = 8
__State$ = -28						; size = 4
$T2 = -24						; size = 1
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
$T3 = 12						; size = 1
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 780  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	eax, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 783  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [eax], bl
	jne	SHORT $LN26@operator
	xor	ecx, ecx
	jmp	SHORT $LN121@operator
$LN26@operator:
	mov	ecx, eax
	lea	edx, DWORD PTR [ecx+1]
$LL108@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL108@operator
	sub	ecx, edx
$LN121@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	edx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	DWORD PTR __Count$2$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+edx+36]
	mov	esi, DWORD PTR [eax+edx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN110@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN110@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN110@operator:
	sub	esi, ecx
	sbb	edi, ebx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+edx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 99   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], edx

; 100  : 			{	// lock the stream buffer, if there
; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN39@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Ostr$[ebp]
$LN39@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+edx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN35@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [eax+edx+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN35@operator
	cmp	ecx, edx
	je	SHORT $LN35@operator

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	edx, DWORD PTR __Ostr$[ebp]
$LN35@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+edx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 786  : 		? 0 : _Ostr.width() - _Count;
; 787  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 788  : 
; 789  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

	mov	ebx, 4

; 791  : 	else

	jmp	$LN22@operator
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+edx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	eax, 64					; 00000040H
	je	SHORT $LN105@operator
$LL4@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN111@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN111@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+edx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+edx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T2[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z

; 800  : 					break;

	mov	edx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN2@operator

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

	mov	ebx, 4

; 800  : 					break;

	jmp	SHORT $LN6@operator
$LN2@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL4@operator
$LN3@operator:
	test	ebx, ebx

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	jne	SHORT $LN6@operator
$LN105@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	0
	push	DWORD PTR __Count$2$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+edx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN112@operator
	test	edx, edx
	jne	SHORT $LN112@operator
	npad	7
$LL114@operator:

; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jl	SHORT $LN118@operator
	jg	SHORT $LN113@operator
	test	esi, esi
	je	SHORT $LN118@operator
$LN113@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T3[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN5@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

	or	ebx, 4

; 813  : 					break;

	jmp	SHORT $LN118@operator
$LN5@operator:

; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL114@operator
$LN112@operator:

; 805  : 			_State |= ios_base::badbit;

	mov	ebx, 4
$LN118@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
$LN6@operator:

; 814  : 					}
; 815  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+edx+32], 0
	mov	DWORD PTR [eax+edx+36], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
	jmp	SHORT $LN124@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 816  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	ebx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR __Ostr$[ebp]
$LN124@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 817  : 		}
; 818  : 
; 819  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [edx]
	push	0
	push	ebx
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 130  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 133  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN88@operator
	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN88@operator:

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+esi+56]
	test	ecx, ecx
	je	SHORT $LN115@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN115@operator:

; 820  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]

; 821  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$8:
	call	___std_terminate
	ret	0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9:
	call	___std_terminate
	ret	0
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+edi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR [edi-80]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-80]
	mov	DWORD PTR [ecx+edi-84], eax

; 76   : 		_Tidy();

	lea	ecx, DWORD PTR [edi-76]
	mov	DWORD PTR [edi-76], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	lea	ecx, DWORD PTR [edi-76]
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 537  : 		}

	lea	ecx, DWORD PTR [edi-72]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, edi
	pop	edi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [edi-80]
	lea	ebx, DWORD PTR [edi-80]

; 76   : 		_Tidy();

	lea	ecx, DWORD PTR [edi-76]

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+edi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-80]
	mov	DWORD PTR [edx+edi-84], eax

; 75   : 		{	// destroy the object

	mov	DWORD PTR [edi-76], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	lea	ecx, DWORD PTR [edi-76]
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 537  : 		}

	lea	ecx, DWORD PTR [edi-72]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, edi
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar
	push	152					; 00000098H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@scalar:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 75   : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	68					; 00000044H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$ = 8						; size = 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT
; _this$ = ecx

; 354  : 		{	// convert open mode to stream state bits

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR __Mode$[ebp]

; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))

	mov	eax, ebx
	lea	ecx, DWORD PTR [ebx*4]
	not	ecx
	and	ecx, 4
	mov	edx, ecx
	or	edx, 2
	and	al, 2

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

	mov	eax, ebx
	cmovne	edx, ecx
	mov	ecx, edx
	or	ecx, 8
	and	al, 8
	cmove	ecx, edx
	mov	eax, ecx
	or	eax, 16					; 00000010H

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

	and	bl, 4
	pop	ebx
	cmove	eax, ecx

; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}

	pop	ebp
	ret	4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

	push	esi
	mov	esi, ecx

; 338  : 		if (_Mystate & _Allocated)

	test	BYTE PTR [esi+60], 1
	je	SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [eax]
	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [eax]
	add	edx, DWORD PTR [ecx]
$LN5@Tidy:

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	mov	eax, DWORD PTR [eax]
	sub	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	edx
	push	eax
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], 0

; 254  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], 0

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], 0

; 294  : 		*_IPfirst = _First;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax], 0

; 295  : 		*_IPnext = _First;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR [esi+60], -2			; fffffffeH
	mov	DWORD PTR [esi+56], 0
	pop	esi

; 346  : 		}

	ret	0
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

	push	ebp
	mov	ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

	mov	eax, DWORD PTR __State$[ebp]
	push	ebx

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], eax
	test	ebx, ebx
	je	SHORT $LN2@Init
	and	eax, 6
	cmp	al, 6
	je	SHORT $LN2@Init

; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

	push	edi
	push	ebx
	lea	ecx, DWORD PTR [esi+64]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ebx
	push	DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 319  : 			_Seekhigh = _Pnew + _Count;

	lea	ecx, DWORD PTR [edi+ebx]

; 320  : 
; 321  : 			if (!(_Mystate & _Noread))

	test	BYTE PTR [esi+60], 4
	mov	DWORD PTR [esi+56], ecx
	jne	SHORT $LN3@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], edi

; 254  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], edi

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], ebx
$LN3@Init:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 324  : 			if (!(_Mystate & _Constant))

	mov	eax, DWORD PTR [esi+60]
	test	al, 2
	jne	SHORT $LN5@Init

; 326  : 				_Mysb::setp(_Pnew,

	test	al, 24					; 00000018H
	mov	edx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 301  : 		*_IPfirst = _First;

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 326  : 				_Mysb::setp(_Pnew,

	cmovne	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 303  : 		*_IPcount = (int)(_Last - _Next);

	mov	ecx, edi
	sub	ecx, edx
	add	ecx, ebx
	mov	DWORD PTR [eax], edi
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], ecx

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 329  : 				if (_Mysb::gptr() == 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], edi

; 254  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], 0

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edi
$LN5@Init:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 332  : 			_Mystate |= _Allocated;

	or	DWORD PTR [esi+60], 1
	pop	edi
$LN2@Init:
	pop	esi
	pop	ebx

; 333  : 			}
; 334  : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
tv214 = -12						; size = 4
tv198 = -8						; size = 4
tv196 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	ebx, DWORD PTR __Ptr$[ebp+12]
	push	esi
	mov	esi, DWORD PTR __Ptr$[ebp+8]
	add	esi, DWORD PTR __Ptr$[ebp]
	push	edi
	adc	ebx, DWORD PTR __Ptr$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [edi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN2@seekpos
	cmp	DWORD PTR [edi+56], eax
	jae	SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

	mov	eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR tv196[ebp], ecx
	mov	DWORD PTR tv198[ebp], eax
	cmp	esi, ecx
	jne	SHORT $LN55@seekpos
	cmp	ebx, eax
	je	$LN11@seekpos
$LN55@seekpos:

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

	mov	edx, DWORD PTR __Mode$[ebp]
	test	dl, 1
	je	SHORT $LN5@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv214[ebp], eax
	test	eax, eax
	je	SHORT $LN60@seekpos

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	ebx, ebx
	jl	SHORT $LN7@seekpos
	jg	SHORT $LN56@seekpos
	test	esi, esi
	jb	SHORT $LN7@seekpos
$LN56@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+56]
	sub	eax, ecx
	cdq
	cmp	ebx, edx
	jg	SHORT $LN64@seekpos
	jl	SHORT $LN57@seekpos
	cmp	esi, eax
	ja	SHORT $LN64@seekpos
$LN57@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [edi+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	ecx, DWORD PTR tv214[ebp]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 248  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [edi+28]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	BYTE PTR __Mode$[ebp], 2
	je	SHORT $LN11@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	edx, DWORD PTR [edi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	cmp	DWORD PTR [edx], 0
	je	SHORT $LN11@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [eax]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edi+28]

; 260  : 		return (*_IPnext + *_IPcount);

	add	ecx, DWORD PTR [edx]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [eax]

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	ecx, eax
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 292  : 			else

	jmp	SHORT $LN11@seekpos
$LN64@seekpos:
	mov	ecx, DWORD PTR tv196[ebp]
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

	mov	ebx, DWORD PTR tv198[ebp]
	jmp	SHORT $LN65@seekpos
$LN60@seekpos:
	mov	eax, DWORD PTR tv198[ebp]
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	dl, 2
	je	SHORT $LN10@seekpos
	mov	edx, DWORD PTR [edi+32]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN10@seekpos

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	ebx, ebx
	jl	SHORT $LN7@seekpos
	jg	SHORT $LN58@seekpos
	test	esi, esi
	jb	SHORT $LN7@seekpos
$LN58@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+56]
	sub	eax, ecx
	cdq
	cmp	ebx, edx
	jg	SHORT $LN64@seekpos
	jl	SHORT $LN59@seekpos
	cmp	esi, eax
	ja	SHORT $LN64@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

	mov	eax, DWORD PTR [edi+32]
	sub	ecx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	mov	eax, DWORD PTR [edi+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 289  : 		*_IPnext += _Off;

	mov	eax, DWORD PTR [edi+32]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 300  : 			else

	jmp	SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	ebx, eax
$LN65@seekpos:
	mov	esi, ecx
$LN11@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm0, xmm0
	pop	edi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
	pop	esi
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movq	QWORD PTR [eax+16], xmm0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 306  : 		}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv264 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
tv268 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	edx, DWORD PTR [ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN2@seekoff
	cmp	DWORD PTR [ebx+56], eax
	jae	SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

	mov	ecx, DWORD PTR __Which$[ebp]
	test	cl, 1
	je	$LN3@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ebx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR tv264[ebp], esi
	test	esi, esi
	je	$LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

	mov	eax, DWORD PTR __Way$[ebp]
	cmp	eax, 2
	jne	SHORT $LN5@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	eax, DWORD PTR [ebx+56]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	add	esi, eax
	adc	edi, edx

; 235  : 			else if (_Way == ios_base::cur

	jmp	SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

	cmp	eax, 1
	jne	SHORT $LN7@seekoff
	test	cl, 2
	jne	SHORT $LN74@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

	mov	eax, esi
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	add	esi, eax
	adc	edi, edx
	jmp	SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

	test	eax, eax
	je	SHORT $LN79@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

	mov	edi, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+4]
	jmp	SHORT $LN9@seekoff
$LN79@seekoff:
	mov	edi, DWORD PTR __Off$[ebp+4]
	mov	esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	edi, edi
	jl	$LN10@seekoff
	jg	SHORT $LN75@seekoff
	test	esi, esi
	jb	$LN10@seekoff
$LN75@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+56]
	sub	eax, ecx
	cdq
	cmp	edi, edx
	jg	$LN10@seekoff
	jl	SHORT $LN76@seekoff
	cmp	esi, eax
	ja	$LN10@seekoff
$LN76@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [ebx+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	ecx, DWORD PTR tv264[ebp]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 248  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [ebx+28]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	BYTE PTR __Which$[ebp], 2
	je	$LN22@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	edx, DWORD PTR [ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

	cmp	DWORD PTR [edx], 0
	je	$LN22@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ebx+28]

; 260  : 		return (*_IPnext + *_IPcount);

	add	ecx, DWORD PTR [edx]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [eax]

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	ecx, eax
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 248  : 			else

	jmp	$LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	cl, 2
	je	$LN13@seekoff
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR tv268[ebp], edx
	test	edx, edx
	je	SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

	mov	eax, DWORD PTR __Way$[ebp]
	cmp	eax, 2
	jne	SHORT $LN15@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	eax, DWORD PTR [ebx+56]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	add	esi, eax
	adc	edi, edx
	jmp	SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

	cmp	eax, 1
	jne	SHORT $LN17@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

	mov	eax, edx
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	add	esi, eax
	adc	edi, edx
	jmp	SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

	test	eax, eax
	je	SHORT $LN80@seekoff

; 258  : 				_Off = _BADOFF;

	mov	edi, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+4]
	jmp	SHORT $LN19@seekoff
$LN80@seekoff:
	mov	edi, DWORD PTR __Off$[ebp+4]
	mov	esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	edi, edi
	jl	SHORT $LN10@seekoff
	jg	SHORT $LN77@seekoff
	test	esi, esi
	jb	SHORT $LN10@seekoff
$LN77@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+56]
	sub	eax, ecx
	cdq
	cmp	edi, edx
	jg	SHORT $LN10@seekoff
	jl	SHORT $LN78@seekoff
	cmp	esi, eax
	ja	SHORT $LN10@seekoff
$LN78@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	mov	eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

	sub	ecx, DWORD PTR tv268[ebp]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 289  : 		*_IPnext += _Off;

	mov	eax, DWORD PTR [ebx+32]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 263  : 			else

	jmp	SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

	mov	esi, DWORD PTR __Off$[ebp]
	mov	eax, esi
	mov	edi, DWORD PTR __Off$[ebp+4]
	or	eax, edi
	je	SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
$LN22@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movq	QWORD PTR [eax+16], xmm0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 272  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	esi, DWORD PTR [ecx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 208  : 		if (_Mysb::gptr() == 0)

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

	or	eax, -1
	pop	esi

; 222  : 		}

	ret	0
$LN2@underflow:
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	edi, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edi]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

	cmp	edx, eax
	jae	SHORT $LN4@underflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 222  : 		}

	ret	0
$LN4@underflow:

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

	test	BYTE PTR [ecx+60], 4
	jne	SHORT $LN8@underflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [ecx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN8@underflow
	cmp	eax, edx
	ja	SHORT $LN6@underflow
	cmp	DWORD PTR [ecx+56], edx
	jbe	SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

	cmp	DWORD PTR [ecx+56], eax
	jae	SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

	mov	DWORD PTR [ecx+56], eax
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

	mov	eax, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 255  : 		*_IGcount = (int)(_Last - _Next);

	sub	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ecx+28]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 222  : 		}

	ret	0
$LN8@underflow:
	pop	edi

; 214  : 			return (_Traits::eof());	// can't read, fail

	or	eax, -1
	pop	esi

; 222  : 		}

	ret	0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

	push	ebp
	mov	ebp, esp
	mov	edx, ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	esi, DWORD PTR [eax]
	jbe	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR __Meta$[ebp]
	cmp	ecx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 571  : 		return (_Left == _Right);

	cmp	cl, BYTE PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN2@pbackfail
	test	BYTE PTR [edx+60], 2
	jne	SHORT $LN4@pbackfail
$LN2@pbackfail:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [edx+44]
	inc	DWORD PTR [eax]

; 248  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [edx+28]
	dec	DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	ecx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

	je	SHORT $LN45@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edx+28]
	pop	esi
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [eax], cl

; 202  : 			return (_Traits::not_eof(_Meta));

	mov	eax, ecx

; 203  : 			}
; 204  : 		}

	pop	ebp
	ret	4
$LN45@pbackfail:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 202  : 			return (_Traits::not_eof(_Meta));

	mov	eax, ecx
	pop	esi

; 203  : 			}
; 204  : 		}

	pop	ebp
	ret	4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

	or	eax, -1
	pop	esi

; 203  : 			}
; 204  : 		}

	pop	ebp
	ret	4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
tv598 = -8						; size = 4
__Newsize$1$ = -8					; size = 4
__Oldptr$1$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 121  : 		if (_Mystate & _Constant)

	mov	eax, DWORD PTR [esi+60]
	test	al, 2
	je	SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

	or	eax, -1
	pop	esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@overflow:
	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	mov	ebx, DWORD PTR __Meta$[ebp]
	cmp	ebx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	pop	ebx
	xor	eax, eax
	pop	esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@overflow:
	push	edi

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

	test	al, 8
	je	SHORT $LN7@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN7@overflow
	mov	edi, DWORD PTR [esi+56]
	cmp	edx, edi
	jae	SHORT $LN7@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]

; 302  : 		*_IPnext = _Next;

	mov	eax, DWORD PTR [esi+32]

; 260  : 		return (*_IPnext + *_IPcount);

	add	ecx, edx

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	ecx, edi
	mov	DWORD PTR [eax], edi
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], ecx
$LN7@overflow:

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN121@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	edi, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

	cmp	edx, eax
	jae	SHORT $LN8@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

	dec	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 134  : 			return (_Meta);

	mov	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

	mov	DWORD PTR [edi], ecx

; 309  : 		return ((*_IPnext)++);

	mov	edx, DWORD PTR [esi+32]
	pop	edi
	mov	esi, DWORD PTR [edx]
	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [esi], bl
	pop	ebx
	pop	esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN8@overflow:

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

	test	edx, edx
	jne	SHORT $LN20@overflow
$LN121@overflow:
	xor	edi, edi
	jmp	SHORT $LN21@overflow
$LN20@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [esi+48]

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

	mov	edi, DWORD PTR [eax]
	sub	edi, DWORD PTR [ecx]
	add	edi, edx
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

	mov	ecx, edi
	shr	ecx, 1
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN22@overflow
	mov	ecx, 32					; 00000020H
	jmp	SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	test	ecx, ecx
	je	SHORT $LN123@overflow
	npad	4
$LL2@overflow:
	mov	eax, 2147483647				; 7fffffffH
	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN116@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

	shr	ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	jne	SHORT $LL2@overflow
$LN116@overflow:

; 146  : 			if (_Inc == 0)

	test	ecx, ecx
	jne	SHORT $LN10@overflow
$LN123@overflow:
	pop	edi
	pop	ebx

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

	or	eax, -1
	pop	esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

	lea	eax, DWORD PTR [ecx+edi]

; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

	push	eax
	lea	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR __Newsize$1$[ebp], eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __Oldptr$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 154  : 			if (0 < _Oldsize)

	test	edi, edi
	je	SHORT $LN125@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	ecx
	push	ebx
	call	_memcpy
	mov	ecx, DWORD PTR __Oldptr$1$[ebp]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 157  : 			if (_Oldsize == 0)

	test	edi, edi
	jne	SHORT $LN12@overflow
$LN125@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 294  : 		*_IPfirst = _First;

	mov	eax, DWORD PTR [esi+16]

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	edx, DWORD PTR __Newsize$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 159  : 				_Seekhigh = _Newptr;

	mov	DWORD PTR [esi+56], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 294  : 		*_IPfirst = _First;

	mov	DWORD PTR [eax], ebx

; 295  : 		*_IPnext = _First;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], ebx

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], edx

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 161  : 				if (_Mystate & _Noread)

	test	BYTE PTR [esi+60], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	DWORD PTR [eax], ebx

; 254  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 161  : 				if (_Mystate & _Noread)

	je	SHORT $LN14@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 254  : 		*_IGnext = _Next;

	mov	DWORD PTR [eax], 0

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 163  : 				else

	jmp	SHORT $LN17@overflow
$LN14@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 254  : 		*_IGnext = _Next;

	mov	DWORD PTR [eax], ebx

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 166  : 			else

	jmp	SHORT $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

	mov	eax, ebx
	sub	eax, ecx
	add	DWORD PTR [esi+56], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

	mov	edx, DWORD PTR [eax]
	mov	eax, ebx
	sub	eax, DWORD PTR __Oldptr$1$[ebp]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 232  : 		return (*_IPfirst);

	mov	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

	add	edx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 301  : 		*_IPfirst = _First;

	add	DWORD PTR [ecx], eax

; 303  : 		*_IPcount = (int)(_Last - _Next);

	mov	ecx, ebx
	mov	eax, DWORD PTR [esi+32]
	sub	ecx, edx
	add	ecx, DWORD PTR __Newsize$1$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 172  : 				if (_Mystate & _Noread)

	test	BYTE PTR [esi+60], 4
	je	SHORT $LN16@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], ebx

; 254  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], 0

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 174  : 				else

	jmp	SHORT $LN17@overflow
$LN16@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

	mov	ecx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

	sub	ecx, DWORD PTR __Oldptr$1$[ebp]
	add	ecx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 255  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [eax], ebx
	inc	edx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN17@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 180  : 			if (_Mystate & _Allocated)

	test	BYTE PTR [esi+60], 1
	je	SHORT $LN18@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	edi
	push	DWORD PTR __Oldptr$1$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN18@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

	mov	eax, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 182  : 			_Mystate |= _Allocated;

	or	DWORD PTR [esi+60], 1
	pop	edi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

	dec	DWORD PTR [eax]

; 309  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [esi+32]
	pop	esi
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	BYTE PTR [edx], al

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Nul$2 = -28						; size = 24
__Str$3 = -28						; size = 24
__Str$4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, ecx
	mov	DWORD PTR $T1[ebp], 0
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

	mov	ecx, DWORD PTR [edx+60]
	test	cl, 2
	jne	SHORT $LN2@str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [edx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN2@str

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

	mov	ecx, DWORD PTR [edx+56]
	cmp	ecx, eax
	cmovb	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 232  : 		return (*_IPfirst);

	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	push	ecx
	push	eax
	lea	ecx, DWORD PTR __Str$4[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$4[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$4[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR __Str$4[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	lea	eax, DWORD PTR __Str$4[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR __Str$4[ebp+20]
	cmp	ecx, 16					; 00000010H
	jb	$LN269@str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR __Str$4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 108  : 			return (_Nul);

	mov	eax, esi
	pop	esi

; 110  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@str:
	push	edi

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

	test	cl, 4
	jne	SHORT $LN4@str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN4@str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax]

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edx+12]

; 242  : 		return (*_IGnext + *_IGcount);

	add	ecx, edi

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	push	ecx
	push	eax
	lea	ecx, DWORD PTR __Str$3[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR __Str$3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 103  : 			return (_Str);

	jmp	SHORT $LN1068@str
$LN4@str:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Nul$2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Nul$2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR __Nul$2[ebp], 0
$LN1068@str:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	lea	eax, DWORD PTR __Nul$2[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR __Nul$2[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN966@str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR __Nul$2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN966@str:
	pop	edi
$LN269@str:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 110  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	ebx, DWORD PTR __Mode$[ebp]

; 358  : 		if (!(_Mode & ios_base::out))

	mov	eax, ebx

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

	mov	DWORD PTR [esi+56], 0
	lea	edx, DWORD PTR [ebx*4]
	not	edx
	and	edx, 4
	mov	ecx, edx
	or	ecx, 2

; 358  : 		if (!(_Mode & ios_base::out))

	and	al, 2

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

	mov	eax, ebx
	cmovne	ecx, edx
	mov	edx, ecx
	or	edx, 8
	and	al, 8
	cmove	edx, ecx
	mov	eax, edx
	or	eax, 16					; 00000010H

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

	and	bl, 4
	cmove	eax, edx

; 312  : 		_Mystate = _State;

	mov	DWORD PTR [esi+60], eax

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 545  : 		{	// return string copy of character array

	push	ebp
	mov	ebp, esp
	push	ecx

; 546  : 		return (_Stringbuffer.str());

	push	DWORD PTR ___$ReturnUdt$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T1[ebp], 0
	call	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 547  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 536  : 		{	// destroy the object

	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi-80]

; 76   : 		_Tidy();

	lea	ecx, DWORD PTR [edi-76]

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+edi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR [edi-80]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-80]
	mov	DWORD PTR [edx+edi-84], eax

; 75   : 		{	// destroy the object

	mov	DWORD PTR [edi-76], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	lea	ecx, DWORD PTR [edi-76]
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 537  : 		}

	lea	ecx, DWORD PTR [edi-72]
	pop	edi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 492  : 		{	// construct empty writable character buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR $T2[ebp], 0
	cmp	DWORD PTR _$initVBases$[ebp], 0
	je	SHORT $LN2@basic_ostr
	lea	ecx, DWORD PTR [edi+80]
	mov	DWORD PTR [edi], OFFSET ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 1
$LN2@basic_ostr:

; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}
; 366  : 
; 367  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 368  : 	_Strstate _Mystate;	// the stream state
; 369  : 	allocator_type _Al;	// the allocator object
; 370  : 	};
; 371  : 
; 372  : 	// basic_stringbuf TEMPLATE OPERATORS
; 373  : template<class _Elem,
; 374  : 	class _Traits,
; 375  : 	class _Alloc> inline
; 376  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 377  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 378  : 	{	// swap _Left and _Right basic_stringbufs
; 379  : 	_Left.swap(_Right);
; 380  : 	}
; 381  : 
; 382  : 		// TEMPLATE CLASS basic_istringstream
; 383  : template<class _Elem,
; 384  : 	class _Traits,
; 385  : 	class _Alloc>
; 386  : 	class basic_istringstream
; 387  : 		: public basic_istream<_Elem, _Traits>
; 388  : 	{	// input stream associated with a character array
; 389  : public:
; 390  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 391  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 392  : 	typedef _Alloc allocator_type;
; 393  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 394  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 395  : 
; 396  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 397  : 		: _Mybase(&_Stringbuffer),
; 398  : 			_Stringbuffer(_Mode | ios_base::in)
; 399  : 		{	// construct empty readable character buffer
; 400  : 		}
; 401  : 
; 402  : 	explicit basic_istringstream(const _Mystr& _Str,
; 403  : 		ios_base::openmode _Mode = ios_base::in)
; 404  : 		: _Mybase(&_Stringbuffer),
; 405  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 406  : 		{	// construct readable character buffer from NTCS
; 407  : 		}
; 408  : 
; 409  : 	basic_istringstream(_Myt&& _Right)
; 410  : 		: _Mybase(&_Stringbuffer)
; 411  : 		{	// construct by moving _Right
; 412  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 413  : 		}
; 414  : 
; 415  : 	_Myt& operator=(_Myt&& _Right)
; 416  : 		{	// move from _Right
; 417  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	void _Assign_rv(_Myt&& _Right)
; 422  : 		{	// assign by moving _Right
; 423  : 		if (this != &_Right)
; 424  : 			{	// different, worth moving
; 425  : 			_Stringbuffer.str(_Mystr());
; 426  : 			this->swap(_Right);
; 427  : 			}
; 428  : 		}
; 429  : 
; 430  : 	void swap(_Myt& _Right)
; 431  : 		{	// swap with _Right
; 432  : 		if (this != &_Right)
; 433  : 			{	// different, swap base and buffer
; 434  : 			_Mybase::swap(_Right);
; 435  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 436  : 			}
; 437  : 		}
; 438  : 
; 439  : 	basic_istringstream(const _Myt&) = delete;
; 440  : 	_Myt& operator=(const _Myt&) = delete;
; 441  : 
; 442  : 	virtual ~basic_istringstream() _NOEXCEPT
; 443  : 		{	// destroy the object
; 444  : 		}
; 445  : 
; 446  : 	_Mysb *rdbuf() const
; 447  : 		{	// return pointer to file buffer
; 448  : 		return ((_Mysb *)&_Stringbuffer);
; 449  : 		}
; 450  : 
; 451  : 	_Mystr str() const
; 452  : 		{	// return string copy of character array
; 453  : 		return (_Stringbuffer.str());
; 454  : 		}
; 455  : 
; 456  : 	void str(const _Mystr& _Newstr)
; 457  : 		{	// replace character array from string
; 458  : 		_Stringbuffer.str(_Newstr);
; 459  : 		}
; 460  : 
; 461  : private:
; 462  : 	_Mysb _Stringbuffer;	// the string buffer
; 463  : 	};
; 464  : 
; 465  : 	// basic_istringstream TEMPLATE OPERATORS
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// TEMPLATE CLASS basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),

	push	0
	push	0
	lea	esi, DWORD PTR [edi+4]
	mov	ecx, edi
	push	esi
	call	DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z

; 492  : 		{	// construct empty writable character buffer

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR __Mode$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	or	ebx, 2
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _this$[ebp], esi
	lea	eax, DWORD PTR [ecx-80]
	mov	DWORD PTR [ecx+edi-4], eax

; 30   : 		{	// construct empty character buffer from mode

	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	lea	ecx, DWORD PTR [ebx*4]
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	not	ecx

; 311  : 		_Seekhigh = 0;

	mov	DWORD PTR [esi+56], 0
	and	ecx, 4

; 360  : 		if (_Mode & ios_base::app)

	mov	eax, ebx
	mov	edx, ecx
	or	edx, 8
	and	al, 8
	cmove	edx, ecx
	mov	eax, edx
	or	eax, 16					; 00000010H

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

	and	bl, 4
	cmove	eax, edx

; 312  : 		_Mystate = _State;

	mov	DWORD PTR [esi+60], eax

; 493  : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN5@basic_ostr
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_ostr:
	ret	0
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2439 : 	{	// return string + NTCS

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR __Right$[ebp]
	push	esi
	mov	DWORD PTR $T1[ebp], 0
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN9@operator
	xor	eax, eax
	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	eax, edx
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL143@operator:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL143@operator
	sub	eax, esi
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR __Left$[ebp]
	push	eax
	push	edx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	push	eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 2440 : 	return (_STD move(_Left.append(_Right)));

	mov	eax, esi
	pop	esi

; 2441 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?uintToString@Json@@YAXIAAPAD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_current$ = 12						; size = 4
?uintToString@Json@@YAXIAAPAD@Z PROC			; Json::uintToString, COMDAT

; 32   : {

	push	ebp
	mov	ebp, esp

; 33   :    *--current = 0;

	mov	ecx, DWORD PTR _value$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _current$[ebp]
	dec	DWORD PTR [edi]
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [eax], 0
$LL4@uintToStri:

; 34   :    do
; 35   :    {
; 36   :       *--current = (value % 10) + '0';

	dec	DWORD PTR [edi]
	mov	eax, -858993459				; cccccccdH
	mov	esi, DWORD PTR [edi]
	mul	ecx
	shr	edx, 3
	mov	al, dl
	shl	al, 2
	lea	ebx, DWORD PTR [eax+edx]
	add	bl, bl
	sub	cl, bl
	add	cl, 48					; 00000030H
	mov	BYTE PTR [esi], cl

; 37   :       value /= 10;

	mov	ecx, edx

; 38   :    }
; 39   :    while ( value != 0 );

	test	ecx, ecx
	jne	SHORT $LL4@uintToStri
	pop	edi
	pop	esi
	pop	ebx

; 40   : }

	pop	ebp
	ret	0
?uintToString@Json@@YAXIAAPAD@Z ENDP			; Json::uintToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?containsControlCharacter@Json@@YA_NPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?containsControlCharacter@Json@@YA_NPBD@Z PROC		; Json::containsControlCharacter, COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp

; 23   :    while ( *str ) 

	mov	ecx, DWORD PTR _str$[ebp]
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN3@containsCo
	npad	4
$LL2@containsCo:

; 18   :    return ch > 0 && ch <= 0x1F;

	dec	al

; 24   :    {
; 25   :       if ( isControlCharacter( *(str++) ) )

	lea	ecx, DWORD PTR [ecx+1]

; 18   :    return ch > 0 && ch <= 0x1F;

	mov	dl, 30					; 0000001eH
	cmp	dl, al
	sbb	eax, eax
	inc	eax

; 24   :    {
; 25   :       if ( isControlCharacter( *(str++) ) )

	test	al, al
	jne	SHORT $LN11@containsCo

; 23   :    while ( *str ) 

	mov	al, BYTE PTR [ecx]
	test	al, al
	jne	SHORT $LL2@containsCo
$LN3@containsCo:

; 27   :    }
; 28   :    return false;

	xor	al, al

; 29   : }

	pop	ebp
	ret	0
$LN11@containsCo:

; 26   :          return true;

	mov	al, 1

; 29   : }

	pop	ebp
	ret	0
?containsControlCharacter@Json@@YA_NPBD@Z ENDP		; Json::containsControlCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?isControlCharacter@Json@@YA_ND@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
?isControlCharacter@Json@@YA_ND@Z PROC			; Json::isControlCharacter, COMDAT

; 17   : {

	push	ebp
	mov	ebp, esp

; 18   :    return ch > 0 && ch <= 0x1F;

	mov	al, BYTE PTR _ch$[ebp]
	mov	cl, 30					; 0000001eH
	dec	al
	cmp	cl, al
	sbb	eax, eax
	inc	eax

; 19   : }

	pop	ebp
	ret	0
?isControlCharacter@Json@@YA_ND@Z ENDP			; Json::isControlCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z
_TEXT	SEGMENT
_writer$ = -88						; size = 72
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sout$ = 8						; size = 4
_root$ = 12						; size = 4
??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z PROC ; Json::operator<<, COMDAT

; 822  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR _root$[ebp]

; 823  :    Json::StyledStreamWriter writer;

	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN108@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN109@operator
$LN108@operator:
	mov	eax, ecx
$LN109@operator:

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01GPOEFGEJ@?7?$AA@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 823  :    Json::StyledStreamWriter writer;

	lea	ecx, DWORD PTR _writer$[ebp]
	call	??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::StyledStreamWriter

; 555  :    document_ = &out;

	mov	esi, DWORD PTR _sout$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	ecx, DWORD PTR _writer$[ebp+16]
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 823  :    Json::StyledStreamWriter writer;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 555  :    document_ = &out;

	mov	DWORD PTR _writer$[ebp+12], esi

; 556  :    addChildValues_ = false;

	mov	BYTE PTR _writer$[ebp+68], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 558  :    writeCommentBeforeValue( root );

	push	edi
	lea	ecx, DWORD PTR _writer$[ebp]
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue

; 559  :    writeValue( root );

	push	edi
	lea	ecx, DWORD PTR _writer$[ebp]
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue

; 560  :    writeCommentAfterValueOnSameLine( root );

	push	edi
	lea	ecx, DWORD PTR _writer$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 561  :    *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	DWORD PTR _writer$[ebp+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 562  :    document_ = NULL; // Forget the stream, for safety.

	mov	DWORD PTR _writer$[ebp+12], 0

; 824  :    writer.write(sout, root);
; 825  :    return sout;

	lea	ecx, DWORD PTR _writer$[ebp]
	call	??1StyledStreamWriter@Json@@QAE@XZ	; Json::StyledStreamWriter::~StyledStreamWriter
	mov	eax, esi

; 826  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z$1:
	lea	ecx, DWORD PTR _writer$[ebp]
	jmp	??1StyledStreamWriter@Json@@QAE@XZ	; Json::StyledStreamWriter::~StyledStreamWriter
__ehhandler$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z ENDP ; Json::operator<<
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
_oss$2 = -276						; size = 152
_this$ = -124						; size = 4
___$ReturnUdt$GSCopy$1$ = -120				; size = 4
$T3 = -116						; size = 4
$T4 = -112						; size = 24
$T5 = -88						; size = 24
$T6 = -64						; size = 24
$T7 = -56						; size = 16
_result$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::valueToQuotedString, COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _value$[ebp]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 113  :    // Not sure how to handle unicode...
; 114  :    if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL && !containsControlCharacter( value ))

	push	OFFSET ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
	push	esi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], ebx
	mov	DWORD PTR $T3[ebp], 0
	call	DWORD PTR __imp__strpbrk
	add	esp, 8
	test	eax, eax
	jne	$LN7@valueToQuo
	mov	ecx, esi

; 23   :    while ( *str ) 

	cmp	BYTE PTR [esi], al
	je	SHORT $LN28@valueToQuo
	npad	5
$LL27@valueToQuo:

; 24   :    {
; 25   :       if ( isControlCharacter( *(str++) ) )

	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]

; 18   :    return ch > 0 && ch <= 0x1F;

	dec	al
	mov	dl, 30					; 0000001eH
	cmp	dl, al
	sbb	eax, eax
	inc	eax

; 25   :       if ( isControlCharacter( *(str++) ) )

	test	al, al
	jne	SHORT $LN7@valueToQuo

; 19   : }
; 20   : 
; 21   : static bool containsControlCharacter( const char* str )
; 22   : {
; 23   :    while ( *str ) 

	cmp	BYTE PTR [ecx], al
	jne	SHORT $LL27@valueToQuo
$LN28@valueToQuo:

; 115  :       return std::string("\"") + value + "\"";

	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	esi
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	push	eax
	push	ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T6[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 115  :       return std::string("\"") + value + "\"";

	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN41@valueToQuo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T6[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN41@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T5[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T6[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T6[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T6[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	$LN146@valueToQuo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 115  :       return std::string("\"") + value + "\"";

	jmp	$LN146@valueToQuo
$LN7@valueToQuo:

; 119  :    unsigned maxsize = strlen(value)*2 + 3; // allescaped+quotes+NULL

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL1131@valueToQuo:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL1131@valueToQuo
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _result$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _result$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _result$[ebp], al
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 119  :    unsigned maxsize = strlen(value)*2 + 3; // allescaped+quotes+NULL

	lea	ecx, DWORD PTR [ecx*2+3]

; 120  :    std::string result;

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	ecx, 15					; 0000000fH
	je	SHORT $LN410@valueToQuo

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	ecx
	lea	ecx, DWORD PTR _result$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN410@valueToQuo

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _result$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR _result$[ebp]

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _result$[ebp+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmovae	eax, DWORD PTR _result$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
$LN410@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 123  :    for (const char* c=value; *c != 0; ++c)

	cmp	BYTE PTR [esi], 0
	je	$LN649@valueToQuo
	mov	ebx, DWORD PTR $T3[ebp]
$LL4@valueToQuo:

; 124  :    {
; 125  :       switch(*c)

	mov	cl, BYTE PTR [esi]
	movsx	eax, cl
	add	eax, -8					; fffffff8H
	cmp	eax, 84					; 00000054H
	ja	$LN15@valueToQuo
	movzx	eax, BYTE PTR $LN1132@valueToQuo[eax]
	jmp	DWORD PTR $LN1134@valueToQuo[eax*4]
$LN8@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02MCKKLHBJ@?2?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 129  :             break;

	jmp	$LN2@valueToQuo
$LN9@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02HDBGODGB@?2?2?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 132  :             break;

	jmp	$LN2@valueToQuo
$LN10@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02DCNDPIBM@?2b?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 135  :             break;

	jmp	$LN2@valueToQuo
$LN11@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02FGLPDNBI@?2f?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 138  :             break;

	jmp	$LN2@valueToQuo
$LN12@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02JOGGLHBA@?2n?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 141  :             break;

	jmp	$LN2@valueToQuo
$LN13@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02HIBBOKEN@?2r?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 144  :             break;

	jmp	$LN2@valueToQuo
$LN466@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02COELENML@?2t?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 147  :             break;

	jmp	$LN2@valueToQuo
$LN15@valueToQuo:

; 18   :    return ch > 0 && ch <= 0x1F;

	mov	al, cl
	mov	dl, 30					; 0000001eH
	dec	al
	cmp	dl, al
	sbb	eax, eax
	inc	eax

; 148  :          //case '/':
; 149  :             // Even though \/ is considered a legal escape in JSON, a bare
; 150  :             // slash is also legal, so I see no reason to escape it.
; 151  :             // (I hope I am not misunderstanding something.
; 152  :             // blep notes: actually escaping \/ may be useful in javascript to avoid </ 
; 153  :             // sequence.
; 154  :             // Should add a flag to allow this compatibility mode and prevent this 
; 155  :             // sequence from occurring.
; 156  :          default:
; 157  :             if ( isControlCharacter( *c ) )

	test	al, al
	je	$LN16@valueToQuo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 492  : 		{	// construct empty writable character buffer

	lea	ecx, DWORD PTR _oss$2[ebp+80]
	mov	DWORD PTR _oss$2[ebp], OFFSET ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	eax, DWORD PTR _oss$2[ebp+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	or	ebx, 2

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(_Mysb::eback(),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	enum
; 350  : 		{	// constant for minimum buffer size
; 351  : 		_MINSIZE = 32};
; 352  : 
; 353  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 354  : 		{	// convert open mode to stream state bits
; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))
; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)
; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)
; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}
; 366  : 
; 367  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 368  : 	_Strstate _Mystate;	// the stream state
; 369  : 	allocator_type _Al;	// the allocator object
; 370  : 	};
; 371  : 
; 372  : 	// basic_stringbuf TEMPLATE OPERATORS
; 373  : template<class _Elem,
; 374  : 	class _Traits,
; 375  : 	class _Alloc> inline
; 376  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 377  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 378  : 	{	// swap _Left and _Right basic_stringbufs
; 379  : 	_Left.swap(_Right);
; 380  : 	}
; 381  : 
; 382  : 		// TEMPLATE CLASS basic_istringstream
; 383  : template<class _Elem,
; 384  : 	class _Traits,
; 385  : 	class _Alloc>
; 386  : 	class basic_istringstream
; 387  : 		: public basic_istream<_Elem, _Traits>
; 388  : 	{	// input stream associated with a character array
; 389  : public:
; 390  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 391  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 392  : 	typedef _Alloc allocator_type;
; 393  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 394  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 395  : 
; 396  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 397  : 		: _Mybase(&_Stringbuffer),
; 398  : 			_Stringbuffer(_Mode | ios_base::in)
; 399  : 		{	// construct empty readable character buffer
; 400  : 		}
; 401  : 
; 402  : 	explicit basic_istringstream(const _Mystr& _Str,
; 403  : 		ios_base::openmode _Mode = ios_base::in)
; 404  : 		: _Mybase(&_Stringbuffer),
; 405  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 406  : 		{	// construct readable character buffer from NTCS
; 407  : 		}
; 408  : 
; 409  : 	basic_istringstream(_Myt&& _Right)
; 410  : 		: _Mybase(&_Stringbuffer)
; 411  : 		{	// construct by moving _Right
; 412  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 413  : 		}
; 414  : 
; 415  : 	_Myt& operator=(_Myt&& _Right)
; 416  : 		{	// move from _Right
; 417  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	void _Assign_rv(_Myt&& _Right)
; 422  : 		{	// assign by moving _Right
; 423  : 		if (this != &_Right)
; 424  : 			{	// different, worth moving
; 425  : 			_Stringbuffer.str(_Mystr());
; 426  : 			this->swap(_Right);
; 427  : 			}
; 428  : 		}
; 429  : 
; 430  : 	void swap(_Myt& _Right)
; 431  : 		{	// swap with _Right
; 432  : 		if (this != &_Right)
; 433  : 			{	// different, swap base and buffer
; 434  : 			_Mybase::swap(_Right);
; 435  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 436  : 			}
; 437  : 		}
; 438  : 
; 439  : 	basic_istringstream(const _Myt&) = delete;
; 440  : 	_Myt& operator=(const _Myt&) = delete;
; 441  : 
; 442  : 	virtual ~basic_istringstream() _NOEXCEPT
; 443  : 		{	// destroy the object
; 444  : 		}
; 445  : 
; 446  : 	_Mysb *rdbuf() const
; 447  : 		{	// return pointer to file buffer
; 448  : 		return ((_Mysb *)&_Stringbuffer);
; 449  : 		}
; 450  : 
; 451  : 	_Mystr str() const
; 452  : 		{	// return string copy of character array
; 453  : 		return (_Stringbuffer.str());
; 454  : 		}
; 455  : 
; 456  : 	void str(const _Mystr& _Newstr)
; 457  : 		{	// replace character array from string
; 458  : 		_Stringbuffer.str(_Newstr);
; 459  : 		}
; 460  : 
; 461  : private:
; 462  : 	_Mysb _Stringbuffer;	// the string buffer
; 463  : 	};
; 464  : 
; 465  : 	// basic_istringstream TEMPLATE OPERATORS
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// TEMPLATE CLASS basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),

	lea	ecx, DWORD PTR _oss$2[ebp]
	push	eax
	mov	DWORD PTR $T3[ebp], ebx
	call	DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z

; 492  : 		{	// construct empty writable character buffer

	mov	eax, DWORD PTR _oss$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _oss$2[ebp+eax], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR _oss$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-80]
	mov	DWORD PTR _oss$2[ebp+ecx-4], eax
	lea	eax, DWORD PTR _oss$2[ebp+4]

; 30   : 		{	// construct empty character buffer from mode

	mov	ecx, eax

; 491  : 			_Stringbuffer(_Mode | ios_base::out)

	mov	DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	DWORD PTR _oss$2[ebp+4], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

	mov	DWORD PTR _oss$2[ebp+60], 0

; 312  : 		_Mystate = _State;

	mov	DWORD PTR _oss$2[ebp+64], 4
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	push	OFFSET ?uppercase@std@@YAAAVios_base@1@AAV21@@Z ; std::uppercase
	push	OFFSET ?hex@std@@YAAAVios_base@1@AAV21@@Z ; std::hex
	lea	eax, DWORD PTR _oss$2[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	OFFSET ??_C@_02DHFAHMIK@?2u?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	mov	edi, eax
	lea	eax, DWORD PTR $T7[ebp]
	push	0
	push	4
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip

; 62   : 	_Ostr.fill(_Manip._Fill);

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 119  : 		_Fillch = _Newfill;

	mov	BYTE PTR [ecx+edi+64], 48		; 00000030H
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip

; 527  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	add	ecx, edi
	push	ecx
	call	eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	movsx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip

; 527  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	add	esp, 24					; 00000018H
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	mov	ecx, edi
	push	eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 161  :                result += oss.str();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR _oss$2[ebp]
	call	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR _result$[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 161  :                result += oss.str();

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN533@valueToQuo

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN533@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR _oss$2[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 162  :             }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _oss$2[ebp+eax], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR _oss$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-80]
	mov	DWORD PTR _oss$2[ebp+ecx-4], eax

; 76   : 		_Tidy();

	lea	ecx, DWORD PTR _oss$2[ebp+4]
	mov	DWORD PTR _oss$2[ebp+4], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	lea	ecx, DWORD PTR _oss$2[ebp+4]
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 537  : 		}

	lea	ecx, DWORD PTR _oss$2[ebp+8]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _oss$2[ebp+80]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 163  :             else

	jmp	SHORT $LN2@valueToQuo
$LN16@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	ecx
	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@valueToQuo:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 123  :    for (const char* c=value; *c != 0; ++c)

	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	$LL4@valueToQuo
	mov	ebx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
$LN649@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ebx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ebx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	mov	ecx, DWORD PTR _result$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN781@valueToQuo

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR _result$[ebp+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN782@valueToQuo
	push	eax
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	mov	ecx, DWORD PTR _result$[ebp+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN782@valueToQuo
$LN781@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ebx], eax
$LN782@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR _result$[ebp+16]
	mov	DWORD PTR [ebx+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	DWORD PTR [ebx+20], ecx
$LN146@valueToQuo:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 171  :    return result;

	mov	eax, ebx

; 172  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN1134@valueToQuo:
	DD	$LN10@valueToQuo
	DD	$LN466@valueToQuo
	DD	$LN12@valueToQuo
	DD	$LN11@valueToQuo
	DD	$LN13@valueToQuo
	DD	$LN8@valueToQuo
	DD	$LN9@valueToQuo
	DD	$LN15@valueToQuo
$LN1132@valueToQuo:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	3
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$0:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$1:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$3:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$99:
	mov	eax, DWORD PTR $T3[ebp]
	and	eax, 2
	je	$LN476@valueToQuo
	and	DWORD PTR $T3[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR _oss$2[ebp+80]
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN476@valueToQuo:
	ret	0
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$100:
	lea	ecx, DWORD PTR _oss$2[ebp+8]
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$102:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$4:
	lea	ecx, DWORD PTR _oss$2[ebp]
	jmp	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$5:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::valueToQuotedString
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 1
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; Json::valueToString, COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 108  :    return value ? "true" : "false";

	cmp	BYTE PTR _value$[ebp], 0
	mov	edx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 108  :    return value ? "true" : "false";

	mov	eax, OFFSET ??_C@_05LAPONLG@false?$AA@
	cmove	edx, eax
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN119@valueToStr
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 108  :    return value ? "true" : "false";

	mov	eax, esi
	pop	esi

; 109  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN119@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
	npad	2
$LL121@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL121@valueToStr
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 108  :    return value ? "true" : "false";

	mov	eax, esi
	pop	esi

; 109  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 8
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z PROC ; Json::valueToString, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 68   :    char buffer[32];
; 69   : #if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__) // Use secure version with visual studio 2005 to avoid warning. 
; 70   :    sprintf_s(buffer, sizeof(buffer), "%#.16g", value); 

	movsd	xmm0, QWORD PTR _value$[ebp]
	lea	eax, DWORD PTR _buffer$[ebp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	sub	esp, 8
	mov	DWORD PTR $T1[ebp], 0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@
	push	32					; 00000020H
	push	eax
	call	_sprintf_s

; 71   : #else	
; 72   :    sprintf(buffer, "%#.16g", value); 
; 73   : #endif
; 74   :    char* ch = buffer + strlen(buffer) - 1;

	lea	ecx, DWORD PTR _buffer$[ebp]
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [ecx+1]
$LL488@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL488@valueToStr
	sub	ecx, edx

; 75   :    if (*ch != '0') return buffer; // nothing to truncate, so save time

	cmp	BYTE PTR _buffer$[ebp+ecx-1], 48	; 00000030H
	lea	eax, DWORD PTR _buffer$[ebp+ecx-1]
	je	SHORT $LN479@valueToStr
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	je	SHORT $LN495@valueToStr
	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
$LL489@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL489@valueToStr
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 75   :    if (*ch != '0') return buffer; // nothing to truncate, so save time

	jmp	$LN494@valueToStr
$LN479@valueToStr:

; 76   :    while(ch > buffer && *ch == '0'){

	lea	ecx, DWORD PTR _buffer$[ebp]
	cmp	eax, ecx
	jbe	SHORT $LN493@valueToStr
$LL2@valueToStr:
	cmp	BYTE PTR [eax], 48			; 00000030H
	jne	SHORT $LN493@valueToStr

; 77   :      --ch;

	dec	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	cmp	eax, ecx
	ja	SHORT $LL2@valueToStr
$LN493@valueToStr:

; 78   :    }
; 79   :    char* last_nonzero = ch;
; 80   :    while(ch >= buffer){

	lea	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, eax
	cmp	eax, ecx
	jb	SHORT $LN5@valueToStr
	npad	5
$LL4@valueToStr:

; 81   :      switch(*ch){

	mov	cl, BYTE PTR [eax]
	cmp	cl, 46					; 0000002eH
	je	SHORT $LN10@valueToStr
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN481@valueToStr

; 82   :      case '0':
; 83   :      case '1':
; 84   :      case '2':
; 85   :      case '3':
; 86   :      case '4':
; 87   :      case '5':
; 88   :      case '6':
; 89   :      case '7':
; 90   :      case '8':
; 91   :      case '9':
; 92   :        --ch;

	dec	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	cmp	eax, ecx
	jae	SHORT $LL4@valueToStr
$LN5@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	jne	SHORT $LN477@valueToStr
$LN495@valueToStr:
	xor	ecx, ecx
	jmp	SHORT $LN478@valueToStr
$LN481@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	je	SHORT $LN495@valueToStr
	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	1
$LL490@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL490@valueToStr
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 99   :        return buffer;

	jmp	SHORT $LN494@valueToStr
$LN10@valueToStr:

; 93   :        continue;
; 94   :      case '.':
; 95   :        // Truncate zeroes to save bytes in output, but keep one.
; 96   :        *(last_nonzero+2) = '\0';

	mov	BYTE PTR [edx+2], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	je	SHORT $LN495@valueToStr
	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL491@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL491@valueToStr
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 97   :        return buffer;

	jmp	SHORT $LN494@valueToStr
$LN477@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	1
$LL492@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL492@valueToStr
$LN494@valueToStr:
	sub	ecx, edx
$LN478@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	lea	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, esi
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 103  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
_current$ = -40						; size = 4
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::valueToString, COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 59   :    char buffer[32];
; 60   :    char *current = buffer + sizeof(buffer);

	lea	eax, DWORD PTR _buffer$[ebp+32]
	mov	DWORD PTR $T1[ebp], 0
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR _current$[ebp], eax

; 61   :    uintToString( value, current );

	lea	eax, DWORD PTR _current$[ebp]
	push	eax
	push	DWORD PTR _value$[ebp]
	call	?uintToString@Json@@YAXIAAPAD@Z		; Json::uintToString
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR _current$[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 61   :    uintToString( value, current );

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN119@valueToStr
	xor	ecx, ecx
	jmp	SHORT $LN120@valueToStr
$LN119@valueToStr:
	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL121@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL121@valueToStr
	sub	ecx, edi
	pop	edi
$LN120@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 64   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
_current$ = -40						; size = 4
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; Json::valueToString, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 44   :    char buffer[32];
; 45   :    char *current = buffer + sizeof(buffer);
; 46   :    bool isNegative = value < 0;

	mov	ecx, DWORD PTR _value$[ebp]
	lea	eax, DWORD PTR _buffer$[ebp+32]
	push	ebx
	mov	DWORD PTR _current$[ebp], eax
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 47   :    if ( isNegative )
; 48   :       value = -value;
; 49   :    uintToString( UInt(value), current );

	lea	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	eax, ecx
	shr	ebx, 31					; 0000001fH
	neg	eax
	mov	DWORD PTR $T1[ebp], 0
	test	bl, bl
	cmove	eax, ecx
	push	eax
	call	?uintToString@Json@@YAXIAAPAD@Z		; Json::uintToString

; 50   :    if ( isNegative )
; 51   :       *--current = '-';

	mov	edx, DWORD PTR _current$[ebp]
	add	esp, 8
	test	bl, bl
	je	SHORT $LN3@valueToStr
	dec	edx
	mov	BYTE PTR [edx], 45			; 0000002dH
$LN3@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN121@valueToStr
	xor	ecx, ecx
	jmp	SHORT $LN122@valueToStr
$LN121@valueToStr:
	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
	npad	5
$LL123@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL123@valueToStr
	sub	ecx, edi
	pop	edi
$LN122@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 54   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT
_end$1$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
tv1407 = 12						; size = 4
_text$ = 12						; size = 4
_c$1$ = 15						; size = 1
?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z PROC ; Json::StyledStreamWriter::normalizeEOL, COMDAT

; 799  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN114@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN115@normalizeE
$LN114@normalizeE:
	mov	eax, esi
$LN115@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	ebx, DWORD PTR _text$[ebp]

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ebx+16]

; 729  : 		return (_Get_data()._Mysize);

	lea	ecx, DWORD PTR [ebx+16]

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	edi, DWORD PTR [esi+16]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 817  :    return normalized;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	DWORD PTR tv1407[ebp], ecx

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	edi, eax
	ja	SHORT $LN179@normalizeE
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN179@normalizeE

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, esi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN573@normalizeE

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN174@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN175@normalizeE
$LN174@normalizeE:
	mov	eax, esi
$LN175@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN573@normalizeE:
	mov	ecx, DWORD PTR tv1407[ebp]
$LN179@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN195@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN195@normalizeE:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 803  :    const char *end = begin + text.length();

	mov	eax, DWORD PTR [ecx]
	add	eax, ebx
	mov	DWORD PTR _end$1$[ebp], eax

; 805  :    while ( current != end )

	cmp	ebx, eax
	je	$LN3@normalizeE
	npad	2
$LL2@normalizeE:

; 807  :       char c = *current++;

	mov	dl, BYTE PTR [ebx]
	mov	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ecx, DWORD PTR [esi+16]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 807  :       char c = *current++;

	inc	ebx
	mov	BYTE PTR _c$1$[ebp], dl

; 808  :       if ( c == '\r' ) // mac or dos EOL

	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN4@normalizeE
	cmp	BYTE PTR [ebx], 10			; 0000000aH
	cmovne	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
	inc	ebx
	cmp	eax, 1
	jbe	$LN567@normalizeE

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+1]

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN567@normalizeE

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN239@normalizeE

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	$LN562@normalizeE
$LN577@normalizeE:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	mov	ecx, DWORD PTR [esi+16]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN346@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN347@normalizeE
$LN239@normalizeE:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN577@normalizeE

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN580@normalizeE
$LN346@normalizeE:
	mov	eax, esi
$LN347@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 10			; 0000000aH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN557@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN558@normalizeE
$LN4@normalizeE:

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
	cmp	eax, 1
	jbe	SHORT $LN567@normalizeE

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+1]

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	SHORT $LN567@normalizeE

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN417@normalizeE

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	dl, BYTE PTR _c$1$[ebp]

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN562@normalizeE
$LN579@normalizeE:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	mov	ecx, DWORD PTR [esi+16]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN524@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN525@normalizeE
$LN417@normalizeE:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN579@normalizeE
$LN580@normalizeE:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN494@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	jmp	SHORT $LN562@normalizeE
$LN494@normalizeE:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	jmp	SHORT $LN562@normalizeE
$LN524@normalizeE:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
$LN525@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], dl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN557@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN558@normalizeE
$LN557@normalizeE:
	mov	eax, esi
$LN558@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN562@normalizeE:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 805  :    while ( current != end )

	cmp	ebx, DWORD PTR _end$1$[ebp]
	jne	$LL2@normalizeE
$LN3@normalizeE:

; 817  :    return normalized;

	mov	eax, esi

; 818  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN567@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN581@normalizeE:
$LN575@normalizeE:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN9@normalizeE
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@normalizeE:
	ret	0
__ehhandler$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ENDP ; Json::StyledStreamWriter::normalizeEOL
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledStreamWriter::hasCommentForValue, COMDAT
; _this$ = ecx

; 790  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 791  :    return value.hasComment( commentBefore )

	mov	esi, DWORD PTR _value$[ebp]
	mov	ecx, esi
	push	0
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	jne	SHORT $LN3@hasComment
	push	1
	mov	ecx, esi
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	jne	SHORT $LN3@hasComment
	push	2
	mov	ecx, esi
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	jne	SHORT $LN3@hasComment
	pop	esi

; 792  :           ||  value.hasComment( commentAfterOnSameLine )
; 793  :           ||  value.hasComment( commentAfter );
; 794  : }

	pop	ebp
	ret	4
$LN3@hasComment:

; 791  :    return value.hasComment( commentBefore )

	mov	al, 1
	pop	esi

; 792  :           ||  value.hasComment( commentAfterOnSameLine )
; 793  :           ||  value.hasComment( commentAfter );
; 794  : }

	pop	ebp
	ret	4
?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledStreamWriter::hasCommentForValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T2 = -136						; size = 24
$T3 = -112						; size = 24
$T4 = -88						; size = 24
$T5 = -64						; size = 24
$T6 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _root$[ebp]

; 776  :    if ( root.hasComment( commentAfterOnSameLine ) )

	mov	ecx, esi
	push	1
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	je	$LN226@writeComme

; 777  :       *document_ << " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	push	1
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, esi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	push	DWORD PTR [edi+12]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T6[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 777  :       *document_ << " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T6[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN16@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T5[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T6[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T6[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T6[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN121@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN121@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T5[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T5[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T5[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 777  :       *document_ << " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN226@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN226@writeComme:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 779  :    if ( root.hasComment( commentAfter ) )

	push	2
	mov	ecx, esi
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	je	$LN3@writeComme

; 780  :    {
; 781  :       *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	DWORD PTR [edi+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 782  :       *document_ << normalizeEOL( root.getComment( commentAfter ) );

	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, esi
	push	2
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	eax
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	push	eax
	push	DWORD PTR [edi+12]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T4[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 782  :       *document_ << normalizeEOL( root.getComment( commentAfter ) );

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN331@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN331@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T4[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T4[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T4[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 782  :       *document_ << normalizeEOL( root.getComment( commentAfter ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN436@writeComme
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN436@writeComme:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 783  :       *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 783  :       *document_ << "\n";

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN3@writeComme:

; 784  :    }
; 785  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeCommentBeforeValue, COMDAT
; _this$ = ecx

; 765  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	edi, DWORD PTR _root$[ebp]

; 766  :    if ( !root.hasComment( commentBefore ) )

	mov	ecx, edi
	push	0
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	je	$LN1@writeComme

; 768  :    *document_ << normalizeEOL( root.getComment( commentBefore ) );

	push	0
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, edi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	push	eax
	push	DWORD PTR [esi+12]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 768  :    *document_ << normalizeEOL( root.getComment( commentBefore ) );

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN12@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN12@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 768  :    *document_ << normalizeEOL( root.getComment( commentBefore ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN117@writeComme
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN117@writeComme:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 769  :    *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 769  :    *document_ << "\n";

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN1@writeComme:

; 770  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeCommentBeforeValue
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?unindent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?unindent@StyledStreamWriter@Json@@AAEXXZ PROC		; Json::StyledStreamWriter::unindent, COMDAT
; _this$ = ecx

; 758  :    assert( indentString_.size() >= indentation_.size() );
; 759  :    indentString_.resize( indentString_.size() - indentation_.size() );

	mov	eax, DWORD PTR [ecx+32]
	sub	eax, DWORD PTR [ecx+60]
	add	ecx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, edx
	ja	SHORT $LN30@unindent

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN53@unindent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN53@unindent:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 760  : }

	ret	0
$LN30@unindent:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 760  : }

	ret	0
?unindent@StyledStreamWriter@Json@@AAEXXZ ENDP		; Json::StyledStreamWriter::unindent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?indent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?indent@StyledStreamWriter@Json@@AAEXXZ PROC		; Json::StyledStreamWriter::indent, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 751  :    indentString_ += indentation_;

	lea	eax, DWORD PTR [ecx+44]
	add	ecx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 752  : }

	ret	0
?indent@StyledStreamWriter@Json@@AAEXXZ ENDP		; Json::StyledStreamWriter::indent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::writeWithIndent, COMDAT
; _this$ = ecx

; 742  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 736  :    *document_ << '\n' << indentString_;

	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	10					; 0000000aH
	push	DWORD PTR [esi+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 743  :    writeIndent();
; 744  :    *document_ << value;

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [esi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 16					; 00000010H
	pop	esi

; 745  : }

	pop	ebp
	ret	4
?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::writeWithIndent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeIndent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?writeIndent@StyledStreamWriter@Json@@AAEXXZ PROC	; Json::StyledStreamWriter::writeIndent, COMDAT
; _this$ = ecx

; 724  :   /*
; 725  :     Some comments in this method would have been nice. ;-)
; 726  : 
; 727  :    if ( !document_.empty() )
; 728  :    {
; 729  :       char last = document_[document_.length()-1];
; 730  :       if ( last == ' ' )     // already indented
; 731  :          return;
; 732  :       if ( last != '\n' )    // Comments may add new-line
; 733  :          *document_ << '\n';
; 734  :    }
; 735  :   */
; 736  :    *document_ << '\n' << indentString_;

	lea	eax, DWORD PTR [ecx+16]
	push	eax
	push	10					; 0000000aH
	push	DWORD PTR [ecx+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8

; 737  : }

	ret	0
?writeIndent@StyledStreamWriter@Json@@AAEXXZ ENDP	; Json::StyledStreamWriter::writeIndent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::pushValue, COMDAT
; _this$ = ecx

; 713  : {

	push	ebp
	mov	ebp, esp

; 714  :    if ( addChildValues_ )

	cmp	BYTE PTR [ecx+68], 0
	je	SHORT $LN2@pushValue

; 718  : }

	pop	ebp

; 715  :       childValues_.push_back( value );

	jmp	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
$LN2@pushValue:

; 716  :    else
; 717  :       *document_ << value;

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [ecx+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8

; 718  : }

	pop	ebp
	ret	4
?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::pushValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
tv851 = -8						; size = 4
_size$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
_lineLength$1$ = -4					; size = 4
$T1 = 8							; size = 1
_value$ = 8						; size = 4
?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledStreamWriter::isMultineArray, COMDAT
; _this$ = ecx

; 682  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 683  :    int size = value.size();

	mov	ecx, DWORD PTR _value$[ebp]
	push	edi
	mov	DWORD PTR _this$1$[ebp], esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 683  :    int size = value.size();

	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	esi
	push	DWORD PTR [esi+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 683  :    int size = value.size();

	mov	DWORD PTR _size$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR [esi]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 684  :    bool isMultiLine = size*3 >= rightMargin_ ;

	lea	edx, DWORD PTR [edi+edi*2]
	cmp	edx, DWORD PTR [esi+40]
	setge	bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 686  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@isMultineA
$LL4@isMultineA:
	test	bl, bl
	jne	$LN16@isMultineA

; 687  :    {
; 688  :       const Value &childValue = value[index];

	mov	ecx, DWORD PTR _value$[ebp]
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	edi, eax

; 689  :       isMultiLine = isMultiLine  ||

	mov	ecx, edi
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	test	al, al
	jne	SHORT $LN10@isMultineA
	mov	ecx, edi
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	test	al, al
	je	SHORT $LN11@isMultineA
$LN10@isMultineA:
	mov	ecx, edi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	test	eax, eax
	jne	SHORT $LN12@isMultineA
$LN11@isMultineA:
	xor	bl, bl
	jmp	SHORT $LN13@isMultineA
$LN12@isMultineA:
	mov	bl, 1
$LN13@isMultineA:

; 686  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	mov	edi, DWORD PTR _size$1$[ebp]
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@isMultineA
$LN3@isMultineA:

; 690  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 691  :                         childValue.size() > 0 );
; 692  :    }
; 693  :    if ( !isMultiLine ) // check if line length > max line length

	test	bl, bl
	jne	$LN16@isMultineA
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx]
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1033 : 		if (capacity() < _Count)

	cmp	eax, edi
	jae	SHORT $LN68@isMultineA

; 1034 : 			{	// something to do, check and reallocate
; 1035 : 			if (max_size() < _Count)

	cmp	edi, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN69@isMultineA

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN482@isMultineA:
$LN69@isMultineA:

; 1037 : 			_Reallocate(_Count);

	push	edi
	mov	ecx, ebx
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN68@isMultineA:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 697  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'

	lea	edx, DWORD PTR [edi*2+2]
	mov	BYTE PTR [ebx+68], 1

; 698  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	esi, esi
	mov	DWORD PTR _lineLength$1$[ebp], edx
	test	edi, edi
	jle	SHORT $LN6@isMultineA

; 694  :    {
; 695  :       childValues_.reserve( size );
; 696  :       addChildValues_ = true;

	mov	DWORD PTR tv851[ebp], esi
	npad	7
$LL7@isMultineA:

; 699  :       {
; 700  :          writeValue( value[index] );

	mov	ecx, DWORD PTR _value$[ebp]
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, ebx
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue

; 701  :          lineLength += int( childValues_[index].length() );

	mov	ecx, DWORD PTR tv851[ebp]
	inc	esi
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR _lineLength$1$[ebp]
	add	edx, DWORD PTR [ecx+eax+16]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _lineLength$1$[ebp], edx
	mov	DWORD PTR tv851[ebp], ecx
	cmp	esi, edi
	jl	SHORT $LL7@isMultineA
$LN6@isMultineA:

; 702  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );
; 703  :       }
; 704  :       addChildValues_ = false;
; 705  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;

	cmp	edx, DWORD PTR [ebx+40]
	mov	BYTE PTR [ebx+68], 0
	setge	bl
$LN16@isMultineA:

; 706  :    }
; 707  :    return isMultiLine;

	pop	edi
	pop	esi
	mov	al, bl
	pop	ebx

; 708  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN481@isMultineA:
?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledStreamWriter::isMultineArray
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv1331 = -92						; size = 4
tv1329 = -88						; size = 4
_value$GSCopy$1$ = -84					; size = 4
_size$1$ = -80						; size = 4
_index$1$ = -76						; size = 4
_childValue$1$ = -72					; size = 4
tv1319 = -68						; size = 4
$T2 = -64						; size = 24
$T3 = -40						; size = 24
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeArrayValue, COMDAT
; _this$ = ecx

; 629  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _value$[ebp]

; 630  :    unsigned size = value.size();

	mov	ecx, esi
	mov	DWORD PTR _value$GSCopy$1$[ebp], esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	ebx, eax
	mov	DWORD PTR _size$1$[ebp], ebx

; 631  :    if ( size == 0 )

	test	ebx, ebx
	jne	SHORT $LN7@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	ecx, DWORD PTR $T4[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T4[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T4[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T4[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 715  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T4[ebp]

; 632  :       pushValue( "[]" );

	mov	DWORD PTR __$EHRec$[ebp+8], ebx

; 715  :       childValues_.push_back( value );

	push	eax
	cmp	BYTE PTR [edi+68], bl
	je	SHORT $LN136@writeArray
	mov	ecx, edi
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 716  :    else

	jmp	SHORT $LN137@writeArray
$LN136@writeArray:

; 717  :       *document_ << value;

	push	DWORD PTR [edi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
$LN137@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	$LN10@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 633  :    else

	jmp	$LN10@writeArray
$LN7@writeArray:

; 634  :    {
; 635  :       bool isArrayMultiLine = isMultineArray( value );

	push	esi
	mov	ecx, edi
	call	?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::isMultineArray

; 636  :       if ( isArrayMultiLine )

	test	al, al
	je	$LN9@writeArray

; 637  :       {
; 638  :          writeWithIndent( "[" );

	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 736  :    *document_ << '\n' << indentString_;

	lea	ebx, DWORD PTR [edi+16]

; 637  :       {
; 638  :          writeWithIndent( "[" );

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 736  :    *document_ << '\n' << indentString_;

	push	ebx
	push	10					; 0000000aH
	push	DWORD PTR [edi+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 744  :    *document_ << value;

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	push	DWORD PTR [edi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 744  :    *document_ << value;

	add	esp, 16					; 00000010H

; 637  :       {
; 638  :          writeWithIndent( "[" );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN254@writeArray

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN254@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 751  :    indentString_ += indentation_;

	lea	eax, DWORD PTR [edi+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	mov	ecx, ebx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [edi]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 641  :          unsigned index =0;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	DWORD PTR tv1331[ebp], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR tv1329[ebp], eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 641  :          unsigned index =0;

	mov	DWORD PTR _index$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	mov	DWORD PTR tv1319[ebp], esi
	npad	7
$LL2@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 644  :             const Value &childValue = value[index];

	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]

; 645  :             writeCommentBeforeValue( childValue );

	push	eax
	mov	ecx, edi
	mov	DWORD PTR _childValue$1$[ebp], eax
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue
	mov	eax, DWORD PTR tv1329[ebp]

; 736  :    *document_ << '\n' << indentString_;

	push	ebx
	push	10					; 0000000aH
	push	DWORD PTR [edi+12]
	cmp	DWORD PTR tv1331[ebp], eax

; 646  :             if ( hasChildValue )

	je	SHORT $LN11@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	esi, DWORD PTR [edi]
	add	esi, DWORD PTR tv1319[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 736  :    *document_ << '\n' << indentString_;

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 744  :    *document_ << value;

	push	esi
	push	DWORD PTR [edi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 647  :                writeWithIndent( childValues_[index] );
; 648  :             else

	mov	esi, DWORD PTR _index$1$[ebp]

; 744  :    *document_ << value;

	add	esp, 16					; 00000010H

; 647  :                writeWithIndent( childValues_[index] );
; 648  :             else

	jmp	SHORT $LN12@writeArray
$LN11@writeArray:

; 736  :    *document_ << '\n' << indentString_;

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8

; 649  :             {
; 650  : 	       writeIndent();
; 651  :                writeValue( childValue );

	mov	ecx, edi
	push	DWORD PTR _childValue$1$[ebp]
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
$LN12@writeArray:

; 652  :             }
; 653  :             if ( ++index == size )

	add	DWORD PTR tv1319[ebp], 24		; 00000018H
	inc	esi
	mov	DWORD PTR _index$1$[ebp], esi
	cmp	esi, DWORD PTR _size$1$[ebp]
	je	SHORT $LN586@writeArray

; 656  :                break;
; 657  :             }
; 658  :             *document_ << ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	DWORD PTR [edi+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 659  :             writeCommentAfterValueOnSameLine( childValue );

	mov	ecx, edi
	push	DWORD PTR _childValue$1$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 660  :          }

	jmp	$LL2@writeArray
$LN586@writeArray:

; 654  :             {
; 655  :                writeCommentAfterValueOnSameLine( childValue );

	push	DWORD PTR _childValue$1$[ebp]
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [edi+32]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 759  :    indentString_.resize( indentString_.size() - indentation_.size() );

	sub	eax, DWORD PTR [edi+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [ebx+16]
	cmp	eax, ecx
	ja	SHORT $LN426@writeArray

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ebx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN448@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN427@writeArray
$LN448@writeArray:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN427@writeArray
$LN426@writeArray:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	sub	eax, ecx
	mov	ecx, ebx
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN427@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 662  :          writeWithIndent( "]" );

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 736  :    *document_ << '\n' << indentString_;

	push	ebx
	push	10					; 0000000aH
	push	DWORD PTR [edi+12]

; 662  :          writeWithIndent( "]" );

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 736  :    *document_ << '\n' << indentString_;

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 744  :    *document_ << value;

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	push	DWORD PTR [edi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 744  :    *document_ << value;

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN10@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 664  :       else // output on a single line

	jmp	SHORT $LN10@writeArray
$LN9@writeArray:

; 665  :       {
; 666  :          assert( childValues_.size() == size );
; 667  :          *document_ << "[ ";

	push	OFFSET ??_C@_02PFNDMDBO@?$FL?5?$AA@
	push	DWORD PTR [edi+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 668  :          for ( unsigned index =0; index < size; ++index )

	xor	esi, esi
	test	ebx, ebx
	je	SHORT $LN5@writeArray

; 665  :       {
; 666  :          assert( childValues_.size() == size );
; 667  :          *document_ << "[ ";

	xor	ebx, ebx
$LL6@writeArray:

; 669  :          {
; 670  :             if ( index > 0 )

	test	esi, esi
	je	SHORT $LN14@writeArray

; 671  :                *document_ << ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	push	DWORD PTR [edi+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN14@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [edi]
	add	eax, ebx
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 672  :             *document_ << childValues_[index];

	push	eax
	push	DWORD PTR [edi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	inc	esi
	add	esp, 8
	add	ebx, 24					; 00000018H
	cmp	esi, DWORD PTR _size$1$[ebp]
	jb	SHORT $LL6@writeArray
$LN5@writeArray:

; 673  :          }
; 674  :          *document_ << " ]";

	push	OFFSET ??_C@_02DHOGEDBE@?5?$FN?$AA@
	push	DWORD PTR [edi+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN10@writeArray:

; 675  :       }
; 676  :    }
; 677  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeArrayValue
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_members$2 = -84					; size = 12
_value$GSCopy$1$ = -72					; size = 4
_childValue$1$ = -68					; size = 4
$T3 = -64						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
$T8 = -40						; size = 24
$T9 = -40						; size = 24
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeValue, COMDAT
; _this$ = ecx

; 568  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _value$[ebp]

; 569  :    switch ( value.type() )

	mov	ecx, edi
	mov	DWORD PTR _value$GSCopy$1$[ebp], edi
	call	?type@Value@Json@@QBE?AW4ValueType@2@XZ	; Json::Value::type
	cmp	eax, 7
	ja	$LN2@writeValue
	jmp	DWORD PTR $LN273@writeValue[eax*4]
$LN6@writeValue:

; 570  :    {
; 571  :    case nullValue:
; 572  :       pushValue( "null" );

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 715  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T12[ebp]
$LN272@writeValue:

; 625  : 
; 626  : 
; 627  : void 
; 628  : StyledStreamWriter::writeArrayValue( const Value &value )
; 629  : {
; 630  :    unsigned size = value.size();
; 631  :    if ( size == 0 )
; 632  :       pushValue( "[]" );
; 633  :    else
; 634  :    {
; 635  :       bool isArrayMultiLine = isMultineArray( value );
; 636  :       if ( isArrayMultiLine )
; 637  :       {
; 638  :          writeWithIndent( "[" );
; 639  :          indent();
; 640  :          bool hasChildValue = !childValues_.empty();
; 641  :          unsigned index =0;
; 642  :          while ( true )
; 643  :          {
; 644  :             const Value &childValue = value[index];
; 645  :             writeCommentBeforeValue( childValue );
; 646  :             if ( hasChildValue )
; 647  :                writeWithIndent( childValues_[index] );
; 648  :             else
; 649  :             {
; 650  : 	       writeIndent();
; 651  :                writeValue( childValue );
; 652  :             }
; 653  :             if ( ++index == size )
; 654  :             {
; 655  :                writeCommentAfterValueOnSameLine( childValue );
; 656  :                break;
; 657  :             }
; 658  :             *document_ << ",";
; 659  :             writeCommentAfterValueOnSameLine( childValue );
; 660  :          }
; 661  :          unindent();
; 662  :          writeWithIndent( "]" );
; 663  :       }
; 664  :       else // output on a single line
; 665  :       {
; 666  :          assert( childValues_.size() == size );
; 667  :          *document_ << "[ ";
; 668  :          for ( unsigned index =0; index < size; ++index )
; 669  :          {
; 670  :             if ( index > 0 )
; 671  :                *document_ << ", ";
; 672  :             *document_ << childValues_[index];
; 673  :          }
; 674  :          *document_ << " ]";
; 675  :       }
; 676  :    }
; 677  : }
; 678  : 
; 679  : 
; 680  : bool 
; 681  : StyledStreamWriter::isMultineArray( const Value &value )
; 682  : {
; 683  :    int size = value.size();
; 684  :    bool isMultiLine = size*3 >= rightMargin_ ;
; 685  :    childValues_.clear();
; 686  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )
; 687  :    {
; 688  :       const Value &childValue = value[index];
; 689  :       isMultiLine = isMultiLine  ||
; 690  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 691  :                         childValue.size() > 0 );
; 692  :    }
; 693  :    if ( !isMultiLine ) // check if line length > max line length
; 694  :    {
; 695  :       childValues_.reserve( size );
; 696  :       addChildValues_ = true;
; 697  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'
; 698  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )
; 699  :       {
; 700  :          writeValue( value[index] );
; 701  :          lineLength += int( childValues_[index].length() );
; 702  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );
; 703  :       }
; 704  :       addChildValues_ = false;
; 705  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;
; 706  :    }
; 707  :    return isMultiLine;
; 708  : }
; 709  : 
; 710  : 
; 711  : void 
; 712  : StyledStreamWriter::pushValue( const std::string &value )
; 713  : {
; 714  :    if ( addChildValues_ )

	cmp	BYTE PTR [ebx+68], 0

; 715  :       childValues_.push_back( value );

	push	eax
	je	SHORT $LN30@writeValue
	mov	ecx, ebx
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 570  :    {
; 571  :    case nullValue:
; 572  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 573  :       break;

	jmp	$LN2@writeValue
$LN30@writeValue:

; 717  :       *document_ << value;

	push	DWORD PTR [ebx+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8

; 570  :    {
; 571  :    case nullValue:
; 572  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 573  :       break;

	jmp	$LN2@writeValue
$LN7@writeValue:

; 574  :    case intValue:
; 575  :       pushValue( valueToString( value.asInt() ) );

	mov	ecx, edi
	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 716  :    else

	jmp	SHORT $LN272@writeValue
$LN8@writeValue:

; 576  :       break;
; 577  :    case uintValue:
; 578  :       pushValue( valueToString( value.asUInt() ) );

	mov	ecx, edi
	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 716  :    else

	jmp	SHORT $LN272@writeValue
$LN9@writeValue:

; 579  :       break;
; 580  :    case realValue:
; 581  :       pushValue( valueToString( value.asDouble() ) );

	mov	ecx, edi
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	lea	eax, DWORD PTR $T9[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 716  :    else

	jmp	$LN272@writeValue
$LN10@writeValue:

; 582  :       break;
; 583  :    case stringValue:
; 584  :       pushValue( valueToQuotedString( value.asCString() ) );

	mov	ecx, edi
	call	?asCString@Value@Json@@QBEPBDXZ		; Json::Value::asCString
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 716  :    else

	jmp	$LN272@writeValue
$LN11@writeValue:

; 585  :       break;
; 586  :    case booleanValue:
; 587  :       pushValue( valueToString( value.asBool() ) );

	mov	ecx, edi
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	eax, al
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 716  :    else

	jmp	$LN272@writeValue
$LN12@writeValue:

; 588  :       break;
; 589  :    case arrayValue:
; 590  :       writeArrayValue( value);

	push	edi
	mov	ecx, ebx
	call	?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeArrayValue

; 591  :       break;

	jmp	$LN2@writeValue
$LN13@writeValue:

; 594  :          Value::Members members( value.getMemberNames() );

	lea	eax, DWORD PTR _members$2[ebp]
	mov	ecx, edi
	push	eax
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR _members$2[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 596  :             pushValue( "{}" );

	lea	ecx, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	cmp	eax, DWORD PTR _members$2[ebp+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 594  :          Value::Members members( value.getMemberNames() );

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	sete	al
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 595  :          if ( members.empty() )

	test	al, al
	je	SHORT $LN14@writeValue

; 596  :             pushValue( "{}" );

	push	OFFSET ??_C@_02MCILKGOH@?$HL?$HN?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T6[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	mov	ecx, ebx
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	lea	ecx, DWORD PTR $T6[ebp]

; 597  :          else

	jmp	$LN271@writeValue
$LN14@writeValue:

; 598  :          {
; 599  :             writeWithIndent( "{" );

	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	eax
	mov	ecx, ebx
	call	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
	lea	ecx, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 751  :    indentString_ += indentation_;

	lea	eax, DWORD PTR [ebx+44]
	lea	ecx, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 46   : 		: _Ptr(_Parg)

	mov	esi, DWORD PTR _members$2[ebp]
	npad	2
$LL4@writeValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 605  :                const Value &childValue = value[name];

	push	esi
	mov	ecx, edi
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]

; 606  :                writeCommentBeforeValue( childValue );

	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _childValue$1$[ebp], eax
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN121@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN122@writeValue
$LN121@writeValue:
	mov	eax, esi
$LN122@writeValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 607  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	edi, eax

; 736  :    *document_ << '\n' << indentString_;

	lea	eax, DWORD PTR [ebx+16]

; 607  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 736  :    *document_ << '\n' << indentString_;

	push	eax
	push	10					; 0000000aH
	push	DWORD PTR [ebx+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 744  :    *document_ << value;

	push	edi
	push	DWORD PTR [ebx+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T4[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 744  :    *document_ << value;

	add	esp, 16					; 00000010H

; 607  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN135@writeValue

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN135@writeValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 608  :                *document_ << " : ";

	push	OFFSET ??_C@_03MCPBMLDJ@?5?3?5?$AA@
	push	DWORD PTR [ebx+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 609  :                writeValue( childValue );

	mov	edi, DWORD PTR _childValue$1$[ebp]
	add	esp, 8
	mov	ecx, ebx
	push	edi
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 113  : 		++_Ptr;

	add	esi, 24					; 00000018H

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR _members$2[ebp+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 610  :                if ( ++it == members.end() )

	je	SHORT $LN267@writeValue

; 613  :                   break;
; 614  :                }
; 615  :                *document_ << ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	DWORD PTR [ebx+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 616  :                writeCommentAfterValueOnSameLine( childValue );

	mov	ecx, ebx
	push	edi
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 617  :             }

	mov	edi, DWORD PTR _value$GSCopy$1$[ebp]
	jmp	$LL4@writeValue
$LN267@writeValue:

; 611  :                {
; 612  :                   writeCommentAfterValueOnSameLine( childValue );

	push	edi
	mov	ecx, ebx
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 618  :             unindent();

	mov	ecx, ebx
	call	?unindent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::unindent

; 619  :             writeWithIndent( "}" );

	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	push	eax
	mov	ecx, ebx
	call	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
	lea	ecx, DWORD PTR $T3[ebp]
$LN271@writeValue:
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 620  :          }
; 621  :       }

	lea	ecx, DWORD PTR _members$2[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN2@writeValue:

; 622  :       break;
; 623  :    }
; 624  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN273@writeValue:
	DD	$LN6@writeValue
	DD	$LN7@writeValue
	DD	$LN8@writeValue
	DD	$LN9@writeValue
	DD	$LN10@writeValue
	DD	$LN11@writeValue
	DD	$LN12@writeValue
	DD	$LN13@writeValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR _members$2[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$7:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$8:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$9:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$10:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeValue
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_root$ = 12						; size = 4
?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z PROC ; Json::StyledStreamWriter::write, COMDAT
; _this$ = ecx

; 554  : {

	push	ebp
	mov	ebp, esp

; 555  :    document_ = &out;

	mov	eax, DWORD PTR _out$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 557  :    indentString_ = "";

	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+12], eax
	mov	BYTE PTR [edi+68], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 558  :    writeCommentBeforeValue( root );

	mov	esi, DWORD PTR _root$[ebp]
	mov	ecx, edi
	push	esi
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue

; 559  :    writeValue( root );

	push	esi
	mov	ecx, edi
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue

; 560  :    writeCommentAfterValueOnSameLine( root );

	push	esi
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 561  :    *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	DWORD PTR [edi+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 562  :    document_ = NULL; // Forget the stream, for safety.

	mov	DWORD PTR [edi+12], 0
	pop	edi
	pop	esi

; 563  : }

	pop	ebp
	ret	8
?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z ENDP ; Json::StyledStreamWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
;	COMDAT ??1StyledStreamWriter@Json@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
??1StyledStreamWriter@Json@@QAE@XZ PROC			; Json::StyledStreamWriter::~StyledStreamWriter, COMDAT
; _this$ = ecx

; 126  :       ~StyledStreamWriter(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+64]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 126  :       ~StyledStreamWriter(){}

	lea	esi, DWORD PTR [edi+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@StyledStre
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN9@StyledStre:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@StyledStre
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN101@StyledStre:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 126  :       ~StyledStreamWriter(){}

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN114@StyledStre
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN114@StyledStre:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN206@StyledStre
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN206@StyledStre:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN217@StyledStre
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
	push	edi
	push	DWORD PTR [edi+4]
	push	eax
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	esi, DWORD PTR [edi]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	esi
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+8], 0
$LN217@StyledStre:
	pop	edi
	pop	esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 126  :       ~StyledStreamWriter(){}

	mov	esp, ebp
	pop	ebp
	ret	0
??1StyledStreamWriter@Json@@QAE@XZ ENDP			; Json::StyledStreamWriter::~StyledStreamWriter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_indentation$ = 8					; size = 24
??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::StyledStreamWriter, COMDAT
; _this$ = ecx

; 548  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR _this$GSCopy$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+8], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 548  : {

	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN121@StyledStre
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN121@StyledStre:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 547  :    , indentation_( indentation )

	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+40], 74			; 0000004aH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	0
	lea	eax, DWORD PTR _indentation$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 548  : {

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _indentation$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN361@StyledStre
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _indentation$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN361@StyledStre:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 549  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _indentation$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::StyledStreamWriter
; Function compile flags: /Ogtp
;	COMDAT ??_GStyledWriter@Json@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GStyledWriter@Json@@UAEPAXI@Z PROC			; Json::StyledWriter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1StyledWriter@Json@@UAE@XZ		; Json::StyledWriter::~StyledWriter
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	76					; 0000004cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GStyledWriter@Json@@UAEPAXI@Z ENDP			; Json::StyledWriter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		}

	ret	8
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT
; _this$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	edi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
	push	edi
	push	DWORD PTR [edi+4]
	push	eax
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [edi]
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [edi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+8], 0
$LN2@Tidy:
	pop	edi

; 1646 : 			}
; 1647 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
tv289 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, 715827883				; 2aaaaaabH
	push	esi
	push	edi

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	edi, DWORD PTR __Count$[ebp]

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	sub	edx, esi
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, edi
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx]
	sub	esi, eax
	mov	DWORD PTR tv289[ebp], eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	esi

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, 178956970				; 0aaaaaaaH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN135@Reserve:
$LN3@Reserve:

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edi, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR tv289[ebp]
	imul	ecx
	xor	ecx, ecx
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 178956970				; 0aaaaaaaH
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	add	eax, esi
	cmp	edx, esi
	cmovae	ecx, eax
	cmp	ecx, edi
	cmovae	edi, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, ebx
	push	edi
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN2@Reserve:
	pop	edi
	pop	esi
	pop	ebx

; 1632 : 			}
; 1633 : 		}

	pop	ebp
	ret	4
$LN134@Reserve:
?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
__Size$1$ = -20						; size = 4
$T2 = -20						; size = 1
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	DWORD PTR __Count$[ebp]
	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	DWORD PTR __Ptr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	edi
	push	ebx
	push	DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1604 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR [edi]
	call	??$_Uninitialized_move_al_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [edi]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	ecx, esi
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR __Size$1$[ebp], ecx

; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	esi, esi
	je	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T3[ebp]
	push	edi
	push	DWORD PTR [edi+4]
	push	esi
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	esi, DWORD PTR [edi]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	esi
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	mov	ecx, DWORD PTR __Size$1$[ebp]
	add	esp, 28					; 0000001cH
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ebx+eax*8]
	mov	DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [ebx+eax*8]
	mov	DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [edi], ebx

; 1623 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1608 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN194@Reallocate:
$LN193@Reallocate:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN3@Inside
	cmp	DWORD PTR [ecx], eax
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1598 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	xor	al, al

; 1598 : 		}

	pop	ebp
	ret	4
?_Inside@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEII@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	push	esi
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 178956970				; 0aaaaaaaH
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[ebp]
	cmovb	eax, DWORD PTR __Count$[ebp]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	pop	ebp
	ret	4
?_Grow_to@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEII@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
$T1 = 12						; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1582 : 		}

	pop	ebp
	ret	8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT
; _this$ = ecx

; 1539 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1539 : 		{	// erase all

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	esi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax
	pop	esi

; 1543 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
$T5 = 8							; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	edi, DWORD PTR __Val$[ebp]
	cmp	edi, ecx
	jae	SHORT $LN2@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	eax, edi
	ja	SHORT $LN2@push_back

; 1277 : 		if (_Inside(_STD addressof(_Val)))
; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	edi, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edi
	sar	edx, 2
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	push	1
	mov	ecx, esi
	call	?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
$LN4@push_back:

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	lea	eax, DWORD PTR [eax+ecx*8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edx, edx
	je	SHORT $LN339@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 15			; 0000000fH

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, edx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1287 : 		else

	jmp	SHORT $LN487@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	push	1
	mov	ecx, esi
	call	?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	ecx, ecx
	je	SHORT $LN339@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	edi
$LN487@push_back:
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN339@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 24			; 00000018H

; 1295 : 			}
; 1296 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$33:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$88:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*8]

; 1243 : 		}

	pop	ebp
	ret	4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty, COMDAT
; _this$ = ecx

; 1189 : 		{	// test if sequence is empty

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1190 : 		return (this->_Myfirst() == this->_Mylast());
; 1191 : 		}

	ret	0
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1181 : 		}

	ret	0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 1067 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1069 : 		}

	pop	ebp
	ret	4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1059 : 		}

	pop	ebp
	ret	4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx+4]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1044 : 		}

	ret	0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve, COMDAT
; _this$ = ecx

; 1032 : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH

; 1033 : 		if (capacity() < _Count)

	mov	ecx, DWORD PTR __Count$[ebp]

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+8]
	sub	edx, DWORD PTR [esi]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1033 : 		if (capacity() < _Count)

	cmp	eax, ecx
	jae	SHORT $LN2@reserve

; 1034 : 			{	// something to do, check and reallocate
; 1035 : 			if (max_size() < _Count)

	cmp	ecx, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN3@reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN49@reserve:
$LN3@reserve:

; 1036 : 				_Xlen();
; 1037 : 			_Reallocate(_Count);

	push	ecx
	mov	ecx, esi
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN2@reserve:
	pop	esi

; 1038 : 			}
; 1039 : 		}

	pop	ebp
	ret	4
$LN48@reserve:
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	edi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
	push	edi
	push	DWORD PTR [edi+4]
	push	eax
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [edi]
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [edi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+8], 0
$LN4@vector:
	pop	edi

; 976  : 		_Tidy();
; 977  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_all, COMDAT
; _this$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 178956970				; 0aaaaaaaH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 178956970				; 0aaaaaaaH

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT
_end$1$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
tv1407 = 12						; size = 4
_text$ = 12						; size = 4
_c$1$ = 15						; size = 1
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z PROC ; Json::StyledWriter::normalizeEOL, COMDAT

; 519  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN114@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN115@normalizeE
$LN114@normalizeE:
	mov	eax, esi
$LN115@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	ebx, DWORD PTR _text$[ebp]

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ebx+16]

; 729  : 		return (_Get_data()._Mysize);

	lea	ecx, DWORD PTR [ebx+16]

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	edi, DWORD PTR [esi+16]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 537  :    return normalized;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	DWORD PTR tv1407[ebp], ecx

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	edi, eax
	ja	SHORT $LN179@normalizeE
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN179@normalizeE

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, esi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN573@normalizeE

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN174@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN175@normalizeE
$LN174@normalizeE:
	mov	eax, esi
$LN175@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN573@normalizeE:
	mov	ecx, DWORD PTR tv1407[ebp]
$LN179@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN195@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN195@normalizeE:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 523  :    const char *end = begin + text.length();

	mov	eax, DWORD PTR [ecx]
	add	eax, ebx
	mov	DWORD PTR _end$1$[ebp], eax

; 525  :    while ( current != end )

	cmp	ebx, eax
	je	$LN3@normalizeE
	npad	2
$LL2@normalizeE:

; 527  :       char c = *current++;

	mov	dl, BYTE PTR [ebx]
	mov	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ecx, DWORD PTR [esi+16]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 527  :       char c = *current++;

	inc	ebx
	mov	BYTE PTR _c$1$[ebp], dl

; 528  :       if ( c == '\r' ) // mac or dos EOL

	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN4@normalizeE
	cmp	BYTE PTR [ebx], 10			; 0000000aH
	cmovne	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
	inc	ebx
	cmp	eax, 1
	jbe	$LN567@normalizeE

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+1]

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN567@normalizeE

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN239@normalizeE

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	$LN562@normalizeE
$LN577@normalizeE:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	mov	ecx, DWORD PTR [esi+16]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN346@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN347@normalizeE
$LN239@normalizeE:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN577@normalizeE

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN580@normalizeE
$LN346@normalizeE:
	mov	eax, esi
$LN347@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 10			; 0000000aH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN557@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN558@normalizeE
$LN4@normalizeE:

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
	cmp	eax, 1
	jbe	SHORT $LN567@normalizeE

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+1]

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	SHORT $LN567@normalizeE

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN417@normalizeE

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	dl, BYTE PTR _c$1$[ebp]

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN562@normalizeE
$LN579@normalizeE:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	mov	ecx, DWORD PTR [esi+16]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN524@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN525@normalizeE
$LN417@normalizeE:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN579@normalizeE
$LN580@normalizeE:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN494@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	jmp	SHORT $LN562@normalizeE
$LN494@normalizeE:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	jmp	SHORT $LN562@normalizeE
$LN524@normalizeE:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
$LN525@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], dl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN557@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN558@normalizeE
$LN557@normalizeE:
	mov	eax, esi
$LN558@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN562@normalizeE:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 525  :    while ( current != end )

	cmp	ebx, DWORD PTR _end$1$[ebp]
	jne	$LL2@normalizeE
$LN3@normalizeE:

; 537  :    return normalized;

	mov	eax, esi

; 538  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN567@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN581@normalizeE:
$LN575@normalizeE:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN9@normalizeE
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@normalizeE:
	ret	0
__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ENDP ; Json::StyledWriter::normalizeEOL
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledWriter::hasCommentForValue, COMDAT
; _this$ = ecx

; 510  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 511  :    return value.hasComment( commentBefore )

	mov	esi, DWORD PTR _value$[ebp]
	mov	ecx, esi
	push	0
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	jne	SHORT $LN3@hasComment
	push	1
	mov	ecx, esi
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	jne	SHORT $LN3@hasComment
	push	2
	mov	ecx, esi
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	jne	SHORT $LN3@hasComment
	pop	esi

; 512  :           ||  value.hasComment( commentAfterOnSameLine )
; 513  :           ||  value.hasComment( commentAfter );
; 514  : }

	pop	ebp
	ret	4
$LN3@hasComment:

; 511  :    return value.hasComment( commentBefore )

	mov	al, 1
	pop	esi

; 512  :           ||  value.hasComment( commentAfterOnSameLine )
; 513  :           ||  value.hasComment( commentAfter );
; 514  : }

	pop	ebp
	ret	4
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::hasCommentForValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T2 = -136						; size = 24
$T3 = -112						; size = 24
$T4 = -88						; size = 24
$T5 = -64						; size = 24
$T6 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeCommentAfterValueOnSameLine, COMDAT
; _this$ = ecx

; 495  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _root$[ebp]

; 496  :    if ( root.hasComment( commentAfterOnSameLine ) )

	mov	ecx, esi
	push	1
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	je	$LN230@writeComme

; 497  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	push	1
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, esi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 497  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	lea	ecx, DWORD PTR [edi+16]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T6[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN20@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T6[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN20@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T5[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T6[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T6[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T6[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN125@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN125@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T5[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T5[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T5[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 497  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN230@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN230@writeComme:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 499  :    if ( root.hasComment( commentAfter ) )

	push	2
	mov	ecx, esi
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	je	$LN3@writeComme
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 501  :       document_ += "\n";

	add	edi, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 502  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	push	2
	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, esi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	eax
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 502  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN347@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN347@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T4[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T4[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T4[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 502  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN452@writeComme
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN452@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN3@writeComme:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 505  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentAfterValueOnSameLine
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeCommentBeforeValue, COMDAT
; _this$ = ecx

; 485  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _root$[ebp]

; 486  :    if ( !root.hasComment( commentBefore ) )

	mov	ecx, esi
	push	0
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	test	al, al
	je	$LN1@writeComme

; 488  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	push	0
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, esi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR [edi+16]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 488  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@writeComme

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN16@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 488  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN121@writeComme
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN121@writeComme:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	lea	ecx, DWORD PTR [edi+16]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN1@writeComme:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 490  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentBeforeValue
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?unindent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?unindent@StyledWriter@Json@@AAEXXZ PROC		; Json::StyledWriter::unindent, COMDAT
; _this$ = ecx

; 478  :    assert( int(indentString_.size()) >= indentSize_ );
; 479  :    indentString_.resize( indentString_.size() - indentSize_ );

	mov	eax, DWORD PTR [ecx+56]
	sub	eax, DWORD PTR [ecx+68]
	add	ecx, 40					; 00000028H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, edx
	ja	SHORT $LN18@unindent

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN41@unindent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN41@unindent:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 480  : }

	ret	0
$LN18@unindent:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 480  : }

	ret	0
?unindent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::unindent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?indent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?indent@StyledWriter@Json@@AAEXXZ PROC			; Json::StyledWriter::indent, COMDAT
; _this$ = ecx

; 470  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?indent@StyledWriter@Json@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 852  : 		assign(_Count, _Ch);

	push	32					; 00000020H
	push	DWORD PTR [esi+68]
	lea	ecx, DWORD PTR $T2[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 852  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 471  :    indentString_ += std::string( indentSize_, ' ' );

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 471  :    indentString_ += std::string( indentSize_, ' ' );

	lea	ecx, DWORD PTR [esi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN124@indent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN124@indent:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 472  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?indent@StyledWriter@Json@@AAEXXZ$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?indent@StyledWriter@Json@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?indent@StyledWriter@Json@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?indent@StyledWriter@Json@@AAEXXZ ENDP			; Json::StyledWriter::indent
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::writeWithIndent, COMDAT
; _this$ = ecx

; 462  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1804 : 		return (this->_Mysize() == 0);

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 448  :    if ( !document_.empty() )

	je	SHORT $LN6@writeWithI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+36], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 315  : 		return (_Myval2);

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN44@writeWithI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN45@writeWithI
$LN44@writeWithI:
	mov	ecx, esi
$LN45@writeWithI:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 450  :       char last = document_[document_.length()-1];

	mov	al, BYTE PTR [ecx+eax-1]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN3@writeWithI

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN6@writeWithI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	10					; 0000000aH
	push	1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN6@writeWithI:

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 456  :    document_ += indentString_;

	lea	eax, DWORD PTR [edi+40]
	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN3@writeWithI:
	push	-1
	push	0
	push	DWORD PTR _value$[ebp]
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 465  : }

	pop	ebp
	ret	4
?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::writeWithIndent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeIndent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?writeIndent@StyledWriter@Json@@AAEXXZ PROC		; Json::StyledWriter::writeIndent, COMDAT
; _this$ = ecx

; 447  : {

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1804 : 		return (this->_Mysize() == 0);

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 448  :    if ( !document_.empty() )

	je	SHORT $LN4@writeInden
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+36], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 315  : 		return (_Myval2);

	lea	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN42@writeInden
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN43@writeInden
$LN42@writeInden:
	mov	edx, ecx
$LN43@writeInden:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 450  :       char last = document_[document_.length()-1];

	mov	al, BYTE PTR [edx+eax-1]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN1@writeInden

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN4@writeInden
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	10					; 0000000aH
	push	1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN4@writeInden:

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 456  :    document_ += indentString_;

	lea	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN1@writeInden:
	pop	esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 457  : }

	ret	0
?writeIndent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::writeIndent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::pushValue, COMDAT
; _this$ = ecx

; 437  : {

	push	ebp
	mov	ebp, esp

; 438  :    if ( addChildValues_ )

	cmp	BYTE PTR [ecx+72], 0
	je	SHORT $LN2@pushValue

; 439  :       childValues_.push_back( value );

	add	ecx, 4

; 442  : }

	pop	ebp

; 439  :       childValues_.push_back( value );

	jmp	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
$LN2@pushValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR _value$[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 441  :       document_ += value;

	add	ecx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 442  : }

	pop	ebp
	ret	4
?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::pushValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
_lineLength$1$ = -12					; size = 4
_size$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
$T1 = 8							; size = 1
_value$ = 8						; size = 4
?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledWriter::isMultineArray, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 407  :    int size = value.size();

	mov	ecx, DWORD PTR _value$[ebp]
	push	edi
	mov	DWORD PTR _this$1$[ebp], esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 407  :    int size = value.size();

	mov	edi, eax
	mov	DWORD PTR _size$1$[ebp], edi

; 408  :    bool isMultiLine = size*3 >= rightMargin_ ;

	lea	edx, DWORD PTR [edi+edi*2]
	cmp	edx, DWORD PTR [esi+64]
	setge	bl

; 409  :    childValues_.clear();

	add	esi, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 409  :    childValues_.clear();

	mov	DWORD PTR _this$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 410  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@isMultineA
$LL4@isMultineA:
	test	bl, bl
	jne	$LN16@isMultineA

; 411  :    {
; 412  :       const Value &childValue = value[index];

	mov	ecx, DWORD PTR _value$[ebp]
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	edi, eax

; 413  :       isMultiLine = isMultiLine  ||

	mov	ecx, edi
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	test	al, al
	jne	SHORT $LN10@isMultineA
	mov	ecx, edi
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	test	al, al
	je	SHORT $LN11@isMultineA
$LN10@isMultineA:
	mov	ecx, edi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	test	eax, eax
	jne	SHORT $LN12@isMultineA
$LN11@isMultineA:
	xor	bl, bl
	jmp	SHORT $LN13@isMultineA
$LN12@isMultineA:
	mov	bl, 1
$LN13@isMultineA:

; 410  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	mov	edi, DWORD PTR _size$1$[ebp]
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@isMultineA
$LN3@isMultineA:

; 414  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 415  :                         childValue.size() > 0 );
; 416  :    }
; 417  :    if ( !isMultiLine ) // check if line length > max line length

	test	bl, bl
	jne	$LN16@isMultineA
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx]
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1033 : 		if (capacity() < _Count)

	cmp	eax, edi
	jae	SHORT $LN68@isMultineA

; 1034 : 			{	// something to do, check and reallocate
; 1035 : 			if (max_size() < _Count)

	cmp	edi, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN69@isMultineA

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN536@isMultineA:
$LN69@isMultineA:

; 1037 : 			_Reallocate(_Count);

	push	edi
	mov	ecx, ebx
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN68@isMultineA:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 420  :       addChildValues_ = true;

	mov	eax, DWORD PTR _this$1$[ebp]

; 421  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'

	lea	ecx, DWORD PTR [edi*2+2]

; 422  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	esi, esi
	mov	DWORD PTR _lineLength$1$[ebp], ecx
	mov	BYTE PTR [eax+72], 1
	test	edi, edi
	jle	SHORT $LN6@isMultineA

; 420  :       addChildValues_ = true;

	xor	ebx, ebx
$LL7@isMultineA:

; 423  :       {
; 424  :          writeValue( value[index] );

	mov	ecx, DWORD PTR _value$[ebp]
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 425  :          lineLength += int( childValues_[index].length() );

	mov	ecx, DWORD PTR _this$1$[ebp]
	inc	esi
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lineLength$1$[ebp]
	add	ecx, DWORD PTR [ebx+eax+16]
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _lineLength$1$[ebp], ecx
	cmp	esi, edi
	jl	SHORT $LL7@isMultineA
	mov	eax, DWORD PTR _this$1$[ebp]
$LN6@isMultineA:

; 426  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );
; 427  :       }
; 428  :       addChildValues_ = false;
; 429  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;

	cmp	ecx, DWORD PTR [eax+64]
	mov	BYTE PTR [eax+72], 0
	setge	bl
$LN16@isMultineA:

; 430  :    }
; 431  :    return isMultiLine;

	pop	edi
	pop	esi
	mov	al, bl
	pop	ebx

; 432  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN535@isMultineA:
?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::isMultineArray
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv1657 = -92						; size = 4
_value$GSCopy$1$ = -88					; size = 4
_size$1$ = -84						; size = 4
_index$1$ = -80						; size = 4
tv1658 = -76						; size = 4
tv1647 = -76						; size = 4
_childValue$1$ = -72					; size = 4
tv1637 = -68						; size = 4
$T2 = -64						; size = 24
$T3 = -40						; size = 24
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeArrayValue, COMDAT
; _this$ = ecx

; 353  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	edi, DWORD PTR _value$[ebp]

; 354  :    unsigned size = value.size();

	mov	ecx, edi
	mov	DWORD PTR _value$GSCopy$1$[ebp], edi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	ebx, eax
	mov	DWORD PTR _size$1$[ebp], ebx

; 355  :    if ( size == 0 )

	test	ebx, ebx
	jne	SHORT $LN7@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	ecx, DWORD PTR $T4[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T4[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T4[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T4[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 439  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T4[ebp]

; 356  :       pushValue( "[]" );

	mov	DWORD PTR __$EHRec$[ebp+8], ebx

; 438  :    if ( addChildValues_ )

	cmp	BYTE PTR [esi+72], bl
	je	SHORT $LN136@writeArray

; 439  :       childValues_.push_back( value );

	lea	ecx, DWORD PTR [esi+4]
	push	eax
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 440  :    else

	jmp	SHORT $LN137@writeArray
$LN136@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 441  :       document_ += value;

	lea	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN137@writeArray:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	$LN10@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 357  :    else

	jmp	$LN10@writeArray
$LN7@writeArray:

; 358  :    {
; 359  :       bool isArrayMultiLine = isMultineArray( value );

	push	edi
	mov	ecx, esi
	call	?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::isMultineArray

; 360  :       if ( isArrayMultiLine )

	test	al, al
	je	$LN667@writeArray

; 362  :          writeWithIndent( "[" );

	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	mov	ecx, esi
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 362  :          writeWithIndent( "[" );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN254@writeArray

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN254@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 363  :          indent();

	mov	ecx, esi
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 365  :          unsigned index =0;

	xor	ebx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	DWORD PTR tv1658[ebp], eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 363  :          indent();

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv1657[ebp], eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 365  :          unsigned index =0;

	mov	DWORD PTR _index$1$[ebp], ebx
	mov	DWORD PTR tv1637[ebp], edi
	npad	4
$LL2@writeArray:

; 366  :          while ( true )
; 367  :          {
; 368  :             const Value &childValue = value[index];

	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	push	ebx
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]

; 369  :             writeCommentBeforeValue( childValue );

	push	eax
	mov	ecx, esi
	mov	DWORD PTR _childValue$1$[ebp], eax
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
	mov	eax, DWORD PTR tv1657[ebp]
	cmp	DWORD PTR tv1658[ebp], eax

; 370  :             if ( hasChildValue )

	je	SHORT $LN11@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ebx, DWORD PTR [esi+4]
	add	ebx, edi
	cmp	DWORD PTR [esi+32], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 320  : 		return (_Myval2);

	lea	edi, DWORD PTR [esi+16]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 448  :    if ( !document_.empty() )

	je	SHORT $LN390@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 1760 : 		return (this->_Mysize());

	mov	ecx, DWORD PTR [esi+32]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN428@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN429@writeArray
$LN428@writeArray:
	mov	eax, edi
$LN429@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 450  :       char last = document_[document_.length()-1];

	mov	al, BYTE PTR [eax+ecx-1]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN387@writeArray

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN390@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	10					; 0000000aH
	push	1
	mov	ecx, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN390@writeArray:

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 456  :    document_ += indentString_;

	lea	eax, DWORD PTR [esi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	mov	ecx, edi
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN387@writeArray:
	push	-1
	push	0
	push	ebx
	mov	ecx, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 372  :             else

	mov	ebx, DWORD PTR _index$1$[ebp]
	jmp	SHORT $LN12@writeArray
$LN11@writeArray:
	cmp	DWORD PTR [esi+32], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 320  : 		return (_Myval2);

	lea	edi, DWORD PTR [esi+16]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 448  :    if ( !document_.empty() )

	je	SHORT $LN445@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 1760 : 		return (this->_Mysize());

	mov	ecx, DWORD PTR [esi+32]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN483@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN484@writeArray
$LN483@writeArray:
	mov	eax, edi
$LN484@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 450  :       char last = document_[document_.length()-1];

	mov	al, BYTE PTR [eax+ecx-1]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN442@writeArray

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN445@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	10					; 0000000aH
	push	1
	mov	ecx, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN445@writeArray:

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 456  :    document_ += indentString_;

	lea	eax, DWORD PTR [esi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	mov	ecx, edi
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN442@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 375  :                writeValue( childValue );

	push	DWORD PTR _childValue$1$[ebp]
	mov	ecx, esi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
$LN12@writeArray:

; 376  :             }
; 377  :             if ( ++index == size )

	add	DWORD PTR tv1637[ebp], 24		; 00000018H
	inc	ebx
	mov	DWORD PTR _index$1$[ebp], ebx
	cmp	ebx, DWORD PTR _size$1$[ebp]
	je	SHORT $LN702@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 383  :             writeCommentAfterValueOnSameLine( childValue );

	push	DWORD PTR _childValue$1$[ebp]
	mov	ecx, esi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 384  :          }

	mov	edi, DWORD PTR tv1637[ebp]
	jmp	$LL2@writeArray
$LN702@writeArray:

; 378  :             {
; 379  :                writeCommentAfterValueOnSameLine( childValue );

	push	DWORD PTR _childValue$1$[ebp]
	mov	ecx, esi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [esi+56]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 479  :    indentString_.resize( indentString_.size() - indentSize_ );

	lea	ecx, DWORD PTR [esi+40]
	sub	eax, DWORD PTR [esi+68]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, edx
	ja	SHORT $LN518@writeArray

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN541@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN541@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN519@writeArray
$LN518@writeArray:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN519@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 386  :          writeWithIndent( "]" );

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	eax
	mov	ecx, esi
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN10@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 388  :       else // output on a single line

	jmp	SHORT $LN10@writeArray
$LN667@writeArray:

; 391  :          document_ += "[ ";

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02PFNDMDBO@?$FL?5?$AA@
	mov	ecx, eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 391  :          document_ += "[ ";

	mov	DWORD PTR tv1647[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 392  :          for ( unsigned index =0; index < size; ++index )

	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN698@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	xor	ebx, ebx
	npad	2
$LL6@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 394  :             if ( index > 0 )

	test	edi, edi
	je	SHORT $LN14@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	ecx, DWORD PTR [esi+16]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN14@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	lea	ecx, DWORD PTR [esi+16]
	push	-1
	push	0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 392  :          for ( unsigned index =0; index < size; ++index )

	inc	edi
	add	ebx, 24					; 00000018H
	cmp	edi, DWORD PTR _size$1$[ebp]
	jb	SHORT $LL6@writeArray
$LN698@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR tv1647[ebp]
	push	2
	push	OFFSET ??_C@_02DHOGEDBE@?5?$FN?$AA@
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN10@writeArray:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 401  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeArrayValue
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_members$2 = -80					; size = 12
_value$GSCopy$1$ = -68					; size = 4
$T3 = -64						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
$T8 = -40						; size = 24
$T9 = -40						; size = 24
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC	; Json::StyledWriter::writeValue, COMDAT
; _this$ = ecx

; 292  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebx, DWORD PTR _value$[ebp]

; 293  :    switch ( value.type() )

	mov	ecx, ebx
	mov	DWORD PTR _value$GSCopy$1$[ebp], ebx
	call	?type@Value@Json@@QBE?AW4ValueType@2@XZ	; Json::Value::type
	cmp	eax, 7
	ja	$LN2@writeValue
	jmp	DWORD PTR $LN263@writeValue[eax*4]
$LN6@writeValue:

; 296  :       pushValue( "null" );

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 438  :    if ( addChildValues_ )

	cmp	BYTE PTR [edi+72], 0

; 439  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T12[ebp]

; 296  :       pushValue( "null" );

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 438  :    if ( addChildValues_ )

	je	SHORT $LN30@writeValue

; 439  :       childValues_.push_back( value );

	push	eax
	lea	ecx, DWORD PTR [edi+4]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 296  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 297  :       break;

	jmp	$LN2@writeValue
$LN30@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 441  :       document_ += value;

	lea	ecx, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 296  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 297  :       break;

	jmp	$LN2@writeValue
$LN7@writeValue:

; 298  :    case intValue:
; 299  :       pushValue( valueToString( value.asInt() ) );

	mov	ecx, ebx
	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1
$LN262@writeValue:
	push	eax
	mov	ecx, edi
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 300  :       break;

	jmp	$LN2@writeValue
$LN8@writeValue:

; 301  :    case uintValue:
; 302  :       pushValue( valueToString( value.asUInt() ) );

	mov	ecx, ebx
	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 303  :       break;

	jmp	SHORT $LN262@writeValue
$LN9@writeValue:

; 304  :    case realValue:
; 305  :       pushValue( valueToString( value.asDouble() ) );

	mov	ecx, ebx
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	lea	eax, DWORD PTR $T9[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 306  :       break;

	jmp	SHORT $LN262@writeValue
$LN10@writeValue:

; 307  :    case stringValue:
; 308  :       pushValue( valueToQuotedString( value.asCString() ) );

	mov	ecx, ebx
	call	?asCString@Value@Json@@QBEPBDXZ		; Json::Value::asCString
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 309  :       break;

	jmp	SHORT $LN262@writeValue
$LN11@writeValue:

; 310  :    case booleanValue:
; 311  :       pushValue( valueToString( value.asBool() ) );

	mov	ecx, ebx
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	eax, al
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 312  :       break;

	jmp	$LN262@writeValue
$LN12@writeValue:

; 313  :    case arrayValue:
; 314  :       writeArrayValue( value);

	push	ebx
	mov	ecx, edi
	call	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue

; 315  :       break;

	jmp	$LN2@writeValue
$LN13@writeValue:

; 318  :          Value::Members members( value.getMemberNames() );

	lea	eax, DWORD PTR _members$2[ebp]
	mov	ecx, ebx
	push	eax
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR _members$2[ebp]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 320  :             pushValue( "{}" );

	lea	ecx, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	cmp	eax, DWORD PTR _members$2[ebp+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 318  :          Value::Members members( value.getMemberNames() );

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	sete	al
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 319  :          if ( members.empty() )

	test	al, al
	je	SHORT $LN14@writeValue

; 320  :             pushValue( "{}" );

	push	OFFSET ??_C@_02MCILKGOH@?$HL?$HN?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T6[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	mov	ecx, edi
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	lea	ecx, DWORD PTR $T6[ebp]

; 321  :          else

	jmp	$LN261@writeValue
$LN14@writeValue:

; 322  :          {
; 323  :             writeWithIndent( "{" );

	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	eax
	mov	ecx, edi
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	lea	ecx, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 324  :             indent();

	mov	ecx, edi
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 46   : 		: _Ptr(_Parg)

	mov	esi, DWORD PTR _members$2[ebp]
$LL4@writeValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 329  :                const Value &childValue = value[name];

	push	esi
	mov	ecx, ebx
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	ebx, eax

; 330  :                writeCommentBeforeValue( childValue );

	mov	ecx, edi
	push	ebx
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN99@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN100@writeValue
$LN99@writeValue:
	mov	eax, esi
$LN100@writeValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 331  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T4[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 331  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN109@writeValue

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN109@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	3
	push	OFFSET ??_C@_03MCPBMLDJ@?5?3?5?$AA@
	lea	ecx, DWORD PTR [edi+16]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 333  :                writeValue( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 113  : 		++_Ptr;

	add	esi, 24					; 00000018H

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR _members$2[ebp+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 334  :                if ( ++it == members.end() )

	je	SHORT $LN257@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR [edi+16]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 340  :                writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 341  :             }

	mov	ebx, DWORD PTR _value$GSCopy$1$[ebp]
	jmp	$LL4@writeValue
$LN257@writeValue:

; 335  :                {
; 336  :                   writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 342  :             unindent();

	mov	ecx, edi
	call	?unindent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::unindent

; 343  :             writeWithIndent( "}" );

	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	push	eax
	mov	ecx, edi
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	lea	ecx, DWORD PTR $T3[ebp]
$LN261@writeValue:
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 344  :          }
; 345  :       }

	lea	ecx, DWORD PTR _members$2[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN2@writeValue:

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN263@writeValue:
	DD	$LN6@writeValue
	DD	$LN7@writeValue
	DD	$LN8@writeValue
	DD	$LN9@writeValue
	DD	$LN10@writeValue
	DD	$LN11@writeValue
	DD	$LN12@writeValue
	DD	$LN13@writeValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR _members$2[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$7:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$8:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$9:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$10:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::StyledWriter::writeValue
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC ; Json::StyledWriter::write, COMDAT
; _this$ = ecx

; 278  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 279  :    document_ = "";

	lea	ebx, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, ebx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 281  :    indentString_ = "";

	lea	ecx, DWORD PTR [edi+40]
	mov	BYTE PTR [edi+72], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 282  :    writeCommentBeforeValue( root );

	mov	esi, DWORD PTR _root$[ebp]
	mov	ecx, edi
	push	esi
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 283  :    writeValue( root );

	push	esi
	mov	ecx, edi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 284  :    writeCommentAfterValueOnSameLine( root );

	push	esi
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, esi
	push	-1
	push	0
	push	ebx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 286  :    return document_;

	mov	eax, esi
	pop	esi
	pop	ebx

; 287  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::StyledWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
;	COMDAT ??1StyledWriter@Json@@UAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
??1StyledWriter@Json@@UAE@XZ PROC			; Json::StyledWriter::~StyledWriter, COMDAT
; _this$ = ecx

; 69   :       virtual ~StyledWriter(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	lea	esi, DWORD PTR [edi+40]
	mov	DWORD PTR [edi], OFFSET ??_7StyledWriter@Json@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@StyledWrit
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN9@StyledWrit:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@StyledWrit
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN101@StyledWrit:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 69   :       virtual ~StyledWriter(){}

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN114@StyledWrit
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN114@StyledWrit:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN206@StyledWrit
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN206@StyledWrit:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 69   :       virtual ~StyledWriter(){}

	lea	ebx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN323@StyledWrit
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[ebp]
	push	ebx
	push	DWORD PTR [ebx+4]
	push	eax
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	esi, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, esi
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	esi
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [ebx+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [ebx+8], 0
$LN323@StyledWrit:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 177  : {

	mov	DWORD PTR [edi], OFFSET ??_7Writer@Json@@6B@
	pop	edi
	pop	esi
	pop	ebx
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 69   :       virtual ~StyledWriter(){}

	mov	esp, ebp
	pop	ebp
	ret	0
??1StyledWriter@Json@@UAE@XZ ENDP			; Json::StyledWriter::~StyledWriter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??0StyledWriter@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0StyledWriter@Json@@QAE@XZ PROC			; Json::StyledWriter::StyledWriter, COMDAT
; _this$ = ecx

; 272  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ecx], OFFSET ??_7StyledWriter@Json@@6B@

; 273  : }

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx+4], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+8], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+36], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+32], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+60], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+56], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+40], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 272  : {

	mov	DWORD PTR _this$[ebp], ecx

; 270  :    : rightMargin_( 74 )

	mov	DWORD PTR [ecx+64], 74			; 0000004aH

; 271  :    , indentSize_( 3 )

	mov	DWORD PTR [ecx+68], 3

; 273  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??0StyledWriter@Json@@QAE@XZ ENDP			; Json::StyledWriter::StyledWriter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??_GFastWriter@Json@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GFastWriter@Json@@UAEPAXI@Z PROC			; Json::FastWriter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 33   :       virtual ~FastWriter(){}

	lea	esi, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], OFFSET ??_7FastWriter@Json@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN13@scalar:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN105@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN105@scalar:
	test	BYTE PTR ___flags$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 177  : {

	mov	DWORD PTR [edi], OFFSET ??_7Writer@Json@@6B@
	je	SHORT $LN115@scalar
	push	32					; 00000020H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN115@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_GFastWriter@Json@@UAEPAXI@Z ENDP			; Json::FastWriter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_members$2 = -84					; size = 12
tv802 = -72						; size = 4
_size$1$ = -72						; size = 4
tv806 = -68						; size = 4
$T3 = -64						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
$T8 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z PROC	; Json::FastWriter::writeValue, COMDAT
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _value$[ebp]

; 210  :    switch ( value.type() )

	mov	ecx, edi
	call	?type@Value@Json@@QBE?AW4ValueType@2@XZ	; Json::Value::type
	cmp	eax, 7
	ja	$LN2@writeValue
	jmp	DWORD PTR $LN322@writeValue[eax*4]
$LN10@writeValue:

; 211  :    {
; 212  :    case nullValue:
; 213  :       document_ += "null";

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 214  :       break;

	jmp	$LN2@writeValue
$LN11@writeValue:

; 216  :       document_ += valueToString( value.asInt() );

	mov	ecx, edi
	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN321@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 216  :       document_ += valueToString( value.asInt() );

	lea	ecx, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 216  :       document_ += valueToString( value.asInt() );

	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 217  :       break;

	jmp	$LN2@writeValue
$LN12@writeValue:

; 218  :    case uintValue:
; 219  :       document_ += valueToString( value.asUInt() );

	mov	ecx, edi
	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 220  :       break;

	jmp	SHORT $LN321@writeValue
$LN13@writeValue:

; 221  :    case realValue:
; 222  :       document_ += valueToString( value.asDouble() );

	mov	ecx, edi
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	lea	eax, DWORD PTR $T6[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 223  :       break;

	jmp	SHORT $LN321@writeValue
$LN14@writeValue:

; 224  :    case stringValue:
; 225  :       document_ += valueToQuotedString( value.asCString() );

	mov	ecx, edi
	call	?asCString@Value@Json@@QBEPBDXZ		; Json::Value::asCString
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 226  :       break;

	jmp	SHORT $LN321@writeValue
$LN15@writeValue:

; 227  :    case booleanValue:
; 228  :       document_ += valueToString( value.asBool() );

	mov	ecx, edi
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	eax, al
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 229  :       break;

	jmp	$LN321@writeValue
$LN16@writeValue:

; 230  :    case arrayValue:
; 231  :       {
; 232  :          document_ += "[";

	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 233  :          int size = value.size();

	mov	ecx, edi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size

; 234  :          for ( int index =0; index < size; ++index )

	xor	esi, esi
	mov	DWORD PTR _size$1$[ebp], eax
	test	eax, eax
	jle	SHORT $LN62@writeValue
	npad	6
$LL6@writeValue:

; 235  :          {
; 236  :             if ( index > 0 )

	test	esi, esi
	jle	SHORT $LN17@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN17@writeValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 238  :             writeValue( value[index] );

	push	esi
	mov	ecx, edi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, ebx
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
	inc	esi
	cmp	esi, DWORD PTR _size$1$[ebp]
	jl	SHORT $LL6@writeValue
$LN62@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 242  :       break;

	jmp	$LN2@writeValue
$LN18@writeValue:

; 243  :    case objectValue:
; 244  :       {
; 245  :          Value::Members members( value.getMemberNames() );

	lea	eax, DWORD PTR _members$2[ebp]
	mov	ecx, edi
	push	eax
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames

; 246  :          document_ += "{";

	lea	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	mov	ecx, eax
	mov	DWORD PTR tv806[ebp], eax
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR _members$2[ebp]
	mov	esi, eax

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR _members$2[ebp+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 248  :                it != members.end(); 

	je	$LN319@writeValue
	npad	1
$LL9@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 252  :             if ( it != members.begin() )

	je	SHORT $LN19@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN19@writeValue:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN177@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN178@writeValue
$LN177@writeValue:
	mov	eax, esi
$LN178@writeValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 254  :             document_ += valueToQuotedString( name.c_str() );

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR [ebx+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 254  :             document_ += valueToQuotedString( name.c_str() );

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 254  :             document_ += valueToQuotedString( name.c_str() );

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN191@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN191@writeValue:
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 255  :             document_ += yamlCompatiblityEnabled_ ? ": " 

	cmp	BYTE PTR [ebx+28], 0
	mov	edx, OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	mov	eax, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
	cmove	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN296@writeValue
	xor	ecx, ecx
	jmp	SHORT $LN297@writeValue
$LN296@writeValue:
	mov	ecx, edx
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv802[ebp], eax
	npad	6
$LL314@writeValue:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL314@writeValue
	sub	ecx, DWORD PTR tv802[ebp]
$LN297@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 257  :             writeValue( value[name] );

	push	esi
	mov	ecx, edi
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	push	eax
	mov	ecx, ebx
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 113  : 		++_Ptr;

	add	esi, 24					; 00000018H

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR _members$2[ebp+4]
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 248  :                it != members.end(); 

	je	SHORT $LN319@writeValue
	mov	eax, DWORD PTR _members$2[ebp]
	jmp	$LL9@writeValue
$LN319@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR tv806[ebp]
	push	1
	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 260  :       }

	lea	ecx, DWORD PTR _members$2[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN2@writeValue:

; 261  :       break;
; 262  :    }
; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN322@writeValue:
	DD	$LN10@writeValue
	DD	$LN11@writeValue
	DD	$LN12@writeValue
	DD	$LN13@writeValue
	DD	$LN14@writeValue
	DD	$LN15@writeValue
	DD	$LN16@writeValue
	DD	$LN18@writeValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR _members$2[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::FastWriter::writeValue
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC ; Json::FastWriter::write, COMDAT
; _this$ = ecx

; 199  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR $T1[ebp], 0
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 200  :    document_ = "";

	lea	edi, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 201  :    writeValue( root );

	push	DWORD PTR _root$[ebp]
	mov	ecx, esi
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, esi
	push	-1
	push	0
	push	edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 203  :    return document_;

	mov	eax, esi
	pop	esi

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::FastWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ
_TEXT	SEGMENT
?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ PROC	; Json::FastWriter::enableYAMLCompatibility, COMDAT
; _this$ = ecx

; 193  :    yamlCompatiblityEnabled_ = true;

	mov	BYTE PTR [ecx+28], 1

; 194  : }

	ret	0
?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ ENDP	; Json::FastWriter::enableYAMLCompatibility
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h
;	COMDAT ??1FastWriter@Json@@UAE@XZ
_TEXT	SEGMENT
??1FastWriter@Json@@UAE@XZ PROC				; Json::FastWriter::~FastWriter, COMDAT
; _this$ = ecx

; 33   :       virtual ~FastWriter(){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7FastWriter@Json@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@FastWriter
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+4]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN9@FastWriter:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+24], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+20], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@FastWriter
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 177  : {

	mov	DWORD PTR [esi], OFFSET ??_7Writer@Json@@6B@
	pop	esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 33   :       virtual ~FastWriter(){}

	ret	0
$LN101@FastWriter:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+4], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 177  : {

	mov	DWORD PTR [esi], OFFSET ??_7Writer@Json@@6B@
	pop	esi
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\include\json\writer.h

; 33   :       virtual ~FastWriter(){}

	ret	0
??1FastWriter@Json@@UAE@XZ ENDP				; Json::FastWriter::~FastWriter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??0FastWriter@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FastWriter@Json@@QAE@XZ PROC				; Json::FastWriter::FastWriter, COMDAT
; _this$ = ecx

; 186  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ecx], OFFSET ??_7FastWriter@Json@@6B@

; 187  : }

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+4], 0
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 186  : {

	mov	DWORD PTR _this$[ebp], ecx

; 185  :    : yamlCompatiblityEnabled_( false )

	mov	BYTE PTR [ecx+28], 0

; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??0FastWriter@Json@@QAE@XZ ENDP				; Json::FastWriter::FastWriter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??_GWriter@Json@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GWriter@Json@@UAEPAXI@Z PROC				; Json::Writer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 177  : {

	mov	DWORD PTR [esi], OFFSET ??_7Writer@Json@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GWriter@Json@@UAEPAXI@Z ENDP				; Json::Writer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Writer@Json@@QAE@XZ
_TEXT	SEGMENT
??0Writer@Json@@QAE@XZ PROC				; Json::Writer::Writer, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7Writer@Json@@6B@
	mov	eax, ecx
	ret	0
??0Writer@Json@@QAE@XZ ENDP				; Json::Writer::Writer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lonycell\downloads\jsoncpp-src-0.5.0.tar\dist\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??1Writer@Json@@UAE@XZ
_TEXT	SEGMENT
??1Writer@Json@@UAE@XZ PROC				; Json::Writer::~Writer, COMDAT
; _this$ = ecx

; 177  : {

	mov	DWORD PTR [ecx], OFFSET ??_7Writer@Json@@6B@

; 178  : }

	ret	0
??1Writer@Json@@UAE@XZ ENDP				; Json::Writer::~Writer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?uppercase@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?uppercase@std@@YAAAVios_base@1@AAV21@@Z PROC		; std::uppercase, COMDAT

; 358  : 	{	// set uppercase

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 391  : 		_Fmtfl = (fmtflags)((int)_Fmtfl

	mov	eax, DWORD PTR __Iosbase$[ebp]
	or	DWORD PTR [eax+20], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 361  : 	}

	pop	ebp
	ret	0
?uppercase@std@@YAAAVios_base@1@AAV21@@Z ENDP		; std::uppercase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?hex@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?hex@std@@YAAAVios_base@1@AAV21@@Z PROC			; std::hex, COMDAT

; 238  : 	{	// set basefield to hex

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 399  : 		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)

	mov	eax, DWORD PTR __Iosbase$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, -1537				; fffff9ffH
	or	ecx, 2048				; 00000800H
	mov	DWORD PTR [eax+20], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 241  : 	}

	pop	ebp
	ret	0
?hex@std@@YAAAVios_base@1@AAV21@@Z ENDP			; std::hex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN10@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN10@scalar:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN102@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN103@scalar
$LN102@scalar:
	mov	eax, esi
$LN103@scalar:
	test	BYTE PTR ___flags$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	je	SHORT $LN109@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN109@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jae	SHORT $LN2@Check_offs

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN18@Check_offs:
$LN2@Check_offs:

; 2272 : 			_Xran();
; 2273 : 		}

	pop	ebp
	ret	4
$LN17@Check_offs:
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 2249 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN57@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN57@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	eax, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ebx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	ebx
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN96@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
$LN96@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN17@Inside
$LN16@Inside:
	mov	esi, ecx
$LN17@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	edx, esi
	jb	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN30@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN31@Inside
$LN30@Inside:
	mov	esi, ecx
$LN31@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [ecx+16]
	add	eax, esi
	cmp	eax, edx
	jbe	SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

	mov	al, 1
	pop	esi

; 2244 : 		}

	pop	ebp
	ret	4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2244 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	esi

; 2225 : 		if (max_size() < _Newsize)

	mov	esi, DWORD PTR __Newsize$[ebp]
	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN2@Grow

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN90@Grow:
$LN2@Grow:

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], esi
	jae	SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [ecx+16]
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	esi, esi
	pop	esi
	setne	al

; 2235 : 		}

	pop	ebp
	ret	8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN5@Grow
	cmp	esi, 16					; 00000010H
	jae	SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

	mov	eax, DWORD PTR [ecx+16]
	cmp	esi, eax
	cmovb	eax, esi
	push	eax
	push	1
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	test	esi, esi
	pop	esi
	setne	al

; 2235 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $LN88@Grow

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], esi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN80@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN80@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
	test	esi, esi
$LN88@Grow:
	setne	al
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2235 : 		}

	pop	ebp
	ret	8
$LN89@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, eax
	or	edi, 15					; 0000000fH

; 2184 : 		if (max_size() < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

	jmp	SHORT $LN108@Copy
$LN2@Copy:
	mov	ebx, DWORD PTR [esi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

	mov	eax, -2					; fffffffeH

; 2189 : 			_Newres = this->_Myres()

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN108@Copy

; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	edi, -2					; fffffffeH
$LN108@Copy:

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 51   : 	if (_Count == 0)

	test	eax, eax
	jne	SHORT $LN136@Copy

; 52   : 		return (_Ptr);

	xor	ebx, ebx
	jmp	SHORT $LN19@Copy
$LN136@Copy:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)
; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;
; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN138@Copy

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN140@Copy

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN443@Copy:
$LN140@Copy:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	eax, eax
	jne	SHORT $LN141@Copy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN444@Copy:
$LN141@Copy:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

	jmp	SHORT $LN19@Copy
$LN138@Copy:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	ebx, ebx
	jne	SHORT $LN19@Copy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN445@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

	mov	eax, $LN440@Copy
	ret	0
$LN440@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	mov	eax, DWORD PTR __Oldlen$[ebp]
	test	eax, eax
	je	SHORT $LN274@Copy

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN265@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN266@Copy
$LN265@Copy:
	mov	ecx, esi
$LN266@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN274@Copy
	push	eax
	push	ecx
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN274@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN278@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN278@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN370@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN371@Copy
$LN370@Copy:
	mov	eax, esi
$LN371@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Oldlen$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2212 : 		this->_Myres() = _Newres;

	mov	DWORD PTR [esi+20], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN434@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, ebx
$LN434@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR _this$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN156@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN156@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN249@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN249@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	call	__CxxThrowException@8
$LN446@Copy:
$LN442@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

	push	ebp
	mov	ebp, esp

; 2175 : 		if (_Count == 1)

	mov	eax, DWORD PTR __Count$[ebp]
	mov	edx, ecx
	cmp	eax, 1
	jne	SHORT $LN2@Chassign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN16@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN16@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	eax, DWORD PTR __Off$[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx+eax], cl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Chassign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN33@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN33@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

	push	ebp
	mov	ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	DWORD PTR __Size$[ebp], eax
	cmovbe	eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 1793 : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	eax, DWORD PTR __Newcap$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, eax
	ja	SHORT $LN47@reserve
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN47@reserve

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN47@reserve

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN42@reserve
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN42@reserve:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
$LN47@reserve:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1800 : 		}

	pop	ebp
	ret	4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1780 : 		{	// determine new length, padding with _Ch elements as needed

	push	ebp
	mov	ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, edx
	ja	SHORT $LN2@resize

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN25@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN25@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1785 : 		}

	pop	ebp
	ret	8
$LN2@resize:

; 1782 : 			_Eos(_Newsize);
; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	sub	eax, edx
	mov	DWORD PTR __Newsize$[ebp], eax

; 1785 : 		}

	pop	ebp

; 1782 : 			_Eos(_Newsize);
; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1775 : 		{	// determine new length, padding with null elements as needed

	push	ebp
	mov	ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, edx
	ja	SHORT $LN4@resize

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN27@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN27@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1777 : 		}

	pop	ebp
	ret	4
$LN4@resize:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1777 : 		}

	pop	ebp
	ret	4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1772 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1766 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1761 : 		}

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN13@c_str

; 1743 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 1744 : 		}

	ret	0
$LN13@c_str:

; 1743 : 		return (this->_Myptr());

	mov	eax, ecx

; 1744 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1688 : 		return (this->_Myptr()[_Off]);

	mov	eax, DWORD PTR __Off$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN13@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1688 : 		return (this->_Myptr()[_Off]);

	add	eax, ecx

; 1689 : 		}

	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, ecx
	jae	SHORT $LN7@erase

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN94@erase:
$LN7@erase:

; 1348 : 		_Check_offset(_Off);
; 1349 : 		if (this->_Mysize() - _Off <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, ecx
	cmp	eax, edx
	ja	SHORT $LN2@erase

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN41@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN41@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1359 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1351 : 		else if (0 < _Count)

	test	edx, edx
	je	SHORT $LN90@erase

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN58@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN59@erase
$LN58@erase:
	mov	eax, esi
$LN59@erase:

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN74@erase
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	push	ebx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN74@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi
	pop	ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN85@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN85@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN90@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN93@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jae	SHORT $LN4@erase

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN38@erase:
$LN4@erase:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN29@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	pop	ebp
	ret	4
$LN29@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	pop	ebp
	ret	4
$LN37@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@insert
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi

; 1274 : 		}

	pop	ebp
	ret	8
$LN5@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@insert:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@insert
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi

; 1274 : 		}

	pop	ebp
	ret	8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
tv774 = -4						; size = 4
__Off$ = 8						; size = 4
tv775 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN21@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN22@insert
$LN21@insert:
	mov	eax, esi
$LN22@insert:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN35@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN36@insert
$LN35@insert:
	mov	edx, esi
$LN36@insert:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN58@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN59@insert
$LN58@insert:
	mov	eax, esi
$LN59@insert:

; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))
; 1253 : 			return (insert(_Off, *this,

	push	DWORD PTR __Count$[ebp]
	sub	ebx, eax
	mov	ecx, esi
	push	ebx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@insert:

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN63@insert

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN265@insert:
$LN63@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);
; 1256 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, ecx
	not	eax
	cmp	eax, edx
	ja	SHORT $LN3@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN266@insert:
$LN3@insert:
	push	edi

; 1257 : 			_Xlen();	// result too long
; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+edx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

	test	edx, edx
	je	$LN258@insert

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN99@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN267@insert:
$LN99@insert:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN100@insert

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	edx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1259 : 		if (0 < _Count && _Grow(_Num))

	je	$LN258@insert
$LN263@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN203@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv775[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN204@insert
$LN100@insert:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN263@insert

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN177@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN177@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN203@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv775[ebp], esi
$LN204@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN217@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv774[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN218@insert
$LN217@insert:
	mov	DWORD PTR tv774[ebp], esi
$LN218@insert:

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN224@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv775[ebp]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv774[ebp]
	add	eax, ecx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	mov	ecx, DWORD PTR __Off$[ebp]
	add	esp, 12					; 0000000cH
$LN224@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN235@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN236@insert
$LN235@insert:
	mov	edx, esi
$LN236@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	je	SHORT $LN242@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN242@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN253@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN253@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN258@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN264@insert:
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv859 = 8						; size = 4
tv856 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv848 = 16						; size = 4
__Roff$ = 16						; size = 4
tv861 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN10@insert

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN286@insert:
$LN10@insert:

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Roff$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, edx
	jae	SHORT $LN26@insert

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN287@insert:
$LN26@insert:

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, edx
	cmp	edi, eax
	cmova	edi, eax

; 1224 : 		_Check_offset(_Off);
; 1225 : 		_Right._Check_offset(_Roff);
; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1227 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
	cmp	eax, edi
	ja	SHORT $LN2@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN288@insert:
$LN2@insert:

; 1228 : 			_Xlen();	// result too long
; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

	test	edi, edi
	je	$LN279@insert

; 2225 : 		if (max_size() < _Newsize)

	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN74@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN289@insert:
$LN74@insert:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], ebx
	jae	SHORT $LN75@insert

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	ebx, ebx

; 1231 : 		if (0 < _Count && _Grow(_Num))

	je	$LN279@insert
$LN283@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN178@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv861[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN179@insert
$LN75@insert:

; 2232 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN283@insert

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN152@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN152@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN178@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv861[ebp], esi
$LN179@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN192@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN193@insert
$LN192@insert:
	mov	ecx, esi
$LN193@insert:

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Off$[ebp]
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN199@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv861[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ecx+edx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	mov	edx, DWORD PTR __Off$[ebp]
	add	esp, 12					; 0000000cH
$LN199@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1236 : 			if (this == &_Right)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	esi, eax
	jne	SHORT $LN4@insert
	mov	eax, DWORD PTR __Roff$[ebp]
	cmp	edx, eax
	lea	ecx, DWORD PTR [eax+edi]
	cmovae	ecx, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR tv848[ebp], ecx
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN210@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv859[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN211@insert
$LN210@insert:
	mov	DWORD PTR tv859[ebp], esi
$LN211@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN224@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN225@insert
$LN224@insert:
	mov	ecx, esi
$LN225@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN263@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv848[ebp]
	add	eax, DWORD PTR tv859[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [ecx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1240 : 			else

	jmp	SHORT $LN284@insert
$LN4@insert:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN242@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN242@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN256@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv856[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN257@insert
$LN256@insert:
	mov	DWORD PTR tv856[ebp], esi
$LN257@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN263@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

	add	eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv856[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memcpy
$LN284@insert:
	add	esp, 12					; 0000000cH
$LN263@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN274@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN274@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
$LN279@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN285@insert:
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1186 : 		{	// assign _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1187 : 		if (_Count == npos)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	esi, ecx
	cmp	edi, -1
	jne	SHORT $LN2@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN152@assign:
$LN2@assign:

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN9@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN153@assign:
$LN9@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN10@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1188 : 			_Xlen();	// result too long
; 1189 : 
; 1190 : 		if (_Grow(_Count))

	je	SHORT $LN146@assign
$LN150@assign:

; 2175 : 		if (_Count == 1)

	cmp	edi, 1
	jne	SHORT $LN95@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN108@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2177 : 		else

	jmp	SHORT $LN96@assign
$LN10@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN150@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN87@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1195 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1196 : 		}

	pop	ebp
	ret	8
$LN87@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1196 : 		}

	pop	ebp
	ret	8
$LN108@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2177 : 		else

	jmp	SHORT $LN96@assign
$LN95@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN125@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN126@assign
$LN125@assign:
	mov	ecx, esi
$LN126@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	edi
	push	eax
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN96@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN141@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1195 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1196 : 		}

	pop	ebp
	ret	8
$LN141@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN146@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1195 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1196 : 		}

	pop	ebp
	ret	8
$LN151@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@assign
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@assign:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@assign
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN21@assign
$LN20@assign:
	mov	eax, esi
$LN21@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN34@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN35@assign
$LN34@assign:
	mov	edx, esi
$LN35@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN57@assign

; 1168 : 			return (assign(*this,

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1168 : 			return (assign(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN57@assign:

; 1168 : 			return (assign(*this,

	push	DWORD PTR __Count$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1168 : 			return (assign(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 2225 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN62@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN188@assign:
$LN62@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN63@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

	je	SHORT $LN181@assign
$LN186@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN158@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN159@assign
$LN63@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN186@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN140@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN140@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1177 : 		}

	pop	ebp
	ret	8
$LN158@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
$LN159@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN165@assign
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN165@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN176@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN176@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN181@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN187@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jae	SHORT $LN7@assign

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN209@assign:
$LN7@assign:

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, ecx
	cmp	edi, eax
	cmova	edi, eax

; 1150 : 		_Right._Check_offset(_Roff);
; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1152 : 
; 1153 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	lea	eax, DWORD PTR [ecx+edi]

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], eax
	jae	SHORT $LN38@assign

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN210@assign:
$LN38@assign:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN63@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN63@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN71@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN211@assign:
$LN71@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN72@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1155 : 		else if (_Grow(_Count))

	je	SHORT $LN203@assign
$LN207@assign:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN166@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN166@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN180@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN181@assign
$LN72@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN207@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN149@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN149@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN180@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN181@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN187@assign
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1157 : 			_Traits::copy(this->_Myptr(),

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN187@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN198@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN198@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN203@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN208@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ebx

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, ebx
	ja	SHORT $LN2@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN142@append:
$LN2@append:

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+ebx]

; 1116 : 		if (0 < _Count && _Grow(_Num))

	test	ebx, ebx
	je	SHORT $LN136@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN143@append:
$LN27@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN28@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN136@append
$LN140@append:

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, esi
	push	ebx
	push	DWORD PTR [esi+16]
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN131@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN28@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN140@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN105@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN105@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1122 : 		}

	pop	ebp
	ret	8
$LN131@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN136@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN141@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@append
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1108 : 		}

	pop	ebp
	ret	4
$LN5@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@append:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@append
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1108 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN21@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN22@append
$LN21@append:
	mov	eax, esi
$LN22@append:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN35@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN36@append
$LN35@append:
	mov	edx, esi
$LN36@append:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN58@append

; 1090 : 			return (append(*this,

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1090 : 			return (append(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN58@append:

; 1090 : 			return (append(*this,

	push	DWORD PTR __Count$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1090 : 			return (append(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR [esi+16]
	mov	eax, edx
	mov	ecx, DWORD PTR __Count$[ebp]
	not	eax
	cmp	eax, ecx
	ja	SHORT $LN3@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN218@append:
$LN3@append:
	push	edi

; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

	test	ecx, ecx
	je	$LN211@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN84@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN219@append:
$LN84@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN85@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1096 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN211@append
$LN216@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN179@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN180@append
$LN85@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN216@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN162@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN162@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1102 : 		}

	pop	ebp
	ret	8
$LN179@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN180@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	ecx, ecx
	je	SHORT $LN195@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN195@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN206@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN206@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN211@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN217@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jae	SHORT $LN6@append

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN202@append:
$LN6@append:

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR [esi+16]

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	sub	eax, ecx

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, eax
	cmova	ecx, eax

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, edx
	not	eax

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	DWORD PTR __Count$[ebp], ecx

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	cmp	eax, ecx
	ja	SHORT $LN2@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN203@append:
$LN2@append:

; 1074 : 			_Xlen();	// result too long
; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

	test	ecx, ecx
	je	$LN196@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN55@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN204@append:
$LN55@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN56@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1077 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN196@append
$LN200@append:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN150@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN150@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN164@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN165@append
$LN56@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN200@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN133@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN133@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN164@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN165@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	ecx, ecx
	je	SHORT $LN180@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ecx
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN180@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN191@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN191@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN196@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN201@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1066 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1059 : 		{	// append 1 * _Ch

	push	ebp
	mov	ebp, esp

; 1060 : 		return (append((size_type)1, _Ch));

	push	DWORD PTR __Ch$[ebp]
	push	1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1061 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1054 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN7@operator
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1055 : 		return (append(_Ptr));
; 1056 : 		}

	pop	ebp
	ret	4
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL9@operator:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL9@operator
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1055 : 		return (append(_Ptr));
; 1056 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1049 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1050 : 		return (append(_Right));
; 1051 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN7@operator
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1040 : 		return (assign(_Ptr));
; 1041 : 		}

	pop	ebp
	ret	4
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL9@operator:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL9@operator
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1040 : 		return (assign(_Ptr));
; 1041 : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN6@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN6@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN98@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
$LN98@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 961  : 		{	// assign by moving _Right

	mov	edi, ecx

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN3@Assign_rv
	push	eax
	push	esi
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN3@Assign_rv
$LN2@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN84@Assign_rv
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
$LN84@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN231@Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	pop	ebp
	ret	4
$LN231@Assign_rv:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	pop	ebp
	ret	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	esi, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 850  : 		{	// construct from _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	esi

; 852  : 		assign(_Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	esi, ecx
	push	DWORD PTR __Count$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 852  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 853  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	ecx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN115@basic_stri
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN115@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, ecx
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL117@basic_stri:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL117@basic_stri
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 822  : 		{	// construct from [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	esi

; 824  : 		assign(_Ptr, _Count);

	push	DWORD PTR __Count$[ebp]
	mov	esi, ecx
	push	DWORD PTR __Ptr$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 825  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 796  : 		}

	mov	eax, ecx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 796  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 735  : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 730  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 725  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

	mov	eax, ecx

; 715  : 		}

	ret	0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 708  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 703  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 698  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 693  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 590  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 590  : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 583  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 584  : 		}

	ret	0
$LN11@Myptr:

; 583  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 584  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 579  : 		}

	ret	0
$LN11@Myptr:

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 579  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 499  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate
$LN15@allocate:

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN10@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN11@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN11@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN15@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN17@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 875  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	or	eax, -1

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 750  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@allocate:
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

	or	eax, -1

; 607  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 600  : 		{	// return anything but EOF

	push	ebp
	mov	ebp, esp

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, -1
	cmovne	eax, ecx

; 602  : 		}

	pop	ebp
	ret	0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 594  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 595  : 		return (_Left == _Right);
; 596  : 		}

	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 588  : 		{	// convert character to metacharacter

	push	ebp
	mov	ebp, esp

; 589  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, BYTE PTR [eax]

; 590  : 		}

	pop	ebp
	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 582  : 		{	// convert metacharacter to character

	push	ebp
	mov	ebp, esp

; 583  : 		return ((_Elem)_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	al, BYTE PTR [eax]

; 584  : 		}

	pop	ebp
	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT

; 570  : 		{	// test for element equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	cl, BYTE PTR [eax]
	sete	al

; 571  : 		return (_Left == _Right);
; 572  : 		}

	pop	ebp
	ret	0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 565  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 566  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR __Count$[ebp]
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	push	DWORD PTR __First$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 561  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	pop	ebp
	ret	0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

	mov	DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	pop	ebp

; 553  : 		return (_Count == 0 ? _First1

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp
	ret	0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

	mov	DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp

; 530  : 		return (_Count == 0 ? _First1

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 523  : 		return (*_First == 0 ? 0

	mov	eax, DWORD PTR __First$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	pop	ebp
	ret	0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

	lea	edx, DWORD PTR [eax+1]
$LL5@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@length
	sub	eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

	push	ebp
	mov	ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 90   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1834 :     {

	push	ebp
	mov	ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }

	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1493 : {

	push	ebp
	mov	ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1499 : }

	pop	ebp
	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
